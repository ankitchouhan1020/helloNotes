{"config":{"lang":["en"],"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Some shortcuts to learn \"Many a little makes a mickle.\"","title":"Preface"},{"location":"#some-shortcuts-to-learn","text":"\"Many a little makes a mickle.\"","title":"Some shortcuts to learn"},{"location":"color/","text":"Primary colors Default: Teal Click on a tile to change the primary color of the theme: Red Pink Purple Deep Purple Indigo Blue Light Blue Cyan Teal Green Light Green Lime Yellow Amber Orange Deep Orange Brown Grey Blue Grey White var buttons = document.querySelectorAll(\"button[data-md-color-primary]\"); Array.prototype.forEach.call(buttons, function(button) { button.addEventListener(\"click\", function() { document.body.dataset.mdColorPrimary = this.dataset.mdColorPrimary; }) }) Accent colors Default: Blue Click on a tile to change the accent color of the theme: Red Pink Purple Deep Purple Indigo Blue Light Blue Cyan Teal Green Light Green Lime Yellow Amber Orange Deep Orange var buttons = document.querySelectorAll(\"button[data-md-color-accent]\"); Array.prototype.forEach.call(buttons, function(button) { button.addEventListener(\"click\", function() { document.body.dataset.mdColorAccent = this.dataset.mdColorAccent; }) })","title":"Color"},{"location":"color/#primary-colors","text":"Default: Teal Click on a tile to change the primary color of the theme: Red Pink Purple Deep Purple Indigo Blue Light Blue Cyan Teal Green Light Green Lime Yellow Amber Orange Deep Orange Brown Grey Blue Grey White var buttons = document.querySelectorAll(\"button[data-md-color-primary]\"); Array.prototype.forEach.call(buttons, function(button) { button.addEventListener(\"click\", function() { document.body.dataset.mdColorPrimary = this.dataset.mdColorPrimary; }) })","title":"Primary colors"},{"location":"color/#accent-colors","text":"Default: Blue Click on a tile to change the accent color of the theme: Red Pink Purple Deep Purple Indigo Blue Light Blue Cyan Teal Green Light Green Lime Yellow Amber Orange Deep Orange var buttons = document.querySelectorAll(\"button[data-md-color-accent]\"); Array.prototype.forEach.call(buttons, function(button) { button.addEventListener(\"click\", function() { document.body.dataset.mdColorAccent = this.dataset.mdColorAccent; }) })","title":"Accent colors"},{"location":"LeetCodeLocked/c1.1/","text":"Factor Combinations Question Print all unique combination of factors (except 1) of a given number. For example: Input: 12 Output: [[2, 2, 3], [2, 6], [3, 4]] Input: 15 Output: [[3, 5]] Input: 28 Output: [[2, 2, 7], [2, 14], [4, 7]] Solution DFS 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 class Solution { public : vector vector int getFactors ( int n ) { vector vector int ret ; vector int cur ; dfs ( n , ret , cur , 1 , 2 ); return ret ; } void dfs ( int n , vector vector int ret , vector int cur , int product , int pos ){ if ( product == n ){ if ( ! cur . empty ()) ret . push_back ( cur ); } else if ( product n pos n ){ for ( int i = pos ; i n ; ++ i ){ if ( product * i n ) break ; // prune if ( n % i != 0 ) continue ; // prune cur . push_back ( i ); dfs ( n , ret , cur , product * i , i ); cur . pop_back (); } } } }; Another solution with Lambda expression 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 vector vector int factors_comb ( int n ) { vector vector int ret = {}; function void ( int , vector int ) dfs = [ ]( int num , vector int cur ) { int last = cur . empty () ? 2 : cur . back (); for ( int f = last ; f num ; ++ f ) { if ( num % f != 0 ) continue ; cur . push_back ( f ); dfs ( num / f , cur ); cur . pop_back (); } if ( ! cur . empty () num = last ) { cur . push_back ( num ); ret . push_back ( cur ); cur . pop_back (); } }; vector int cur = {}; dfs ( n , cur ); return ret ; }","title":"Factor Combinations"},{"location":"LeetCodeLocked/c1.1/#factor-combinations","text":"Question Print all unique combination of factors (except 1) of a given number. For example: Input: 12 Output: [[2, 2, 3], [2, 6], [3, 4]] Input: 15 Output: [[3, 5]] Input: 28 Output: [[2, 2, 7], [2, 14], [4, 7]] Solution DFS 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 class Solution { public : vector vector int getFactors ( int n ) { vector vector int ret ; vector int cur ; dfs ( n , ret , cur , 1 , 2 ); return ret ; } void dfs ( int n , vector vector int ret , vector int cur , int product , int pos ){ if ( product == n ){ if ( ! cur . empty ()) ret . push_back ( cur ); } else if ( product n pos n ){ for ( int i = pos ; i n ; ++ i ){ if ( product * i n ) break ; // prune if ( n % i != 0 ) continue ; // prune cur . push_back ( i ); dfs ( n , ret , cur , product * i , i ); cur . pop_back (); } } } }; Another solution with Lambda expression 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 vector vector int factors_comb ( int n ) { vector vector int ret = {}; function void ( int , vector int ) dfs = [ ]( int num , vector int cur ) { int last = cur . empty () ? 2 : cur . back (); for ( int f = last ; f num ; ++ f ) { if ( num % f != 0 ) continue ; cur . push_back ( f ); dfs ( num / f , cur ); cur . pop_back (); } if ( ! cur . empty () num = last ) { cur . push_back ( num ); ret . push_back ( cur ); cur . pop_back (); } }; vector int cur = {}; dfs ( n , cur ); return ret ; }","title":"Factor Combinations"},{"location":"LeetCodeLocked/c1.10/","text":"Flatten 2D Vector Question Implement an iterator to flatten a 2d vector. For example, Given 2d vector = [ [1,2], [3], [4,5,6] ] By calling __next__ repeatedly until __hasNext__ returns false, the order of elements returned by next should be: `[1, 2, 3, 4, 5, 6] . Solution The idea is very simple. We keep two variables row and col for the range of rows and cols. Specifically, row is the number of rows of vec2d and col is the number of columns of the current 1d vector in vec2d. We also keep two variables r and c to point to the current element. In the constructor, we initialize row and col as above and initialize both r and c to be 0(pointing to the first element). In hasNext(), we just need to check whether r and c are still in the range limited by row andcol. In next(), we first record the current element, which is returned later. Then we update the running indexes and possibly the range if the current element is the last element of the current 1d vector. A final and important note, since in next(), we record the current element, we need to guarantee that there is an element. So we implement a helper function skipEmptyVector() to skip the empty vectors. It is also important to handle the case that vec2d is empty (in this case, we set col = -1). The time complexity of hasNext() is obviously O(1) and the time complexity of next is alsoO(1) in an amortized sense. The code is as follows. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 //C++: 20ms class Vector2D { vector vector int :: iterator row_it , row_end ; vector int :: iterator col_it ; public : Vector2D ( vector vector int vec2d ) { row_it = vec2d . begin (); row_end = vec2d . end (); while ( row_it != row_end row_it - empty ()) row_it ++ ; if ( row_it != row_end ) col_it = row_it - begin (); } int next () { int v = * col_it ; col_it ++ ; if ( col_it == row_it - end ()){ row_it ++ ; while ( row_it != row_end row_it - empty ()) row_it ++ ; // skip empty rows if ( row_it != row_end ) col_it = row_it - begin (); } return v ; } bool hasNext () { if ( row_it == row_end ) return false ; return true ; } }; /** * Your Vector2D object will be instantiated and called as such: * Vector2D i(vec2d); * while (i.hasNext()) cout i.next(); */ another solution .","title":"Flatten 2D Vector"},{"location":"LeetCodeLocked/c1.10/#flatten-2d-vector","text":"Question Implement an iterator to flatten a 2d vector. For example, Given 2d vector = [ [1,2], [3], [4,5,6] ] By calling __next__ repeatedly until __hasNext__ returns false, the order of elements returned by next should be: `[1, 2, 3, 4, 5, 6] . Solution The idea is very simple. We keep two variables row and col for the range of rows and cols. Specifically, row is the number of rows of vec2d and col is the number of columns of the current 1d vector in vec2d. We also keep two variables r and c to point to the current element. In the constructor, we initialize row and col as above and initialize both r and c to be 0(pointing to the first element). In hasNext(), we just need to check whether r and c are still in the range limited by row andcol. In next(), we first record the current element, which is returned later. Then we update the running indexes and possibly the range if the current element is the last element of the current 1d vector. A final and important note, since in next(), we record the current element, we need to guarantee that there is an element. So we implement a helper function skipEmptyVector() to skip the empty vectors. It is also important to handle the case that vec2d is empty (in this case, we set col = -1). The time complexity of hasNext() is obviously O(1) and the time complexity of next is alsoO(1) in an amortized sense. The code is as follows. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 //C++: 20ms class Vector2D { vector vector int :: iterator row_it , row_end ; vector int :: iterator col_it ; public : Vector2D ( vector vector int vec2d ) { row_it = vec2d . begin (); row_end = vec2d . end (); while ( row_it != row_end row_it - empty ()) row_it ++ ; if ( row_it != row_end ) col_it = row_it - begin (); } int next () { int v = * col_it ; col_it ++ ; if ( col_it == row_it - end ()){ row_it ++ ; while ( row_it != row_end row_it - empty ()) row_it ++ ; // skip empty rows if ( row_it != row_end ) col_it = row_it - begin (); } return v ; } bool hasNext () { if ( row_it == row_end ) return false ; return true ; } }; /** * Your Vector2D object will be instantiated and called as such: * Vector2D i(vec2d); * while (i.hasNext()) cout i.next(); */ another solution .","title":"Flatten 2D Vector"},{"location":"LeetCodeLocked/c1.11/","text":"Group Shifted Strings Question Given a string, we can \u201cshift\u201d each of its letter to its successive letter, for example: \u201cabc\u201d - \u201cbcd\u201d . We can keep \u201cshifting\u201d which forms the sequence: \"abc\" - \"bcd\" - ... - \"xyz\" Given a list of strings which contains only lowercase alphabets, group all strings that belong to the same shifting sequence. For example, given: [\"abc\", \"bcd\", \"acef\", \"xyz\", \"az\", \"ba\", \"a\", \"z\"] , Return: [ [\"abc\",\"bcd\",\"xyz\"], [\"az\",\"ba\"], [\"acef\"], [\"a\",\"z\"] ] Note For the return value, each inner list\u2019s elements must follow the lexicographic order. Solution here . 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 class Solution { public : vector vector string groupStrings ( vector string strings ) { unordered_map string , vector string mp ; for ( string s : strings ) mp [ shift ( s )]. push_back ( s ); vector vector string groups ; for ( auto m : mp ) { vector string group = m . second ; sort ( group . begin (), group . end ()); groups . push_back ( group ); } return groups ; } private : string shift ( string s ) { string t ; int n = s . length (); for ( int i = 1 ; i n ; i ++ ) { int diff = s [ i ] - s [ i - 1 ]; if ( diff 0 ) diff += 26 ; t += a + diff + , ; } return t ; } };","title":"Group Shifted Strings"},{"location":"LeetCodeLocked/c1.11/#group-shifted-strings","text":"Question Given a string, we can \u201cshift\u201d each of its letter to its successive letter, for example: \u201cabc\u201d - \u201cbcd\u201d . We can keep \u201cshifting\u201d which forms the sequence: \"abc\" - \"bcd\" - ... - \"xyz\" Given a list of strings which contains only lowercase alphabets, group all strings that belong to the same shifting sequence. For example, given: [\"abc\", \"bcd\", \"acef\", \"xyz\", \"az\", \"ba\", \"a\", \"z\"] , Return: [ [\"abc\",\"bcd\",\"xyz\"], [\"az\",\"ba\"], [\"acef\"], [\"a\",\"z\"] ] Note For the return value, each inner list\u2019s elements must follow the lexicographic order. Solution here . 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 class Solution { public : vector vector string groupStrings ( vector string strings ) { unordered_map string , vector string mp ; for ( string s : strings ) mp [ shift ( s )]. push_back ( s ); vector vector string groups ; for ( auto m : mp ) { vector string group = m . second ; sort ( group . begin (), group . end ()); groups . push_back ( group ); } return groups ; } private : string shift ( string s ) { string t ; int n = s . length (); for ( int i = 1 ; i n ; i ++ ) { int diff = s [ i ] - s [ i - 1 ]; if ( diff 0 ) diff += 26 ; t += a + diff + , ; } return t ; } };","title":"Group Shifted Strings"},{"location":"LeetCodeLocked/c1.12/","text":"Count Univalue Subtrees Question Given a complete binary tree, count the number of nodes. In a complete binary tree every level, except possibly the last, is completely filled, and all nodes in the last level are as far left as possible. It can have between 1 and 2h nodes inclusive at the last level h. Universal value binary tree means all value in that tree is the same. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 //C++: 4ms /** * Definition for a binary tree node. * struct TreeNode { * int val; * TreeNode *left; * TreeNode *right; * TreeNode(int x) : val(x), left(NULL), right(NULL) {} * }; */ class Solution { public : int countUnivalSubtrees ( TreeNode * root ) { int cnt = 0 ; helper ( root , cnt ); return cnt ; } bool helper ( TreeNode * root , int cnt ){ if ( ! root ) return true ; bool left = helper ( root - left , cnt ); bool right = helper ( root - right , cnt ); if ( left right root - left root - left - val == root - val root - right root - right - val == root - val ) { cnt ++ ; return true ; } return false ; } };","title":"Count Univalue Subtrees"},{"location":"LeetCodeLocked/c1.12/#count-univalue-subtrees","text":"Question Given a complete binary tree, count the number of nodes. In a complete binary tree every level, except possibly the last, is completely filled, and all nodes in the last level are as far left as possible. It can have between 1 and 2h nodes inclusive at the last level h. Universal value binary tree means all value in that tree is the same. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 //C++: 4ms /** * Definition for a binary tree node. * struct TreeNode { * int val; * TreeNode *left; * TreeNode *right; * TreeNode(int x) : val(x), left(NULL), right(NULL) {} * }; */ class Solution { public : int countUnivalSubtrees ( TreeNode * root ) { int cnt = 0 ; helper ( root , cnt ); return cnt ; } bool helper ( TreeNode * root , int cnt ){ if ( ! root ) return true ; bool left = helper ( root - left , cnt ); bool right = helper ( root - right , cnt ); if ( left right root - left root - left - val == root - val root - right root - right - val == root - val ) { cnt ++ ; return true ; } return false ; } };","title":"Count Univalue Subtrees"},{"location":"LeetCodeLocked/c1.13/","text":"Binary Tree Upside Down Question Given a binary tree where all the right nodes are either leaf nodes with a sibling (a left node that shares the same parent node) or empty, flip it upside down and turn it into a tree where the original right nodes turned into left leaf nodes. Return the new root. For example: Given a binary tree {1,2,3,4,5} , 1 2 3 4 5 1 / \\ 2 3 / \\ 4 5 return the root of the binary tree [4,5,2,#,#,3,1] . 1 2 3 4 5 4 / \\ 5 2 / \\ 3 1 Solution At each node you want to assign: p.left = parent.right; p.right = parent; Top down approach We need to be very careful when reassigning current node\u2019s left and right children. Besides making a copy of the parent node, you would also need to make a copy of the parent\u2019s right child too. The reason is the current node becomes the parent node in the next iteration. here recursion 1 2 3 4 5 6 7 8 9 10 11 12 public TreeNode UpsideDownBinaryTree ( TreeNode root ) { if ( root == null ) return null ; TreeNode parent = root , left = root . left , right = root . right ; if ( left != null ) { TreeNode ret = UpsideDownBinaryTree ( left ); left . left = right ; left . right = parent ; return ret ; } return root ; } iteration 1 2 3 4 5 6 7 8 9 10 11 12 public TreeNode UpsideDownBinaryTree ( TreeNode root ) { TreeNode node = root , parent = null , right = null ; while ( node != null ) { TreeNode left = node . left ; node . left = right ; right = node . right ; node . right = parent ; parent = node ; node = left ; } return parent ; } postorder Traversal 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 private TreeNode out = null ; public TreeNode UpsideDownBinaryTree ( TreeNode root ) { TreeNode dummy = new TreeNode ( 0 ); dummy . left = new TreeNode ( 0 ); out = dummy ; postorder ( root ); return dummy . right ; } private void postorder ( TreeNode root ) { if ( root == null ) return ; postorder ( root . left ); postorder ( root . right ); if ( out . left == null ) { out . left = root ; out . left . left = null ; out . left . right = null ; } else if ( out . right == null ) { out . right = root ; out . right . left = null ; out . right . right = null ; } if ( out . left != null out . right != null ) out = out . right ; }","title":"Binary Tree Upside Down"},{"location":"LeetCodeLocked/c1.13/#binary-tree-upside-down","text":"Question Given a binary tree where all the right nodes are either leaf nodes with a sibling (a left node that shares the same parent node) or empty, flip it upside down and turn it into a tree where the original right nodes turned into left leaf nodes. Return the new root. For example: Given a binary tree {1,2,3,4,5} , 1 2 3 4 5 1 / \\ 2 3 / \\ 4 5 return the root of the binary tree [4,5,2,#,#,3,1] . 1 2 3 4 5 4 / \\ 5 2 / \\ 3 1 Solution At each node you want to assign: p.left = parent.right; p.right = parent; Top down approach We need to be very careful when reassigning current node\u2019s left and right children. Besides making a copy of the parent node, you would also need to make a copy of the parent\u2019s right child too. The reason is the current node becomes the parent node in the next iteration. here recursion 1 2 3 4 5 6 7 8 9 10 11 12 public TreeNode UpsideDownBinaryTree ( TreeNode root ) { if ( root == null ) return null ; TreeNode parent = root , left = root . left , right = root . right ; if ( left != null ) { TreeNode ret = UpsideDownBinaryTree ( left ); left . left = right ; left . right = parent ; return ret ; } return root ; } iteration 1 2 3 4 5 6 7 8 9 10 11 12 public TreeNode UpsideDownBinaryTree ( TreeNode root ) { TreeNode node = root , parent = null , right = null ; while ( node != null ) { TreeNode left = node . left ; node . left = right ; right = node . right ; node . right = parent ; parent = node ; node = left ; } return parent ; } postorder Traversal 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 private TreeNode out = null ; public TreeNode UpsideDownBinaryTree ( TreeNode root ) { TreeNode dummy = new TreeNode ( 0 ); dummy . left = new TreeNode ( 0 ); out = dummy ; postorder ( root ); return dummy . right ; } private void postorder ( TreeNode root ) { if ( root == null ) return ; postorder ( root . left ); postorder ( root . right ); if ( out . left == null ) { out . left = root ; out . left . left = null ; out . left . right = null ; } else if ( out . right == null ) { out . right = root ; out . right . left = null ; out . right . right = null ; } if ( out . left != null out . right != null ) out = out . right ; }","title":"Binary Tree Upside Down"},{"location":"LeetCodeLocked/c1.14/","text":"Verify preorder sequence of Binary Search Tree Question You have an array of preorder traversal of Binary Search Tree ( BST). Your program should verify whether it is a correct sequence or not. Input: Array of Integer [ Pre-order BST ] Output: String \u201cYes\u201d or \u201cNo\u201d Solution 1 divide and conquer 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 bool verifyPreorder ( vector int preorder ) { int n = preorder . size (); return helper ( preorder , 0 , n - 1 , INT_MIN , INT_MAX ); } bool helper ( vector int preorder , int s , int e , int lb , int ub ){ if ( s = e ) return true ; int r = preorder [ s ]; int i = s ; while ( i = e preorder [ i ] = r ){ if ( preorder [ i ] lb || preorder [ i ] ub ) return false ; i ++ ; } return helper ( preorder , s + 1 , i - 1 , lb , r - 1 ) helper ( preorder , i , e , r + 1 , ub ); } Solution 2 simulate the traversal, keeping a stack of nodes (just their values) of which we're still in the left subtree. If the next number is smaller than the last stack value, then we're still in the left subtree of all stack nodes, so just push the new one onto the stack. But before that, pop all smaller ancestor values, as we must now be in their right subtrees (or even further, in the right subtree of an ancestor). Also, use the popped values as a lower bound, since being in their right subtree means we must never come across a smaller number anymore. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 bool verifyPreorder ( vector int preorder ) { int low = INT_MIN ; // lower bound stack int path ; for ( int p : preorder ) { if ( p low ) { return false ; } while ( ! path . empty () p path . top ()) { low = path . top (); path . pop (); } path . push ( p ); } return true ; } other solution here","title":"Verify preorder sequence of Binary Search Tree"},{"location":"LeetCodeLocked/c1.14/#verify-preorder-sequence-of-binary-search-tree","text":"Question You have an array of preorder traversal of Binary Search Tree ( BST). Your program should verify whether it is a correct sequence or not. Input: Array of Integer [ Pre-order BST ] Output: String \u201cYes\u201d or \u201cNo\u201d Solution 1 divide and conquer 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 bool verifyPreorder ( vector int preorder ) { int n = preorder . size (); return helper ( preorder , 0 , n - 1 , INT_MIN , INT_MAX ); } bool helper ( vector int preorder , int s , int e , int lb , int ub ){ if ( s = e ) return true ; int r = preorder [ s ]; int i = s ; while ( i = e preorder [ i ] = r ){ if ( preorder [ i ] lb || preorder [ i ] ub ) return false ; i ++ ; } return helper ( preorder , s + 1 , i - 1 , lb , r - 1 ) helper ( preorder , i , e , r + 1 , ub ); } Solution 2 simulate the traversal, keeping a stack of nodes (just their values) of which we're still in the left subtree. If the next number is smaller than the last stack value, then we're still in the left subtree of all stack nodes, so just push the new one onto the stack. But before that, pop all smaller ancestor values, as we must now be in their right subtrees (or even further, in the right subtree of an ancestor). Also, use the popped values as a lower bound, since being in their right subtree means we must never come across a smaller number anymore. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 bool verifyPreorder ( vector int preorder ) { int low = INT_MIN ; // lower bound stack int path ; for ( int p : preorder ) { if ( p low ) { return false ; } while ( ! path . empty () p path . top ()) { low = path . top (); path . pop (); } path . push ( p ); } return true ; } other solution here","title":"Verify preorder sequence of Binary Search Tree"},{"location":"LeetCodeLocked/c1.15/","text":"Paint House Question 1 There are a row of n houses, each house can be painted with one of the three colors: red , blue or green . The cost of painting each house with a certain color is different. You have to paint all the houses such that no two adjacent houses have the same color. The cost of painting each house with a certain color is represented by a n x 3 cost matrix. For example, costs[0][0] is the cost of painting house 0 with color red; costs[1][2] is the cost of painting house 1 with color green, and so on... Find the minimum cost to paint all houses. Note All costs are positive integers. Solution DP. O(1) space from here . 1 2 3 4 5 6 7 8 9 10 11 12 13 14 //C++: 12ms class Solution { public : int minCost ( vector vector int costs ) { int n = costs . size (); if ( n == 0 ) return 0 ; for ( int i = 1 ; i n ; ++ i ){ for ( int j = 0 ; j 3 ; ++ j ){ costs [ i ][ j ] += min ( costs [ i - 1 ][( j + 1 ) % 3 ], costs [ i - 1 ][( j + 2 ) % 3 ]); } } return min ( costs [ n - 1 ][ 0 ], min ( costs [ n - 1 ][ 1 ], costs [ n - 1 ][ 2 ])); } }; or here . 1 2 3 4 5 6 7 8 9 10 11 12 13 14 class Solution { public : int minCost ( vector vector int costs ) { if ( costs . empty ()) return 0 ; int n = costs . size (), r = 0 , g = 0 , b = 0 ; for ( int i = 0 ; i n ; i ++ ) { int rr = r , bb = b , gg = g ; r = costs [ i ][ 0 ] + min ( bb , gg ); b = costs [ i ][ 1 ] + min ( rr , gg ); g = costs [ i ][ 2 ] + min ( rr , bb ); } return min ( r , min ( b , g )); } }; another O(n) space from here 1 2 3 4 5 6 7 8 9 10 11 public int minPaintCost ( int [][] cost ) { if ( cost == null || cost . length == 0 ) return 0 ; int [][] dp = new int [ cost . length ][ 3 ]; dp [ 0 ][ 0 ] = cost [ 0 ][ 0 ], dp [ 0 ][ 1 ] = cost [ 0 ][ 1 ], dp [ 0 ][ 2 ] = cost [ 0 ][ 2 ]; for ( int i = 1 ; i cost . length ; ++ i ) { dp [ i ][ 0 ] = cost [ i ][ 0 ] + Math . min ( dp [ i - 1 ][ 1 ], dp [ i - 1 ][ 2 ]); dp [ i ][ 1 ] = cost [ i ][ 1 ] + Math . min ( dp [ i - 1 ][ 0 ], dp [ i - 1 ][ 2 ]); dp [ i ][ 2 ] = cost [ i ][ 2 ] + Math . min ( dp [ i - 1 ][ 0 ], dp [ i - 1 ][ 1 ]); } return Math . min ( dp [ dp . length - 1 ][ 0 ], Math . min ( dp [ dp . length - 1 ][ 1 ],[ dp . length - 1 ][ 2 ])); } Question 2 There are a row of n houses, each house can be painted with one of the k colors. The cost of painting each house with a certain color is different. You have to paint all the houses such that no two adjacent houses have the same color. The cost of painting each house with a certain color is represented by a n x k cost matrix. For example, costs[0][0] is the cost of painting house 0 with color 0; costs[1][2] is the cost of painting house 1 with color 2, and so on... Find the minimum cost to paint all houses. Note All costs are positive integers. Follow up: Could you solve it in O(nk) runtime? Solution dp: maintain the minimum two costs min1(smallest) and min2 (second to smallest) after painting i-th house. from here 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 class Solution { public : int minCostII ( vector vector int costs ) { if ( costs . empty ()) return 0 ; int n = costs . size (), k = costs [ 0 ]. size (), min1 , min2 ; vector int dp ( k , 0 ); for ( int i = 0 ; i n ; i ++ ) { int premin1 = i ? min1 : 0 , premin2 = i ? min2 : 0 ; min1 = min2 = INT_MAX ; for ( int j = 0 ; j k ; j ++ ) { if ( dp [ j ] != premin1 || premin1 == premin2 ) dp [ j ] = premin1 + costs [ i ][ j ]; // pre_min1 occurred when painting house i-1 with color j, // so it cannot be added to dp[j] else dp [ j ] = premin2 + costs [ i ][ j ]; if ( min1 = dp [ j ]) min2 = min ( min2 , dp [ j ]); else min2 = min1 , min1 = dp [ j ]; } } return min1 ; } };","title":"Paint House I, II"},{"location":"LeetCodeLocked/c1.15/#paint-house","text":"Question 1 There are a row of n houses, each house can be painted with one of the three colors: red , blue or green . The cost of painting each house with a certain color is different. You have to paint all the houses such that no two adjacent houses have the same color. The cost of painting each house with a certain color is represented by a n x 3 cost matrix. For example, costs[0][0] is the cost of painting house 0 with color red; costs[1][2] is the cost of painting house 1 with color green, and so on... Find the minimum cost to paint all houses. Note All costs are positive integers. Solution DP. O(1) space from here . 1 2 3 4 5 6 7 8 9 10 11 12 13 14 //C++: 12ms class Solution { public : int minCost ( vector vector int costs ) { int n = costs . size (); if ( n == 0 ) return 0 ; for ( int i = 1 ; i n ; ++ i ){ for ( int j = 0 ; j 3 ; ++ j ){ costs [ i ][ j ] += min ( costs [ i - 1 ][( j + 1 ) % 3 ], costs [ i - 1 ][( j + 2 ) % 3 ]); } } return min ( costs [ n - 1 ][ 0 ], min ( costs [ n - 1 ][ 1 ], costs [ n - 1 ][ 2 ])); } }; or here . 1 2 3 4 5 6 7 8 9 10 11 12 13 14 class Solution { public : int minCost ( vector vector int costs ) { if ( costs . empty ()) return 0 ; int n = costs . size (), r = 0 , g = 0 , b = 0 ; for ( int i = 0 ; i n ; i ++ ) { int rr = r , bb = b , gg = g ; r = costs [ i ][ 0 ] + min ( bb , gg ); b = costs [ i ][ 1 ] + min ( rr , gg ); g = costs [ i ][ 2 ] + min ( rr , bb ); } return min ( r , min ( b , g )); } }; another O(n) space from here 1 2 3 4 5 6 7 8 9 10 11 public int minPaintCost ( int [][] cost ) { if ( cost == null || cost . length == 0 ) return 0 ; int [][] dp = new int [ cost . length ][ 3 ]; dp [ 0 ][ 0 ] = cost [ 0 ][ 0 ], dp [ 0 ][ 1 ] = cost [ 0 ][ 1 ], dp [ 0 ][ 2 ] = cost [ 0 ][ 2 ]; for ( int i = 1 ; i cost . length ; ++ i ) { dp [ i ][ 0 ] = cost [ i ][ 0 ] + Math . min ( dp [ i - 1 ][ 1 ], dp [ i - 1 ][ 2 ]); dp [ i ][ 1 ] = cost [ i ][ 1 ] + Math . min ( dp [ i - 1 ][ 0 ], dp [ i - 1 ][ 2 ]); dp [ i ][ 2 ] = cost [ i ][ 2 ] + Math . min ( dp [ i - 1 ][ 0 ], dp [ i - 1 ][ 1 ]); } return Math . min ( dp [ dp . length - 1 ][ 0 ], Math . min ( dp [ dp . length - 1 ][ 1 ],[ dp . length - 1 ][ 2 ])); } Question 2 There are a row of n houses, each house can be painted with one of the k colors. The cost of painting each house with a certain color is different. You have to paint all the houses such that no two adjacent houses have the same color. The cost of painting each house with a certain color is represented by a n x k cost matrix. For example, costs[0][0] is the cost of painting house 0 with color 0; costs[1][2] is the cost of painting house 1 with color 2, and so on... Find the minimum cost to paint all houses. Note All costs are positive integers. Follow up: Could you solve it in O(nk) runtime? Solution dp: maintain the minimum two costs min1(smallest) and min2 (second to smallest) after painting i-th house. from here 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 class Solution { public : int minCostII ( vector vector int costs ) { if ( costs . empty ()) return 0 ; int n = costs . size (), k = costs [ 0 ]. size (), min1 , min2 ; vector int dp ( k , 0 ); for ( int i = 0 ; i n ; i ++ ) { int premin1 = i ? min1 : 0 , premin2 = i ? min2 : 0 ; min1 = min2 = INT_MAX ; for ( int j = 0 ; j k ; j ++ ) { if ( dp [ j ] != premin1 || premin1 == premin2 ) dp [ j ] = premin1 + costs [ i ][ j ]; // pre_min1 occurred when painting house i-1 with color j, // so it cannot be added to dp[j] else dp [ j ] = premin2 + costs [ i ][ j ]; if ( min1 = dp [ j ]) min2 = min ( min2 , dp [ j ]); else min2 = min1 , min1 = dp [ j ]; } } return min1 ; } };","title":"Paint House"},{"location":"LeetCodeLocked/c1.16/","text":"3Sum Smaller Question Given an array of n integers nums and a target, find the number of index triplets i, j, k with 0 = i j k n that satisfy the condition nums[i] + nums[j] + nums[k] target . For example, given nums = [-2, 0, 1, 3]``, and target = 2`. Return 2. Because there are two triplets which sums are less than 2: [-2, 0, 1] [-2, 0, 3] Follow up: Could you solve it in O(n2) runtime? Solutuion sort and two pointers 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 class Solution { public : int threeSumSmaller ( vector int nums , int target ) { if ( nums . size () 3 ) return 0 ; sort ( nums . begin (), nums . end ()); int sz = nums . size (), count = 0 ; for ( int ind = 0 ; ind sz - 2 ; ind ++ ) { int left = ind + 1 , right = sz - 1 ; while ( left right ) { int sum = nums [ ind ] + nums [ left ] + nums [ right ]; if ( sum target ) { count += right - left ; left ++ ; } else { right -- ; } } } return count ; } }","title":"3Sum Smaller"},{"location":"LeetCodeLocked/c1.16/#3sum-smaller","text":"Question Given an array of n integers nums and a target, find the number of index triplets i, j, k with 0 = i j k n that satisfy the condition nums[i] + nums[j] + nums[k] target . For example, given nums = [-2, 0, 1, 3]``, and target = 2`. Return 2. Because there are two triplets which sums are less than 2: [-2, 0, 1] [-2, 0, 3] Follow up: Could you solve it in O(n2) runtime? Solutuion sort and two pointers 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 class Solution { public : int threeSumSmaller ( vector int nums , int target ) { if ( nums . size () 3 ) return 0 ; sort ( nums . begin (), nums . end ()); int sz = nums . size (), count = 0 ; for ( int ind = 0 ; ind sz - 2 ; ind ++ ) { int left = ind + 1 , right = sz - 1 ; while ( left right ) { int sum = nums [ ind ] + nums [ left ] + nums [ right ]; if ( sum target ) { count += right - left ; left ++ ; } else { right -- ; } } } return count ; } }","title":"3Sum Smaller"},{"location":"LeetCodeLocked/c1.17/","text":"Graph Valid Tree Question Given n nodes labeled from 0 to n - 1 and a list of undirected edges (each edge is a pair of nodes), write a function to check whether these edges make up a valid tree. For example: Given n = 5 and edges = [[0, 1], [0, 2], [0, 3], [1, 4]] , return true. Given n = 5 and edges = [[0, 1], [1, 2], [2, 3], [1, 3], [1, 4]] , return false. Hint: Given n = 5 and edges = [[0, 1], [1, 2], [3, 4]], what should your return? Is this case a valid tree? According to the definition of tree on Wikipedia: \u201ca tree is an undirected graph in which any two vertices are connected by exactly one path. In other words, any connected graph without simple cycles is a tree.\u201d Note: you can assume that no duplicate edges will appear in edges. Since all edges are undirected, [0, 1] is the same as [1, 0] and thus will not appear together inedges. Solution Treating input as graph, making sure no cycles and one connected component. check for cycle and connectness in Graph can be done by DFS, BFS and Union-find DFS from here 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 class Solution { public : bool validTree ( int n , vector pair int , int edges ) { vector vector int matrix ( n ); for ( auto e : edges ) { matrix [ e . first ]. push_back ( e . second ); matrix [ e . second ]. push_back ( e . first ); } int path [ n ]; fill ( path , path + n , 0 ); path [ 0 ] = 1 ; if ( hasCycle ( matrix , n , 0 , - 1 , path )) return false ; // has cycle if ( accumulate ( path , path + n , 0 ) n ) return false ; // not fully connected return true ; } bool hasCycle ( vector vector int matrix , int n , int src , int pre , int path []) { for ( auto i : matrix [ src ]) { if ( i != pre ) { if ( path [ i ]) return true ; path [ i ] = 1 ; if ( hasCycle ( matrix , n , i , src , path )) return ture ; } } return false ; } }","title":"Graph Valid Tree"},{"location":"LeetCodeLocked/c1.17/#graph-valid-tree","text":"Question Given n nodes labeled from 0 to n - 1 and a list of undirected edges (each edge is a pair of nodes), write a function to check whether these edges make up a valid tree. For example: Given n = 5 and edges = [[0, 1], [0, 2], [0, 3], [1, 4]] , return true. Given n = 5 and edges = [[0, 1], [1, 2], [2, 3], [1, 3], [1, 4]] , return false. Hint: Given n = 5 and edges = [[0, 1], [1, 2], [3, 4]], what should your return? Is this case a valid tree? According to the definition of tree on Wikipedia: \u201ca tree is an undirected graph in which any two vertices are connected by exactly one path. In other words, any connected graph without simple cycles is a tree.\u201d Note: you can assume that no duplicate edges will appear in edges. Since all edges are undirected, [0, 1] is the same as [1, 0] and thus will not appear together inedges. Solution Treating input as graph, making sure no cycles and one connected component. check for cycle and connectness in Graph can be done by DFS, BFS and Union-find DFS from here 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 class Solution { public : bool validTree ( int n , vector pair int , int edges ) { vector vector int matrix ( n ); for ( auto e : edges ) { matrix [ e . first ]. push_back ( e . second ); matrix [ e . second ]. push_back ( e . first ); } int path [ n ]; fill ( path , path + n , 0 ); path [ 0 ] = 1 ; if ( hasCycle ( matrix , n , 0 , - 1 , path )) return false ; // has cycle if ( accumulate ( path , path + n , 0 ) n ) return false ; // not fully connected return true ; } bool hasCycle ( vector vector int matrix , int n , int src , int pre , int path []) { for ( auto i : matrix [ src ]) { if ( i != pre ) { if ( path [ i ]) return true ; path [ i ] = 1 ; if ( hasCycle ( matrix , n , i , src , path )) return ture ; } } return false ; } }","title":"Graph Valid Tree"},{"location":"LeetCodeLocked/c1.18/","text":"Palindrome Permutation I, II Question 1 Given a string, determine if a permutation of the string could form a palindrome. For example, \"code\" - False , \"aab\" - True , \"carerac\" - True . Hint: Consider the palindromes of odd vs even length. What difference do you notice? Count the frequency of each character. If each character occurs even number of times, then it must be a palindrome. How about character which occurs odd number of times? Solution count number of chars, and odd char can only be one 1 2 3 4 5 6 7 8 9 10 11 12 13 14 class Solution { public : bool canPermutePalindrome ( string s ) { vector int smap ( 256 , 0 ); for ( auto c : s ) { smap [ c ] ++ ; } int oddCount = 0 ; for ( int i = 0 ; i 256 ; i ++ ) { if ( cmap [ i ] % 2 != 0 ) oddCount ++ ; } return oddCount = 1 ; } }; another solution here 1 2 3 4 5 6 bool canPermutePalindrome ( string s ) { bitset 256 b ; for ( char c : s ) b . flip ( c ); return b . count () 2 ; } Question 2 Given a string s, return all the palindromic permutations (without duplicates) of it. Return an empty list if no palindromic permutation could be form. For example: Given s = \"aabb\" , return [\"abba\", \"baab\"] . Given s = \"abc\" , return []. Hint: If a palindromic permutation exists, we just need to generate the first half of the string. To generate all distinct permutations of a (half of) string, use a similar approach from: Permutations II or Next Permutation. Solution 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 class Solution { public : vector string generatePalindromes ( string s ) { vector string palindromes ; unordered_map char , int count ; for ( char c : s ) count [ c ] ++ ; int odd = 0 ; char mid ; string half ; for ( auto p : count ) { if ( p . second 1 ) { odd ++ , mid = p . first ; } half += string ( p . second / 2 , p . first ); } palindromes = permutations ( half ); for ( string p : palindromes ) { string t ( p ); reverse ( t . begin (), t . end ()); if ( odd ) t = mid + t ; p += t ; } return palindromes ; } private : vector string permutations ( string s ) { vector string perms ; string t ( s ); do { perms . push_back ( s ); next_permutation ( s . begin (), s . end ()); } while ( s != t ); return perms ; } };","title":"Palindrome Permutation I, II"},{"location":"LeetCodeLocked/c1.18/#palindrome-permutation-i-ii","text":"Question 1 Given a string, determine if a permutation of the string could form a palindrome. For example, \"code\" - False , \"aab\" - True , \"carerac\" - True . Hint: Consider the palindromes of odd vs even length. What difference do you notice? Count the frequency of each character. If each character occurs even number of times, then it must be a palindrome. How about character which occurs odd number of times? Solution count number of chars, and odd char can only be one 1 2 3 4 5 6 7 8 9 10 11 12 13 14 class Solution { public : bool canPermutePalindrome ( string s ) { vector int smap ( 256 , 0 ); for ( auto c : s ) { smap [ c ] ++ ; } int oddCount = 0 ; for ( int i = 0 ; i 256 ; i ++ ) { if ( cmap [ i ] % 2 != 0 ) oddCount ++ ; } return oddCount = 1 ; } }; another solution here 1 2 3 4 5 6 bool canPermutePalindrome ( string s ) { bitset 256 b ; for ( char c : s ) b . flip ( c ); return b . count () 2 ; } Question 2 Given a string s, return all the palindromic permutations (without duplicates) of it. Return an empty list if no palindromic permutation could be form. For example: Given s = \"aabb\" , return [\"abba\", \"baab\"] . Given s = \"abc\" , return []. Hint: If a palindromic permutation exists, we just need to generate the first half of the string. To generate all distinct permutations of a (half of) string, use a similar approach from: Permutations II or Next Permutation. Solution 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 class Solution { public : vector string generatePalindromes ( string s ) { vector string palindromes ; unordered_map char , int count ; for ( char c : s ) count [ c ] ++ ; int odd = 0 ; char mid ; string half ; for ( auto p : count ) { if ( p . second 1 ) { odd ++ , mid = p . first ; } half += string ( p . second / 2 , p . first ); } palindromes = permutations ( half ); for ( string p : palindromes ) { string t ( p ); reverse ( t . begin (), t . end ()); if ( odd ) t = mid + t ; p += t ; } return palindromes ; } private : vector string permutations ( string s ) { vector string perms ; string t ( s ); do { perms . push_back ( s ); next_permutation ( s . begin (), s . end ()); } while ( s != t ); return perms ; } };","title":"Palindrome Permutation I, II"},{"location":"LeetCodeLocked/c1.19/","text":"Alien Dictonary Question There is a new alien language which uses the latin alphabet. However, the order among letters are unknown to you. You receive a list of words from the dictionary, where words are sorted lexicographically by the rules of this new language. Derive the order of letters in this language. For example, Given the following words in dictionary, 1 2 3 4 5 6 7 [ wrt , wrf , er , ett , rftt ] The correct order is: \"wertf\". Note You may assume all letters are in lowercase. If the order is invalid, return an empty string. There may be multiple valid order of letters, return any one of them is fine. Solution topological sorting from here and here 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 class Solution { // Time Complexity - O(V+E)\uff0cSpace Complexity - O(V+E) ? public : string alienOrder ( vector string words ) { if ( words . size () == 1 ) return words [ 0 ]; graph g = make_graph ( words ); return topsort ( g ); } private : typedef unordered_map char , unordered_set char graph ; graph make_graph ( vector string words ) { graph g ; int n = words . size (); for ( int i = 1 ; i words . size (); i ++ ) { string word1 = words [ i - 1 ], word2 = words [ i ]; bool found = false ; int m = word1 . size (), n = word2 . size (), l = max ( m , n ); for ( int j = 0 ; j l ; j ++ ) { if ( j m g . find ( word1 [ j ]) == g . end ()) g [ word1 [ j ]] = unordered_set char (); if ( j n g . find ( word2 [ j ]) == g . end ()) g [ word2 [ j ]] = unordered_set char (); if ( j m j n word1 [ j ] != word2 [ j ] ! found ) { g [ word1 [ j ]]. insert ( word2 [ j ]); found = true ; } } } return g ; } string topsort ( graph g ) { vector bool path ( 256 , false ), visited ( 256 , false ); string order ; for ( auto adj : g ) { if ( ! dfs ( g , path , visited , order , adj . first )) return ; } reverse ( order . begin (), order . end ()); return order ; } // check for cycle and generate topological sort bool dfs ( graph g , vector bool path , vector bool visited , string order , char node ) { if ( path [ node ]) return false ; if ( visited [ node ]) return true ; path [ node ] = visited [ node ] = true ; for ( auto neigh : g [ node ]) { if ( ! dfs ( g , path , visited , order , neigh )) return false ; } path [ node ] = false ; order += node ; return true ; } };","title":"Alien Dictonary"},{"location":"LeetCodeLocked/c1.19/#alien-dictonary","text":"Question There is a new alien language which uses the latin alphabet. However, the order among letters are unknown to you. You receive a list of words from the dictionary, where words are sorted lexicographically by the rules of this new language. Derive the order of letters in this language. For example, Given the following words in dictionary, 1 2 3 4 5 6 7 [ wrt , wrf , er , ett , rftt ] The correct order is: \"wertf\". Note You may assume all letters are in lowercase. If the order is invalid, return an empty string. There may be multiple valid order of letters, return any one of them is fine. Solution topological sorting from here and here 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 class Solution { // Time Complexity - O(V+E)\uff0cSpace Complexity - O(V+E) ? public : string alienOrder ( vector string words ) { if ( words . size () == 1 ) return words [ 0 ]; graph g = make_graph ( words ); return topsort ( g ); } private : typedef unordered_map char , unordered_set char graph ; graph make_graph ( vector string words ) { graph g ; int n = words . size (); for ( int i = 1 ; i words . size (); i ++ ) { string word1 = words [ i - 1 ], word2 = words [ i ]; bool found = false ; int m = word1 . size (), n = word2 . size (), l = max ( m , n ); for ( int j = 0 ; j l ; j ++ ) { if ( j m g . find ( word1 [ j ]) == g . end ()) g [ word1 [ j ]] = unordered_set char (); if ( j n g . find ( word2 [ j ]) == g . end ()) g [ word2 [ j ]] = unordered_set char (); if ( j m j n word1 [ j ] != word2 [ j ] ! found ) { g [ word1 [ j ]]. insert ( word2 [ j ]); found = true ; } } } return g ; } string topsort ( graph g ) { vector bool path ( 256 , false ), visited ( 256 , false ); string order ; for ( auto adj : g ) { if ( ! dfs ( g , path , visited , order , adj . first )) return ; } reverse ( order . begin (), order . end ()); return order ; } // check for cycle and generate topological sort bool dfs ( graph g , vector bool path , vector bool visited , string order , char node ) { if ( path [ node ]) return false ; if ( visited [ node ]) return true ; path [ node ] = visited [ node ] = true ; for ( auto neigh : g [ node ]) { if ( ! dfs ( g , path , visited , order , neigh )) return false ; } path [ node ] = false ; order += node ; return true ; } };","title":"Alien Dictonary"},{"location":"LeetCodeLocked/c1.2/","text":"Two Sum II, III Question 1 Array is sorted. Solution tow pointers one from beginning and one from end of the array. move pointers based on the two sum results. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 vector int twosum ( vector int numbers , int target ) { //vector int res; int left = 0 , right = nums . size () - 1 ; while ( left right ) { int sum = numbers [ left ] + numbers [ right ]; if ( sum == target ) { return { left + 1 , right + 1 }; } else if ( sum target ){ right -- ; } else { left ++ ; } } return {}; } Question 2 Design and implement a TwoSum class. It should support the following operations: add and find. add(input) \u2013 Add the number input to an internal data structure. find(value) \u2013 Find if there exists any pair of numbers which sum is equal to the value. For example, add(1); add(3); add(5); find(4)- true; find(7)- false Solution add \u2013 O(n) runtime, find \u2013 O(1) runtime, O(n2) space\u2013 Store pair sums in hash table: We could store all possible pair sums into a hash table. The extra space needed is in the order of O(n2). You would also need an extra O(n) space to store the list of added numbers. Each add operation essentially go through the list and form new pair sums that go into the hash table. The find operation involves a single hash table lookup in O(1) runtime. This method is useful if the number of find operations far exceeds the number of add operations. add \u2013 O(log n) runtime, find \u2013 O(n) runtime, O(n) space \u2013 Binary search + Two pointers: Maintain a sorted array of numbers. Each add operation would need O(log n) time to insert it at the correct position using a modified binary search (See Question [48. Search Insert Position]). For find operation we could then apply the [Two pointers] approach in O(n) runtime. add \u2013 O(1) runtime, find \u2013 O(n) runtime, O(n) space \u2013 Store input in hash table: A simpler approach is to store each input into a hash table. To find if a pair sum exists, just iterate through the hash table in O(n) runtime. Make sure you are able to handle duplicates correctly. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 class TwoSum { public : void add ( int x ) { umap [ x ] ++ ; } bool find ( int target ) { for ( auto i : umap ) { if ( umap . find ( target - i . first ) != umap . end ()) { if ( target - i . first != i . first ) return true ; else if ( umap [ i . first ] = 2 ) return true ; } } return false ; } private : unordered_map int , int umap ; };","title":"Two Sum III \u2013 Data structure design"},{"location":"LeetCodeLocked/c1.2/#two-sum-ii-iii","text":"Question 1 Array is sorted. Solution tow pointers one from beginning and one from end of the array. move pointers based on the two sum results. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 vector int twosum ( vector int numbers , int target ) { //vector int res; int left = 0 , right = nums . size () - 1 ; while ( left right ) { int sum = numbers [ left ] + numbers [ right ]; if ( sum == target ) { return { left + 1 , right + 1 }; } else if ( sum target ){ right -- ; } else { left ++ ; } } return {}; } Question 2 Design and implement a TwoSum class. It should support the following operations: add and find. add(input) \u2013 Add the number input to an internal data structure. find(value) \u2013 Find if there exists any pair of numbers which sum is equal to the value. For example, add(1); add(3); add(5); find(4)- true; find(7)- false Solution add \u2013 O(n) runtime, find \u2013 O(1) runtime, O(n2) space\u2013 Store pair sums in hash table: We could store all possible pair sums into a hash table. The extra space needed is in the order of O(n2). You would also need an extra O(n) space to store the list of added numbers. Each add operation essentially go through the list and form new pair sums that go into the hash table. The find operation involves a single hash table lookup in O(1) runtime. This method is useful if the number of find operations far exceeds the number of add operations. add \u2013 O(log n) runtime, find \u2013 O(n) runtime, O(n) space \u2013 Binary search + Two pointers: Maintain a sorted array of numbers. Each add operation would need O(log n) time to insert it at the correct position using a modified binary search (See Question [48. Search Insert Position]). For find operation we could then apply the [Two pointers] approach in O(n) runtime. add \u2013 O(1) runtime, find \u2013 O(n) runtime, O(n) space \u2013 Store input in hash table: A simpler approach is to store each input into a hash table. To find if a pair sum exists, just iterate through the hash table in O(n) runtime. Make sure you are able to handle duplicates correctly. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 class TwoSum { public : void add ( int x ) { umap [ x ] ++ ; } bool find ( int target ) { for ( auto i : umap ) { if ( umap . find ( target - i . first ) != umap . end ()) { if ( target - i . first != i . first ) return true ; else if ( umap [ i . first ] = 2 ) return true ; } } return false ; } private : unordered_map int , int umap ; };","title":"Two Sum II, III"},{"location":"LeetCodeLocked/c1.20/","text":"Closest Binary Search Tree Value I, II Question I one closest value Solution can be solved by recursion [here])(http://www.cnblogs.com/jcliBlogger/p/4763200.html) 1 2 3 4 5 6 7 8 9 10 11 12 13 14 class Solution { public : int closestValue ( TreeNode * root , double target ) { if ( ! root ) return INT_MAX ; if ( ! root - left ! root - right ) return root - val ; int left = closestValue ( target - left , target ); int right = closestValue ( target - right , target ); double td = abs ( root - val - target ), ld = abs ( left - target ), rd = abs ( right - target ); if ( td ld ) return ( td rd ) ? root - val : right ; else return ( ld rd ) ? left : right ; } } or 1 2 3 4 5 6 7 8 // recursive int closestValue ( TreeNode * root , double target ) { int a = root - val ; auto kid = target a ? root - left : root - right ; if ( ! kid ) return a ; int b = closestValue ( kid , target ); return abs ( a - target ) abs ( b - target ) ? a : b ; } 1 2 3 4 5 6 7 8 9 10 // iterative int closestValue ( TreeNode * root , double target ) { int closest = root - val ; while ( root ) { if ( abs ( closest - target ) = abs ( root - val - target )) closest = root - val ; root = target root - val ? root - left : root - right ; } return closest ; } more solution here Question II k closest values Solution here 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 Solution { public : vector int closestKValues ( TreeNode * root , double target , int k ) { priority_queue pair double , int pq ; closestK ( root , pq , target , k ); vector int closest ; while ( ! pq . empty ()) { closest . push_back ( pq . top (). second ); pq . pop (); } return closest ; } private : void closestK ( TreeNode * node , priority_queue pair double , int pq , double target , int k ){ if ( ! node ) return ; pq . push ( make_pair ( abs ( target - node - val ), node - val )); if ( pq . size () k ) pq . pop (); closestK ( node - left , pq , target , k ); closestK ( node - right , pq , target , k ); } }","title":"losest Binary Search Tree Value I, II"},{"location":"LeetCodeLocked/c1.20/#closest-binary-search-tree-value-i-ii","text":"Question I one closest value Solution can be solved by recursion [here])(http://www.cnblogs.com/jcliBlogger/p/4763200.html) 1 2 3 4 5 6 7 8 9 10 11 12 13 14 class Solution { public : int closestValue ( TreeNode * root , double target ) { if ( ! root ) return INT_MAX ; if ( ! root - left ! root - right ) return root - val ; int left = closestValue ( target - left , target ); int right = closestValue ( target - right , target ); double td = abs ( root - val - target ), ld = abs ( left - target ), rd = abs ( right - target ); if ( td ld ) return ( td rd ) ? root - val : right ; else return ( ld rd ) ? left : right ; } } or 1 2 3 4 5 6 7 8 // recursive int closestValue ( TreeNode * root , double target ) { int a = root - val ; auto kid = target a ? root - left : root - right ; if ( ! kid ) return a ; int b = closestValue ( kid , target ); return abs ( a - target ) abs ( b - target ) ? a : b ; } 1 2 3 4 5 6 7 8 9 10 // iterative int closestValue ( TreeNode * root , double target ) { int closest = root - val ; while ( root ) { if ( abs ( closest - target ) = abs ( root - val - target )) closest = root - val ; root = target root - val ? root - left : root - right ; } return closest ; } more solution here Question II k closest values Solution here 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 Solution { public : vector int closestKValues ( TreeNode * root , double target , int k ) { priority_queue pair double , int pq ; closestK ( root , pq , target , k ); vector int closest ; while ( ! pq . empty ()) { closest . push_back ( pq . top (). second ); pq . pop (); } return closest ; } private : void closestK ( TreeNode * node , priority_queue pair double , int pq , double target , int k ){ if ( ! node ) return ; pq . push ( make_pair ( abs ( target - node - val ), node - val )); if ( pq . size () k ) pq . pop (); closestK ( node - left , pq , target , k ); closestK ( node - right , pq , target , k ); } }","title":"Closest Binary Search Tree Value I, II"},{"location":"LeetCodeLocked/c1.21/","text":"Encode and Decode Strings Question Design an algorithm to encode a list of strings to a string. The encoded string is then sent over the network and is decoded back to the original list of strings. Machine 1 (sender) has the function: 1 2 3 4 string encode ( vector string strs ) { // ... your code return encoded_string ; } Machine 2 (receiver) has the function: 1 2 3 4 vector string decode ( string s ) { //... your code return strs ; } So Machine 1 does: string encoded_string = encode(strs); and Machine 2 does: vector string strs2 = decode(encoded_string); strs2 in Machine 2 should be the same as strs in Machine 1. Implement the encode and decode methods. Note The string may contain any possible characters out of 256 valid ascii characters. Your algorithm should be generalized enough to work on any possible characters. Do not use class member/global/static variables to store states. Your encode and decode algorithms should be stateless. Do not rely on any library method such as eval or serialize methods. You should implement your own encode/decode algorithm. Solution from here 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 class Codec { public : // Encodes a list of strings to a single string. string encode ( vector string strs ) { string encoded = ; for ( string str : strs ) { int len = str . size (); encoded += to_string ( len ) + @ + str ; } return encoded ; } // Decodes a single string to a list of strings. vector string decode ( string s ) { vector string r ; int head = 0 ; while ( head s . size ()) { int at_pos = s . find_first_of ( @ , head ); //int len = atoi( s[head]); //head = s.find( @ , head) + 1; int len = stoi ( s . substr ( head , at_pos - head )); head = at_pos + 1 ; r . push_back ( s . substr ( head , len )); head += len ; } return r ; } }; // Your Codec object will be instantiated and called as such: // Codec codec; // codec.decode(codec.encode(strs)); other solution with run-length encoding here","title":"Encode and Decode Strings"},{"location":"LeetCodeLocked/c1.21/#encode-and-decode-strings","text":"Question Design an algorithm to encode a list of strings to a string. The encoded string is then sent over the network and is decoded back to the original list of strings. Machine 1 (sender) has the function: 1 2 3 4 string encode ( vector string strs ) { // ... your code return encoded_string ; } Machine 2 (receiver) has the function: 1 2 3 4 vector string decode ( string s ) { //... your code return strs ; } So Machine 1 does: string encoded_string = encode(strs); and Machine 2 does: vector string strs2 = decode(encoded_string); strs2 in Machine 2 should be the same as strs in Machine 1. Implement the encode and decode methods. Note The string may contain any possible characters out of 256 valid ascii characters. Your algorithm should be generalized enough to work on any possible characters. Do not use class member/global/static variables to store states. Your encode and decode algorithms should be stateless. Do not rely on any library method such as eval or serialize methods. You should implement your own encode/decode algorithm. Solution from here 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 class Codec { public : // Encodes a list of strings to a single string. string encode ( vector string strs ) { string encoded = ; for ( string str : strs ) { int len = str . size (); encoded += to_string ( len ) + @ + str ; } return encoded ; } // Decodes a single string to a list of strings. vector string decode ( string s ) { vector string r ; int head = 0 ; while ( head s . size ()) { int at_pos = s . find_first_of ( @ , head ); //int len = atoi( s[head]); //head = s.find( @ , head) + 1; int len = stoi ( s . substr ( head , at_pos - head )); head = at_pos + 1 ; r . push_back ( s . substr ( head , len )); head += len ; } return r ; } }; // Your Codec object will be instantiated and called as such: // Codec codec; // codec.decode(codec.encode(strs)); other solution with run-length encoding here","title":"Encode and Decode Strings"},{"location":"LeetCodeLocked/c1.22/","text":"Find the Celebrity Question Suppose you are at a party with n people (labeled from 0 to n - 1) and among them, there may exist one celebrity. The definition of a celebrity is that all the other n - 1people know him/her but he/she does not know any of them. Now you want to find out who the celebrity is or verify that there is not one. The only thing you are allowed to do is to ask questions like: \"Hi, A. Do you know B?\" to get information of whether A knows B. You need to find out the celebrity (or verify there is not one) by asking as few questions as possible (in the asymptotic sense). You are given a helper function bool knows(a, b) which tells you whether A knows B. Implement a function int findCelebrity(n), your function should minimize the number of calls to knows. Note There will be exactly one celebrity if he/she is in the party. Return the celebrity's label if there is a celebrity in the party. If there is no celebrity, return -1. Solution \u53cc\u6307\u9488\uff0cO(n)\u65f6\u95f4\uff0cO(1)\u7a7a\u95f4\u3002 ref . 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 // Forward declaration of the knows API. bool knows ( int a , int b ); class Solution { public : int findCelebrity ( int n ) { int c = 0 ; for ( int i = 1 ; i n ; ++ i ){ if ( knows ( c , i )){ c = i ; } } for ( int i = 0 ; i n ; ++ i ){ if ( c != i ( knows ( c , i ) || ! knows ( i , c ))) return - 1 ; } return c ; } };","title":"Find the Celebrity"},{"location":"LeetCodeLocked/c1.22/#find-the-celebrity","text":"Question Suppose you are at a party with n people (labeled from 0 to n - 1) and among them, there may exist one celebrity. The definition of a celebrity is that all the other n - 1people know him/her but he/she does not know any of them. Now you want to find out who the celebrity is or verify that there is not one. The only thing you are allowed to do is to ask questions like: \"Hi, A. Do you know B?\" to get information of whether A knows B. You need to find out the celebrity (or verify there is not one) by asking as few questions as possible (in the asymptotic sense). You are given a helper function bool knows(a, b) which tells you whether A knows B. Implement a function int findCelebrity(n), your function should minimize the number of calls to knows. Note There will be exactly one celebrity if he/she is in the party. Return the celebrity's label if there is a celebrity in the party. If there is no celebrity, return -1. Solution \u53cc\u6307\u9488\uff0cO(n)\u65f6\u95f4\uff0cO(1)\u7a7a\u95f4\u3002 ref . 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 // Forward declaration of the knows API. bool knows ( int a , int b ); class Solution { public : int findCelebrity ( int n ) { int c = 0 ; for ( int i = 1 ; i n ; ++ i ){ if ( knows ( c , i )){ c = i ; } } for ( int i = 0 ; i n ; ++ i ){ if ( c != i ( knows ( c , i ) || ! knows ( i , c ))) return - 1 ; } return c ; } };","title":"Find the Celebrity"},{"location":"LeetCodeLocked/c1.23/","text":"Paint Fence Question There is a fence with n posts, each post can be painted with one of the k colors. You have to paint all the posts such that no more than two adjacent fence posts have the same color. Return the total number of ways you can paint the fence. Note n and k are non-negative integers. Solution DP, see here and here 1 2 3 4 5 6 7 8 9 10 11 12 13 class Solution { public : int numWays ( int n , int k ) { if ( n 2 || ! k ) return n * k ; int s = k , d1 = k , d2 = k * ( k - 1 ); for ( int i = 2 ; i n ; i ++ ) { s = d2 ; d2 = ( k - 1 ) * ( d1 + d2 ); d1 = s ; } return s + d2 ; } };","title":"Paint Fence"},{"location":"LeetCodeLocked/c1.23/#paint-fence","text":"Question There is a fence with n posts, each post can be painted with one of the k colors. You have to paint all the posts such that no more than two adjacent fence posts have the same color. Return the total number of ways you can paint the fence. Note n and k are non-negative integers. Solution DP, see here and here 1 2 3 4 5 6 7 8 9 10 11 12 13 class Solution { public : int numWays ( int n , int k ) { if ( n 2 || ! k ) return n * k ; int s = k , d1 = k , d2 = k * ( k - 1 ); for ( int i = 2 ; i n ; i ++ ) { s = d2 ; d2 = ( k - 1 ) * ( d1 + d2 ); d1 = s ; } return s + d2 ; } };","title":"Paint Fence"},{"location":"LeetCodeLocked/c1.24/","text":"Walls and Gates Question You are given a m x n 2D grid initialized with these three possible values. -1 - A wall or an obstacle. 0 - A gate. INF - Infinity means an empty room. We use the value 231 - 1 = 2147483647 to represent INF as you may assume that the distance to a gate is less than 2147483647 . Fill each empty room with the distance to its nearest gate. If it is impossible to reach a gate, it should be filled with INF . For example, given the 2D grid: 1 2 3 4 INF -1 0 INF INF INF INF -1 INF -1 INF -1 0 -1 INF INF After running your function, the 2D grid should be: 1 2 3 4 3 -1 0 1 2 2 1 -1 1 -1 2 -1 0 -1 3 4 Solution BFS with appropriate pruning. refer to this post and here . 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 class Solution { public : void wallsAndGates ( vector vector int rooms ) { if ( rooms . empty ()) return ; int m = rooms . size (), n = rooms [ 0 ]. size (); queue pair int , int q ; for ( int i = 0 ; i m ; i ++ ) { for ( int j = 0 ; j n ; j ++ ) { if ( ! rooms [ i ][ j ]) q . push ({ i , j }); } } for ( int d = 1 ; ! q . empty (); d ++ ) { for ( int k = q . size (); k ; k -- ) { int i = q . front (). first , j = q . front (). second ; q . pop (); add ( rooms , q , i - 1 , j , m , n , d ); add ( rooms , q , i + 1 , j , m , n , d ); add ( rooms , q , i , j - 1 , m , n , d ); add ( rooms , q , i , j + 1 , m , n , d ); } } } private : void add ( vector vector int rooms , queue pair int , int q , int i , int j , int m , int n , int d ) { if ( i = 0 i m j = 0 j n rooms [ i ][ j ] d ) { q . push ({ i , j }); rooms [ i ][ j ] = d ; } } };","title":"Walls and Gates"},{"location":"LeetCodeLocked/c1.24/#walls-and-gates","text":"Question You are given a m x n 2D grid initialized with these three possible values. -1 - A wall or an obstacle. 0 - A gate. INF - Infinity means an empty room. We use the value 231 - 1 = 2147483647 to represent INF as you may assume that the distance to a gate is less than 2147483647 . Fill each empty room with the distance to its nearest gate. If it is impossible to reach a gate, it should be filled with INF . For example, given the 2D grid: 1 2 3 4 INF -1 0 INF INF INF INF -1 INF -1 INF -1 0 -1 INF INF After running your function, the 2D grid should be: 1 2 3 4 3 -1 0 1 2 2 1 -1 1 -1 2 -1 0 -1 3 4 Solution BFS with appropriate pruning. refer to this post and here . 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 class Solution { public : void wallsAndGates ( vector vector int rooms ) { if ( rooms . empty ()) return ; int m = rooms . size (), n = rooms [ 0 ]. size (); queue pair int , int q ; for ( int i = 0 ; i m ; i ++ ) { for ( int j = 0 ; j n ; j ++ ) { if ( ! rooms [ i ][ j ]) q . push ({ i , j }); } } for ( int d = 1 ; ! q . empty (); d ++ ) { for ( int k = q . size (); k ; k -- ) { int i = q . front (). first , j = q . front (). second ; q . pop (); add ( rooms , q , i - 1 , j , m , n , d ); add ( rooms , q , i + 1 , j , m , n , d ); add ( rooms , q , i , j - 1 , m , n , d ); add ( rooms , q , i , j + 1 , m , n , d ); } } } private : void add ( vector vector int rooms , queue pair int , int q , int i , int j , int m , int n , int d ) { if ( i = 0 i m j = 0 j n rooms [ i ][ j ] d ) { q . push ({ i , j }); rooms [ i ][ j ] = d ; } } };","title":"Walls and Gates"},{"location":"LeetCodeLocked/c1.25/","text":"Inorder Successor Question Given a binary search tree and a node in it, find the in-order successor of that node in the BST. Note If the given node has no in-order successor in the tree, return null. Solution from here There are just two cases: The easier one: p has right subtree, then its successor is just the leftmost child of its right subtree; The harder one: p has no right subtree, then a traversal is needed to find its successor. Traversal : we start from the root, each time we see a node with val larger than p - val , we know this node may be p's successor. So we record it in suc. Then we try to move to the next level of the tree: if p - val root - val , which means p is in the right subtree, then its successor is also in the right subtree, so we update root = root - right; if p - val root - val , we update root = root - left similarly; once we find p - val == root - val , we know we've reached at p and the current sucis just its successor. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 class Solution { public : TreeNode * inorderSuccessor ( TreeNode * root , TreeNode * p ) { if ( p - right ) return leftMost ( p - right ); TreeNode * suc = NULL ; while ( root ) { if ( p - val root - val ) { suc = root ; root = root - left ; } else if ( p - val root - val ) root = root - right ; else break ; } return suc ; } private : TreeNode * leftMost ( TreeNode * node ) { while ( node - left ) node = node - left ; return node ; } }; Another solution: 1 2 3 4 5 6 7 8 9 10 11 class Solution { public : TreeNode * inorderSuccessor ( TreeNode * root , TreeNode * p ) { TreeNode * suc = NULL ; while ( root ) { root = ( root - val = p - val ) ? root - right : ( suc = root ) - left ; } return suc ; } };","title":"Inorder Successor"},{"location":"LeetCodeLocked/c1.25/#inorder-successor","text":"Question Given a binary search tree and a node in it, find the in-order successor of that node in the BST. Note If the given node has no in-order successor in the tree, return null. Solution from here There are just two cases: The easier one: p has right subtree, then its successor is just the leftmost child of its right subtree; The harder one: p has no right subtree, then a traversal is needed to find its successor. Traversal : we start from the root, each time we see a node with val larger than p - val , we know this node may be p's successor. So we record it in suc. Then we try to move to the next level of the tree: if p - val root - val , which means p is in the right subtree, then its successor is also in the right subtree, so we update root = root - right; if p - val root - val , we update root = root - left similarly; once we find p - val == root - val , we know we've reached at p and the current sucis just its successor. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 class Solution { public : TreeNode * inorderSuccessor ( TreeNode * root , TreeNode * p ) { if ( p - right ) return leftMost ( p - right ); TreeNode * suc = NULL ; while ( root ) { if ( p - val root - val ) { suc = root ; root = root - left ; } else if ( p - val root - val ) root = root - right ; else break ; } return suc ; } private : TreeNode * leftMost ( TreeNode * node ) { while ( node - left ) node = node - left ; return node ; } }; Another solution: 1 2 3 4 5 6 7 8 9 10 11 class Solution { public : TreeNode * inorderSuccessor ( TreeNode * root , TreeNode * p ) { TreeNode * suc = NULL ; while ( root ) { root = ( root - val = p - val ) ? root - right : ( suc = root ) - left ; } return suc ; } };","title":"Inorder Successor"},{"location":"LeetCodeLocked/c1.26/","text":"Unique Word Abbreviation Question An abbreviation of a word follows the form . Below are some examples of word abbreviations: a) it -- it (no abbreviation) 1 1 b) d|o|g -- d1g 1 2 1 1 1 1---5----0----5--8 c) i|nternationalizatio|n -- i18n 1 2 1 1---5----0 d) l|ocalizatio|n -- l10n Assume you have a dictionary and given a word, find whether its abbreviation is unique in the dictionary. A word's abbreviation is unique if no other word from the dictionary has the same abbreviation. Example: Given dictionary = [ \"deer\", \"door\", \"cake\", \"card\" ] 1 2 3 4 isUnique ( dear ) - false isUnique ( cart ) - true isUnique ( cane ) - false isUnique ( make ) - true Solution use map to store the abbrev and set of the original string (in case the same string is appeared in the set) 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 class ValidWordAbbr { public : ValidWordAbbr ( vector string dictionary ) { for ( string d : dictionary ) { int n = d . length (); string abbr = d [ 0 ] + to_string ( n ) + d [ n - 1 ]; mp [ abbr ]. insert ( d ); } } bool isUnique ( string word ) { int n = word . length (); string abbr = word [ 0 ] + to_string ( n ) + word [ n - 1 ]; return mp [ abbr ]. count ( word ) == mp [ abbr ]. size (); } private : unordered_map string , unordered_set string mp ; }; // Your ValidWordAbbr object will be instantiated and called as such: // ValidWordAbbr vwa(dictionary); // vwa.isUnique( hello ); // vwa.isUnique( anotherWord );","title":"Unique Word Abbreviation"},{"location":"LeetCodeLocked/c1.26/#unique-word-abbreviation","text":"Question An abbreviation of a word follows the form . Below are some examples of word abbreviations: a) it -- it (no abbreviation) 1 1 b) d|o|g -- d1g 1 2 1 1 1 1---5----0----5--8 c) i|nternationalizatio|n -- i18n 1 2 1 1---5----0 d) l|ocalizatio|n -- l10n Assume you have a dictionary and given a word, find whether its abbreviation is unique in the dictionary. A word's abbreviation is unique if no other word from the dictionary has the same abbreviation. Example: Given dictionary = [ \"deer\", \"door\", \"cake\", \"card\" ] 1 2 3 4 isUnique ( dear ) - false isUnique ( cart ) - true isUnique ( cane ) - false isUnique ( make ) - true Solution use map to store the abbrev and set of the original string (in case the same string is appeared in the set) 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 class ValidWordAbbr { public : ValidWordAbbr ( vector string dictionary ) { for ( string d : dictionary ) { int n = d . length (); string abbr = d [ 0 ] + to_string ( n ) + d [ n - 1 ]; mp [ abbr ]. insert ( d ); } } bool isUnique ( string word ) { int n = word . length (); string abbr = word [ 0 ] + to_string ( n ) + word [ n - 1 ]; return mp [ abbr ]. count ( word ) == mp [ abbr ]. size (); } private : unordered_map string , unordered_set string mp ; }; // Your ValidWordAbbr object will be instantiated and called as such: // ValidWordAbbr vwa(dictionary); // vwa.isUnique( hello ); // vwa.isUnique( anotherWord );","title":"Unique Word Abbreviation"},{"location":"LeetCodeLocked/c1.27/","text":"Word Pattern II Question Given a pattern and a string str, find if str follows the same pattern. Here follow means a full match, such that there is a bijection between a letter in pattern and a non-empty substring in str. Examples: 1 2 3 pattern = abab , str = redblueredblue should return true. pattern = aaaa , str = asdasdasdasd should return true. pattern = aabb , str = xyzabcxzyabc should return false. Notes: You may assume both pattern and str contains only lowercase letters. Solution solution from [here] (http://www.cnblogs.com/jcliBlogger/p/4870514.html) and [here] (https://leetcode.com/discuss/63252/share-my-java-backtracking-solution) 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 class Solution { public : bool wordPatternMatch ( string pattern , string str ) { unordered_set string st ; unordered_map char , string mp ; return match ( str , 0 , pattern , 0 , st , mp ); } private : bool match ( string str , int i , string pat , int j , unordered_set string st , unordered_map char , string mp ) { int m = str . length (), n = pat . length (); if ( i == m j == n ) return true ; if ( i == m || j == n ) return false ; char c = pat [ j ]; if ( mp . find ( c ) != mp . end ()) { string s = mp [ c ]; int l = s . length (); if ( s != str . substr ( i , l )) return false ; return match ( str , i + l , pat , j + 1 , st , mp ); } for ( int k = i ; k m ; k ++ ) { string s = str . substr ( i , k - i + 1 ); if ( st . find ( s ) != st . end ()) continue ; st . insert ( s ); mp [ c ] = s ; if ( match ( str , k + 1 , pat , j + 1 , st , mp )) return true ; st . erase ( s ); mp . erase ( c ); } return false ; } };","title":"Word Pattern II"},{"location":"LeetCodeLocked/c1.27/#word-pattern-ii","text":"Question Given a pattern and a string str, find if str follows the same pattern. Here follow means a full match, such that there is a bijection between a letter in pattern and a non-empty substring in str. Examples: 1 2 3 pattern = abab , str = redblueredblue should return true. pattern = aaaa , str = asdasdasdasd should return true. pattern = aabb , str = xyzabcxzyabc should return false. Notes: You may assume both pattern and str contains only lowercase letters. Solution solution from [here] (http://www.cnblogs.com/jcliBlogger/p/4870514.html) and [here] (https://leetcode.com/discuss/63252/share-my-java-backtracking-solution) 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 class Solution { public : bool wordPatternMatch ( string pattern , string str ) { unordered_set string st ; unordered_map char , string mp ; return match ( str , 0 , pattern , 0 , st , mp ); } private : bool match ( string str , int i , string pat , int j , unordered_set string st , unordered_map char , string mp ) { int m = str . length (), n = pat . length (); if ( i == m j == n ) return true ; if ( i == m || j == n ) return false ; char c = pat [ j ]; if ( mp . find ( c ) != mp . end ()) { string s = mp [ c ]; int l = s . length (); if ( s != str . substr ( i , l )) return false ; return match ( str , i + l , pat , j + 1 , st , mp ); } for ( int k = i ; k m ; k ++ ) { string s = str . substr ( i , k - i + 1 ); if ( st . find ( s ) != st . end ()) continue ; st . insert ( s ); mp [ c ] = s ; if ( match ( str , k + 1 , pat , j + 1 , st , mp )) return true ; st . erase ( s ); mp . erase ( c ); } return false ; } };","title":"Word Pattern II"},{"location":"LeetCodeLocked/c1.28/","text":"Flip Game Question You are playing the following Flip Game with your friend: Given a string that contains only these two characters: + and - , you and your friend take turns to flip two consecutive \"++\" into \"--\". The game ends when a person can no longer make a move and therefore the other person will be the winner. Write a function to compute all possible states of the string after one valid move. For example, given s = \"++++\", after one move, it may become one of the following states: 1 2 3 4 5 [ --++ , +--+ , ++-- ] If there is no valid move, return an empty list [] . Solution 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 class Solution { public : vector string generatePossibleNextMoves ( string s ) { vector string moves ; int n = s . length (); for ( int i = 0 ; i n - 1 ; i ++ ) { if ( s [ i ] == + s [ i + 1 ] == + ) { s [ i ] = s [ i + 1 ] = - ; moves . push_back ( s ); s [ i ] = s [ i + 1 ] = + ; } } return moves ; } }; Flip Game II Question You are playing the following Flip Game with your friend: Given a string that contains only these two characters: + and - , you and your friend take turns to flip two consecutive \"++\" into \"--\". The game ends when a person can no longer make a move and therefore the other person will be the winner. Write a function to determine if the starting player can guarantee a win. For example, given s = \"++++\", return true. The starting player can guarantee a win by flipping the middle \"++\" to become \"+--+\". Follow up: Derive your algorithm's runtime complexity. Solution short answer from here . 1 2 3 4 5 6 7 8 9 class Solution { public : bool canWin ( string s ) { for ( int i = - 1 ; ( i = s . find ( ++ , i + 1 )) = 0 ; ) if ( ! canWin ( s . substr ( 0 , i ) + - + s . substr ( i + 2 ))) return true ; return false ; } }; or here","title":"Flip Game I, II"},{"location":"LeetCodeLocked/c1.28/#flip-game","text":"Question You are playing the following Flip Game with your friend: Given a string that contains only these two characters: + and - , you and your friend take turns to flip two consecutive \"++\" into \"--\". The game ends when a person can no longer make a move and therefore the other person will be the winner. Write a function to compute all possible states of the string after one valid move. For example, given s = \"++++\", after one move, it may become one of the following states: 1 2 3 4 5 [ --++ , +--+ , ++-- ] If there is no valid move, return an empty list [] . Solution 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 class Solution { public : vector string generatePossibleNextMoves ( string s ) { vector string moves ; int n = s . length (); for ( int i = 0 ; i n - 1 ; i ++ ) { if ( s [ i ] == + s [ i + 1 ] == + ) { s [ i ] = s [ i + 1 ] = - ; moves . push_back ( s ); s [ i ] = s [ i + 1 ] = + ; } } return moves ; } };","title":"Flip Game"},{"location":"LeetCodeLocked/c1.28/#flip-game-ii","text":"Question You are playing the following Flip Game with your friend: Given a string that contains only these two characters: + and - , you and your friend take turns to flip two consecutive \"++\" into \"--\". The game ends when a person can no longer make a move and therefore the other person will be the winner. Write a function to determine if the starting player can guarantee a win. For example, given s = \"++++\", return true. The starting player can guarantee a win by flipping the middle \"++\" to become \"+--+\". Follow up: Derive your algorithm's runtime complexity. Solution short answer from here . 1 2 3 4 5 6 7 8 9 class Solution { public : bool canWin ( string s ) { for ( int i = - 1 ; ( i = s . find ( ++ , i + 1 )) = 0 ; ) if ( ! canWin ( s . substr ( 0 , i ) + - + s . substr ( i + 2 ))) return true ; return false ; } }; or here","title":"Flip Game II"},{"location":"LeetCodeLocked/c1.29/","text":"Best Meeting Point Question A group of two or more people wants to meet and minimize the total travel distance. You are given a 2D grid of values 0 or 1, where each 1 marks the home of someone in the group. The distance is calculated using Manhattan Distance, where distance (p1, p2) = |p2.x - p1.x| + |p2.y - p1.y| . For example, given three people living at (0,0), (0,4), and (2,2): 1 2 3 4 5 1 - 0 - 0 - 0 - 1 | | | | | 0 - 0 - 0 - 0 - 0 | | | | | 0 - 0 - 1 - 0 - 0 The point (0,2) is an ideal meeting point, as the total travel distance of 2+2+2=6 is minimal. So return 6. Hint Try to solve it in one dimension first. How can this solution apply to the two dimension case? Solution median 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 class Solution { public : int minTotalDistance ( vector vector int grid ) { int m = grid . size (), n = grid [ 0 ]. size (); vector int ii , jj ; for ( int i = 0 ; i m ; i ++ ) { for ( int j = 0 ; j n ; j ++ ) { if ( grid [ i ][ j ]) { ii . push_back ( i ); jj . push_back ( j ); } } } sort ( jj . begin (), jj . end ()); int c = ii . size (), res = 0 , io = ii [ c / 2 ], jo = jj [ c / 2 ]; for ( int i : ii ) res += abs ( i - io ); for ( int j : jj ) res += abs ( j - jo ); return res ; } };","title":"Best Meeting Point"},{"location":"LeetCodeLocked/c1.29/#best-meeting-point","text":"Question A group of two or more people wants to meet and minimize the total travel distance. You are given a 2D grid of values 0 or 1, where each 1 marks the home of someone in the group. The distance is calculated using Manhattan Distance, where distance (p1, p2) = |p2.x - p1.x| + |p2.y - p1.y| . For example, given three people living at (0,0), (0,4), and (2,2): 1 2 3 4 5 1 - 0 - 0 - 0 - 1 | | | | | 0 - 0 - 0 - 0 - 0 | | | | | 0 - 0 - 1 - 0 - 0 The point (0,2) is an ideal meeting point, as the total travel distance of 2+2+2=6 is minimal. So return 6. Hint Try to solve it in one dimension first. How can this solution apply to the two dimension case? Solution median 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 class Solution { public : int minTotalDistance ( vector vector int grid ) { int m = grid . size (), n = grid [ 0 ]. size (); vector int ii , jj ; for ( int i = 0 ; i m ; i ++ ) { for ( int j = 0 ; j n ; j ++ ) { if ( grid [ i ][ j ]) { ii . push_back ( i ); jj . push_back ( j ); } } } sort ( jj . begin (), jj . end ()); int c = ii . size (), res = 0 , io = ii [ c / 2 ], jo = jj [ c / 2 ]; for ( int i : ii ) res += abs ( i - io ); for ( int j : jj ) res += abs ( j - jo ); return res ; } };","title":"Best Meeting Point"},{"location":"LeetCodeLocked/c1.3/","text":"Read N Characters Given Read4 I, II Question 1 The API int read4(char *buf) reads 4 characters at a time from a file. The return value is the actual number of characters read. For example, it returns 3 if there is only 3 characters left in the file. By using the read4 API, implement the function int read(char *buf, int n) that reads n characters from the file. Note The read function will only be called once for each test case. Solution \u7531\u4e8e\u6bcf\u6b21\u53ea\u80fd\u8bfb\u8fdb4\u4e2a\u5b57\u7b26\uff0c\u800cn\u672a\u5fc5\u662f4\u7684\u500d\u6570\u3002\u6240\u4ee5\u4e00\u76f4\u8bfb\u5230len+4 n\u65f6\u505c\u6b62\u3002\u5269\u4e0bm = n-len 4 \u4e2a\u5b57\u7b26\u3002\u5efa\u7acb\u4e00\u4e2a\u65b0\u7684\u7f13\u5b58remain\u8bfb\u51654\u4e2a\u5b57\u7b26\uff0c\u7136\u540e\u5c06\u5176\u4e2d\u7684m\u4e2a\u5199\u5165buff\u5c3e\u90e8\u3002\u8981\u6ce8\u610f\u5728\u6574\u4e2a\u8bfb\u5165\u8fc7\u7a0b\u4e2d\u7684\u6bcf\u4e2a\u9636\u6bb5\u5224\u65ad\u662f\u5426\u5df2\u7ecf\u8bfb\u5b8c\u6587\u4ef6\u3002 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 // Forward declaration of the read4 API. int read4 ( char * buf ); class Solution { public : /** * @param buf Destination buffer * @param n Maximum number of characters to read * @return The number of characters read */ int read ( char * buf , int n ) { int len = 0 ; int m = INT_MAX ; while ( len + 4 = n ) { m = read4 ( buf + len ); len += m ; if ( m 4 ) break ; } if ( len == n || m 4 ) return len ; char * remain = new char [ 5 ]; m = min ( read4 ( remain ), n - len ); for ( int i = 0 ; i m ; i ++ ) buf [ len ++ ] = remain [ i ]; delete [] remain ; return len ; } int read2 ( char * buf , int n ) { char tmp [ 4 ]; int idx = 0 , cnt4 ; while ( idx n ) { cnt4 = read4 ( tmp ); for ( int i = 0 ; i cnt4 idx n ; ++ i ) { buf [ idx ++ ] = tmp [ i ]; } if ( cnt4 4 ) break ; } return idx ; } }; 1 Question 2 Read N Characters Given Read4 II - Call multiple times Solution 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 /* The read4 API is defined in the parent class Reader4. int read4(char[] buf); */ public class Solution extends Reader4 { private char [] buffer = new char [ 4 ]; int offset = 0 , bufsize = 0 ; /** * @param buf Destination buffer * @param n Maximum number of characters to read * @return The number of characters read */ public int read ( char [] buf , int n ) { int readBytes = 0 ; boolean eof = false ; while (! eof readBytes n ) { int sz = ( bufsize 0 ) ? bufsize : read4 ( buffer ); if ( bufsize == 0 sz 4 ) eof = true ; int bytes = Math . min ( n - readBytes , sz ); System . arraycopy ( buffer /* src */ , offset /* srcPos */ , buf /* dest */ , readBytes /* destPos */ , bytes /* length */ ); offset = ( offset + bytes ) % 4 ; bufsize = sz - bytes ; readBytes += bytes ; } return readBytes ; } } 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 // Forward declaration of the read4 API. int read4 ( char * buf ); class Solution { private : char tmp [ 4 ]; int tmp_idx = 0 , tmp_len = 0 ; public : /** * @param buf Destination buffer * @param n Maximum number of characters to read * @return The number of characters read */ int read ( char * buf , int n ) { int idx = 0 ; bool flag ; while ( idx n ) { flag = true ; if ( tmp_idx == tmp_len ) { tmp_idx = 0 ; tmp_len = read4 ( tmp ); if ( tmp_len != 4 ) flag = false ; } for (; tmp_idx tmp_len idx n ; ++ tmp_idx ) { buf [ idx ++ ] = tmp [ tmp_idx ]; } if ( ! flag ) break ; } return idx ; } }; another solution Key Idea: First Read from internal buffer, then file, then push superfluous to the internal buffer. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 // Forward declaration of the read4 API. int read4 ( char * buf ); class Solution { public : /** * @param buf Destination buffer * @param n Maximum number of characters to read * @return The number of characters read */ queue char tank ; int read ( char * buf , int n ) { int w = 0 , wBuf ; char * pBuf = buf ; while ( w n ! tank . empty ()) { * pBuf = tank . front (); tank . pop (); w ++ ; pBuf ++ ; } while ( w n ( wBuf = read4 ( pBuf )) ) { w += wBuf ; pBuf += wBuf ; } if ( w = n ) { for ( int i = 0 ; i w - n ; i ++ ) { tank . push ( pBuf [ n - w + i ]); } pBuf [ n - w ] = \\0 ; w = n ; } buf += w ; return w ; } };","title":"Read N Characters Given Read4 I, II"},{"location":"LeetCodeLocked/c1.3/#read-n-characters-given-read4-i-ii","text":"Question 1 The API int read4(char *buf) reads 4 characters at a time from a file. The return value is the actual number of characters read. For example, it returns 3 if there is only 3 characters left in the file. By using the read4 API, implement the function int read(char *buf, int n) that reads n characters from the file. Note The read function will only be called once for each test case. Solution \u7531\u4e8e\u6bcf\u6b21\u53ea\u80fd\u8bfb\u8fdb4\u4e2a\u5b57\u7b26\uff0c\u800cn\u672a\u5fc5\u662f4\u7684\u500d\u6570\u3002\u6240\u4ee5\u4e00\u76f4\u8bfb\u5230len+4 n\u65f6\u505c\u6b62\u3002\u5269\u4e0bm = n-len 4 \u4e2a\u5b57\u7b26\u3002\u5efa\u7acb\u4e00\u4e2a\u65b0\u7684\u7f13\u5b58remain\u8bfb\u51654\u4e2a\u5b57\u7b26\uff0c\u7136\u540e\u5c06\u5176\u4e2d\u7684m\u4e2a\u5199\u5165buff\u5c3e\u90e8\u3002\u8981\u6ce8\u610f\u5728\u6574\u4e2a\u8bfb\u5165\u8fc7\u7a0b\u4e2d\u7684\u6bcf\u4e2a\u9636\u6bb5\u5224\u65ad\u662f\u5426\u5df2\u7ecf\u8bfb\u5b8c\u6587\u4ef6\u3002 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 // Forward declaration of the read4 API. int read4 ( char * buf ); class Solution { public : /** * @param buf Destination buffer * @param n Maximum number of characters to read * @return The number of characters read */ int read ( char * buf , int n ) { int len = 0 ; int m = INT_MAX ; while ( len + 4 = n ) { m = read4 ( buf + len ); len += m ; if ( m 4 ) break ; } if ( len == n || m 4 ) return len ; char * remain = new char [ 5 ]; m = min ( read4 ( remain ), n - len ); for ( int i = 0 ; i m ; i ++ ) buf [ len ++ ] = remain [ i ]; delete [] remain ; return len ; } int read2 ( char * buf , int n ) { char tmp [ 4 ]; int idx = 0 , cnt4 ; while ( idx n ) { cnt4 = read4 ( tmp ); for ( int i = 0 ; i cnt4 idx n ; ++ i ) { buf [ idx ++ ] = tmp [ i ]; } if ( cnt4 4 ) break ; } return idx ; } }; 1 Question 2 Read N Characters Given Read4 II - Call multiple times Solution 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 /* The read4 API is defined in the parent class Reader4. int read4(char[] buf); */ public class Solution extends Reader4 { private char [] buffer = new char [ 4 ]; int offset = 0 , bufsize = 0 ; /** * @param buf Destination buffer * @param n Maximum number of characters to read * @return The number of characters read */ public int read ( char [] buf , int n ) { int readBytes = 0 ; boolean eof = false ; while (! eof readBytes n ) { int sz = ( bufsize 0 ) ? bufsize : read4 ( buffer ); if ( bufsize == 0 sz 4 ) eof = true ; int bytes = Math . min ( n - readBytes , sz ); System . arraycopy ( buffer /* src */ , offset /* srcPos */ , buf /* dest */ , readBytes /* destPos */ , bytes /* length */ ); offset = ( offset + bytes ) % 4 ; bufsize = sz - bytes ; readBytes += bytes ; } return readBytes ; } } 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 // Forward declaration of the read4 API. int read4 ( char * buf ); class Solution { private : char tmp [ 4 ]; int tmp_idx = 0 , tmp_len = 0 ; public : /** * @param buf Destination buffer * @param n Maximum number of characters to read * @return The number of characters read */ int read ( char * buf , int n ) { int idx = 0 ; bool flag ; while ( idx n ) { flag = true ; if ( tmp_idx == tmp_len ) { tmp_idx = 0 ; tmp_len = read4 ( tmp ); if ( tmp_len != 4 ) flag = false ; } for (; tmp_idx tmp_len idx n ; ++ tmp_idx ) { buf [ idx ++ ] = tmp [ tmp_idx ]; } if ( ! flag ) break ; } return idx ; } }; another solution Key Idea: First Read from internal buffer, then file, then push superfluous to the internal buffer. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 // Forward declaration of the read4 API. int read4 ( char * buf ); class Solution { public : /** * @param buf Destination buffer * @param n Maximum number of characters to read * @return The number of characters read */ queue char tank ; int read ( char * buf , int n ) { int w = 0 , wBuf ; char * pBuf = buf ; while ( w n ! tank . empty ()) { * pBuf = tank . front (); tank . pop (); w ++ ; pBuf ++ ; } while ( w n ( wBuf = read4 ( pBuf )) ) { w += wBuf ; pBuf += wBuf ; } if ( w = n ) { for ( int i = 0 ; i w - n ; i ++ ) { tank . push ( pBuf [ n - w + i ]); } pBuf [ n - w ] = \\0 ; w = n ; } buf += w ; return w ; } };","title":"Read N Characters Given Read4 I, II"},{"location":"LeetCodeLocked/c1.30/","text":"Binary Tree Longest Consecutive Sequence Problem Given a binary tree, find the length of the longest consecutive sequence path. The path refers to any sequence of nodes from some starting node to any node in the tree along the parent-child connections. The longest consecutive path need to be from parent to child (cannot be the reverse). For example, 1 2 3 4 5 6 7 1 \\ 3 / \\ 2 4 \\ 5 Longest consecutive sequence path is 3-4-5, so return 3. 1 2 3 4 5 6 7 2 \\ 3 / 2 / 1 Longest consecutive sequence path is 2-3',not 3-2-1', so return `2'. Solution here 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 /** * Definition for a binary tree node. * struct TreeNode { * int val; * TreeNode *left; * TreeNode *right; * TreeNode(int x) : val(x), left(NULL), right(NULL) {} * }; */ class Solution { public : int longestConsecutive ( TreeNode * root ) { return longest ( root , NULL , 0 ); } private : int longest ( TreeNode * now , TreeNode * parent , int len ) { if ( ! now ) return len ; len = ( parent now - val == parent - val + 1 ) ? len + 1 : 1 ; return max ( len , max ( longest ( now - left , now , len ), longest ( now - right , now , len ))); } }; another implementation 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 class Solution { public : int longestConsecutive ( TreeNode * root ) { if ( root == nullptr ) { return 0 ; } return longest ( root , 1 , INT_MAX ); } private : int longest ( TreeNode * root , int curLen , int lasValue ) { if ( root == nullptr ) return curLen ; if ( root - val == lasValue + 1 ) { curLen ++ ; } else { curLen = 1 ; } int left = longest ( root - left , curLen , root - val ); int right = longest ( root - right , curLen , root - val ); return max ( curLen , max ( left , right )); } };","title":"Binary Tree Longest Consecutive Sequence"},{"location":"LeetCodeLocked/c1.30/#binary-tree-longest-consecutive-sequence","text":"Problem Given a binary tree, find the length of the longest consecutive sequence path. The path refers to any sequence of nodes from some starting node to any node in the tree along the parent-child connections. The longest consecutive path need to be from parent to child (cannot be the reverse). For example, 1 2 3 4 5 6 7 1 \\ 3 / \\ 2 4 \\ 5 Longest consecutive sequence path is 3-4-5, so return 3. 1 2 3 4 5 6 7 2 \\ 3 / 2 / 1 Longest consecutive sequence path is 2-3',not 3-2-1', so return `2'. Solution here 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 /** * Definition for a binary tree node. * struct TreeNode { * int val; * TreeNode *left; * TreeNode *right; * TreeNode(int x) : val(x), left(NULL), right(NULL) {} * }; */ class Solution { public : int longestConsecutive ( TreeNode * root ) { return longest ( root , NULL , 0 ); } private : int longest ( TreeNode * now , TreeNode * parent , int len ) { if ( ! now ) return len ; len = ( parent now - val == parent - val + 1 ) ? len + 1 : 1 ; return max ( len , max ( longest ( now - left , now , len ), longest ( now - right , now , len ))); } }; another implementation 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 class Solution { public : int longestConsecutive ( TreeNode * root ) { if ( root == nullptr ) { return 0 ; } return longest ( root , 1 , INT_MAX ); } private : int longest ( TreeNode * root , int curLen , int lasValue ) { if ( root == nullptr ) return curLen ; if ( root - val == lasValue + 1 ) { curLen ++ ; } else { curLen = 1 ; } int left = longest ( root - left , curLen , root - val ); int right = longest ( root - right , curLen , root - val ); return max ( curLen , max ( left , right )); } };","title":"Binary Tree Longest Consecutive Sequence"},{"location":"LeetCodeLocked/c1.31/","text":"Smallest Rectangle Enclosing Black Pixels Question An image is represented by a binary matrix with 0 as a white pixel and 1 as a black pixel. The black pixels are connected, i.e., there is only one black region. Pixels are connected horizontally and vertically. Given the location (x, y) of one of the black pixels, return the area of the smallest (axis-aligned) rectangle that encloses all black pixels. For example, given the following image: 1 2 3 4 5 [ 0010 , 0110 , 0100 ] and x = 0 , y = 2 , Return 6 . Solution DFS and binary search here 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 // binary search class Solution { public : int minArea ( vector vector char image , int x , int y ) { int m = image . size (), n = image [ 0 ]. size (); int l = search ( image , 0 , x , 0 , n , true , true ); int r = search ( image , x + 1 , m , 0 , n , false , true ); int u = search ( image , 0 , y , l , r , true , false ); int d = search ( image , y + 1 , n , l , r , false , false ); return ( r - l ) * ( d - u ); } private : bool white ( vector vector char image , int mid , int k , int row ) { return ( row ? image [ mid ][ k ] : image [ k ][ mid ]) == 0 ; } int search ( vector vector char image , int b , int e , int mini , int maxi , bool first , bool row ) { while ( b != e ) { int mid = ( b + e ) / 2 , k = mini ; while ( k maxi white ( image , mid , k , row )) k ++ ; if ( k maxi == first ) e = mid ; else b = mid + 1 ; } return b ; } }; BFS","title":"Smallest Rectangle Enclosing Black Pixels"},{"location":"LeetCodeLocked/c1.31/#smallest-rectangle-enclosing-black-pixels","text":"Question An image is represented by a binary matrix with 0 as a white pixel and 1 as a black pixel. The black pixels are connected, i.e., there is only one black region. Pixels are connected horizontally and vertically. Given the location (x, y) of one of the black pixels, return the area of the smallest (axis-aligned) rectangle that encloses all black pixels. For example, given the following image: 1 2 3 4 5 [ 0010 , 0110 , 0100 ] and x = 0 , y = 2 , Return 6 . Solution DFS and binary search here 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 // binary search class Solution { public : int minArea ( vector vector char image , int x , int y ) { int m = image . size (), n = image [ 0 ]. size (); int l = search ( image , 0 , x , 0 , n , true , true ); int r = search ( image , x + 1 , m , 0 , n , false , true ); int u = search ( image , 0 , y , l , r , true , false ); int d = search ( image , y + 1 , n , l , r , false , false ); return ( r - l ) * ( d - u ); } private : bool white ( vector vector char image , int mid , int k , int row ) { return ( row ? image [ mid ][ k ] : image [ k ][ mid ]) == 0 ; } int search ( vector vector char image , int b , int e , int mini , int maxi , bool first , bool row ) { while ( b != e ) { int mid = ( b + e ) / 2 , k = mini ; while ( k maxi white ( image , mid , k , row )) k ++ ; if ( k maxi == first ) e = mid ; else b = mid + 1 ; } return b ; } }; BFS","title":"Smallest Rectangle Enclosing Black Pixels"},{"location":"LeetCodeLocked/c1.32/","text":"Number of Islands II Question A 2d grid map of m rows and n columns is initially filled with water. We may perform an addLand operation which turns the water at position (row, col) into a land. Given a list of positions to operate, count the number of islands after each addLand operation. An island is surrounded by water and is formed by connecting adjacent lands horizontally or vertically. You may assume all four edges of the grid are all surrounded by water. Example Given m = 3, n = 3 , positions = [[0,0], [0,1], [1,2], [2,1]] . Initially, the 2d grid grid is filled with water. (Assume 0 represents water and 1 represents land). 1 2 3 0 0 0 0 0 0 0 0 0 Operation #1: addLand(0, 0) turns the water at grid[0][0] into a land. 1 2 3 1 0 0 0 0 0 Number of islands = 1 0 0 0 Operation #2: addLand(0, 1) turns the water at grid[0][1] into a land. 1 2 3 1 1 0 0 0 0 Number of islands = 1 0 0 0 Operation #3: addLand(1, 2) turns the water at grid[1][2] into a land. 1 2 3 1 1 0 0 0 1 Number of islands = 2 0 0 0 Operation #4: addLand(2, 1) turns the water at grid[2][1] into a land. 1 2 3 1 1 0 0 0 1 Number of islands = 3 0 1 0 We return the result as an array: [1, 1, 2, 3] Note 0 is represented as the sea, 1 is represented as the island. If two 1 is adjacent, we consider them in the same island. We only consider up/down/left/right adjacent. Solution Union-find 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 class UnionFind2D { public : UnionFind2D ( int m , int n ) { for ( int i = 0 ; i m * n ; i ++ ) ids . push_back ( - 1 ); for ( int i = 0 ; i m * n ; i ++ ) szs . push_back ( 1 ); M = m , N = n , cnt = 0 ; } int index ( int x , int y ) { return x * N + y ; } int size ( void ) { return cnt ; } int id ( int x , int y ) { if ( x = 0 x M y = 0 y N ) return ids [ index ( x , y )]; return - 1 ; } int add ( int x , int y ) { int idx = index ( x , y ); ids [ idx ] = idx ; szs [ idx ] = 1 ; cnt ++ ; return idx ; } int root ( int i ) { for (; i != ids [ i ]; i = ids [ i ]) ids [ i ] = ids [ ids [ i ]]; return i ; } bool find ( int p , int q ) { return root ( p ) == root ( q ); } void unite ( int p , int q ) { int i = root ( p ), j = root ( q ); if ( szs [ i ] szs [ j ]) swap ( i , j ); ids [ i ] = j ; szs [ j ] += szs [ i ]; cnt -- ; } private : vector int ids , szs ; int M , N , cnt ; }; class Solution { public : vector int numIslands2 ( int m , int n , vector pair int , int positions ) { UnionFind2D islands ( m , n ); vector pair int , int dirs = { { 0 , - 1 }, { 0 , 1 }, { - 1 , 0 }, { 1 , 0 } }; vector int ans ; for ( auto pos : positions ) { int x = pos . first , y = pos . second ; int p = islands . add ( x , y ); for ( auto d : dirs ) { int q = islands . id ( x + d . first , y + d . second ); if ( q = 0 ! islands . find ( p , q )) islands . unite ( p , q ); } ans . push_back ( islands . size ()); } return ans ; } }; another implementation 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 /** * Definition for a point. * struct Point { * int x; * int y; * Point() : x(0), y(0) {} * Point(int a, int b) : x(a), y(b) {} * }; */ class Solution { public : /* * @param n an integer * @param m an integer * @param operators an array of point * @return an integer array */ int findFather ( unordered_map int , int father , int x ) { if ( father . find ( x ) == father . end ()) { father [ x ] = x ; return x ; } int res = x , tmp ; while ( res != father [ res ]) { res = father [ res ]; } while ( x != father [ x ]) { tmp = father [ x ]; father [ x ] = res ; x = tmp ; } return x ; } vector int numIslands2 ( int n , int m , vector Point operators ) { // Write your code here unordered_map int , int father ; vector int res ; int cnt = 0 ; const int dx [] = { 0 , 1 , 0 , - 1 }; const int dy [] = { 1 , 0 , - 1 , 0 }; for ( auto op : operators ) { int p = op . x * m + op . y ; int fp = findFather ( father , p ); if ( fp == p ) ++ cnt ; for ( int i = 0 ; i 4 ; ++ i ) { int xx = op . x + dx [ i ], yy = op . y + dy [ i ]; if ( xx 0 || xx = n || yy 0 || yy = m ) continue ; int q = ( op . x + dx [ i ]) * m + op . y + dy [ i ]; if ( father . find ( q ) != father . end ()) { int fq = findFather ( father , q ); if ( fp != fq ) { -- cnt ; father [ fq ] = fp ; } } } res . push_back ( cnt ); } return res ; } };","title":"Number of Islands II"},{"location":"LeetCodeLocked/c1.32/#number-of-islands-ii","text":"Question A 2d grid map of m rows and n columns is initially filled with water. We may perform an addLand operation which turns the water at position (row, col) into a land. Given a list of positions to operate, count the number of islands after each addLand operation. An island is surrounded by water and is formed by connecting adjacent lands horizontally or vertically. You may assume all four edges of the grid are all surrounded by water. Example Given m = 3, n = 3 , positions = [[0,0], [0,1], [1,2], [2,1]] . Initially, the 2d grid grid is filled with water. (Assume 0 represents water and 1 represents land). 1 2 3 0 0 0 0 0 0 0 0 0 Operation #1: addLand(0, 0) turns the water at grid[0][0] into a land. 1 2 3 1 0 0 0 0 0 Number of islands = 1 0 0 0 Operation #2: addLand(0, 1) turns the water at grid[0][1] into a land. 1 2 3 1 1 0 0 0 0 Number of islands = 1 0 0 0 Operation #3: addLand(1, 2) turns the water at grid[1][2] into a land. 1 2 3 1 1 0 0 0 1 Number of islands = 2 0 0 0 Operation #4: addLand(2, 1) turns the water at grid[2][1] into a land. 1 2 3 1 1 0 0 0 1 Number of islands = 3 0 1 0 We return the result as an array: [1, 1, 2, 3] Note 0 is represented as the sea, 1 is represented as the island. If two 1 is adjacent, we consider them in the same island. We only consider up/down/left/right adjacent. Solution Union-find 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 class UnionFind2D { public : UnionFind2D ( int m , int n ) { for ( int i = 0 ; i m * n ; i ++ ) ids . push_back ( - 1 ); for ( int i = 0 ; i m * n ; i ++ ) szs . push_back ( 1 ); M = m , N = n , cnt = 0 ; } int index ( int x , int y ) { return x * N + y ; } int size ( void ) { return cnt ; } int id ( int x , int y ) { if ( x = 0 x M y = 0 y N ) return ids [ index ( x , y )]; return - 1 ; } int add ( int x , int y ) { int idx = index ( x , y ); ids [ idx ] = idx ; szs [ idx ] = 1 ; cnt ++ ; return idx ; } int root ( int i ) { for (; i != ids [ i ]; i = ids [ i ]) ids [ i ] = ids [ ids [ i ]]; return i ; } bool find ( int p , int q ) { return root ( p ) == root ( q ); } void unite ( int p , int q ) { int i = root ( p ), j = root ( q ); if ( szs [ i ] szs [ j ]) swap ( i , j ); ids [ i ] = j ; szs [ j ] += szs [ i ]; cnt -- ; } private : vector int ids , szs ; int M , N , cnt ; }; class Solution { public : vector int numIslands2 ( int m , int n , vector pair int , int positions ) { UnionFind2D islands ( m , n ); vector pair int , int dirs = { { 0 , - 1 }, { 0 , 1 }, { - 1 , 0 }, { 1 , 0 } }; vector int ans ; for ( auto pos : positions ) { int x = pos . first , y = pos . second ; int p = islands . add ( x , y ); for ( auto d : dirs ) { int q = islands . id ( x + d . first , y + d . second ); if ( q = 0 ! islands . find ( p , q )) islands . unite ( p , q ); } ans . push_back ( islands . size ()); } return ans ; } }; another implementation 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 /** * Definition for a point. * struct Point { * int x; * int y; * Point() : x(0), y(0) {} * Point(int a, int b) : x(a), y(b) {} * }; */ class Solution { public : /* * @param n an integer * @param m an integer * @param operators an array of point * @return an integer array */ int findFather ( unordered_map int , int father , int x ) { if ( father . find ( x ) == father . end ()) { father [ x ] = x ; return x ; } int res = x , tmp ; while ( res != father [ res ]) { res = father [ res ]; } while ( x != father [ x ]) { tmp = father [ x ]; father [ x ] = res ; x = tmp ; } return x ; } vector int numIslands2 ( int n , int m , vector Point operators ) { // Write your code here unordered_map int , int father ; vector int res ; int cnt = 0 ; const int dx [] = { 0 , 1 , 0 , - 1 }; const int dy [] = { 1 , 0 , - 1 , 0 }; for ( auto op : operators ) { int p = op . x * m + op . y ; int fp = findFather ( father , p ); if ( fp == p ) ++ cnt ; for ( int i = 0 ; i 4 ; ++ i ) { int xx = op . x + dx [ i ], yy = op . y + dy [ i ]; if ( xx 0 || xx = n || yy 0 || yy = m ) continue ; int q = ( op . x + dx [ i ]) * m + op . y + dy [ i ]; if ( father . find ( q ) != father . end ()) { int fq = findFather ( father , q ); if ( fp != fq ) { -- cnt ; father [ fq ] = fp ; } } } res . push_back ( cnt ); } return res ; } };","title":"Number of Islands II"},{"location":"LeetCodeLocked/c1.33/","text":"Range Sum Query 2D - Mutable Question Given a 2D matrix, find the sum of the elements inside the rectangle defined by (row1, col1), (row2, col2). Example: 1 2 3 4 5 6 7 8 9 10 11 Given matrix = [ [3, 0, 1, 4, 2], [5, 6, 3, 2, 1], [1, 2, 0, 1, 5], [4, 1, 0, 1, 7], [1, 0, 3, 0, 5] ] sumRegion(2, 1, 4, 3) - 8 sumRegion(1, 1, 2, 2) - 11 sumRegion(1, 2, 2, 4) - 12 Note: You may assume that the matrix does not change. There are many calls to sumRegion function. You may assume that row1 \u2264 row2 and col1 \u2264 col2. Solution binary indexed tree 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 class NumMatrix { vector vector int tree ; vector vector int ma ; public : NumMatrix ( vector vector int matrix ) { int n = matrix . size (); int m = n == 0 ? 0 : matrix [ 0 ]. size (); if ( n == 0 || m == 0 ) { return ; } tree = vector vector int ( n + 1 , vector int ( m + 1 , 0 )); ma = vector vector int ( n , vector int ( m , 0 )); for ( int i = 0 ; i n ; ++ i ) { for ( int j = 0 ; j m ; ++ j ) { update ( i , j , matrix [ i ][ j ]); } } } void update ( int row , int col , int val ) { int delta = val - ma [ row ][ col ]; ma [ row ][ col ] = val ; for ( int i = row + 1 ; i = ma . size (); i += i ( - i )) { for ( int j = col + 1 ; j = ma [ 0 ]. size (); j += j ( - j )) { tree [ i ][ j ] += delta ; } //for (int j = col + 1; j 0; j -= j (-j)) { // sol += tree[i][j]; //} } return sol ; } int sumRegion ( int row1 , int col1 , int row2 , int col2 ) { } }; // Your NumMatrix object will be instantiated and called as such: // NumMatrix numMatrix(matrix); // numMatrix.sumRegion(0, 1, 2, 3); // numMatrix.update(1, 1, 10); // numMatrix.sumRegion(1, 2, 3, 4); another implementation 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 class NumMatrix { vector vector int rowSums ; vector vector int ma ; public : NumMatrix ( vector vector int matrix ) { int n = matrix . size (); int m = ( n == 0 ) ? 0 : matrix [ 0 ]. size (); if ( n == 0 || m == 0 ) { return ; } ma = matrix ; rowSums = vector vector int ( n , vector int ( m + 1 , 0 )); for ( int i = 0 ; i n ; i ++ ) { for ( int j = 1 ; j = m ; j ++ ) { rowSums [ i ][ j ] = rowSums [ i ][ j - 1 ] + matrix [ i ][ j - 1 ]; } } } void update ( int row , int col , int val ) { for ( int i = col + 1 ; i = ma [ 0 ]. size (); i ++ ) { rowSums [ row ][ i ] += ( - ma [ row ][ col ] + val ); } ma [ row ][ col ] = val ; } int sumRegion ( int row1 , int col1 , int row2 , int col2 ) { int sol = 0 ; for ( int i = row1 ; i = row2 ; i ++ ) { sol += ( rowSums [ i ][ col2 + 1 ] - rowSums [ i ][ col1 ]); } return sol ; } };","title":"Range Sum Query 2D - Mutable"},{"location":"LeetCodeLocked/c1.33/#range-sum-query-2d-mutable","text":"Question Given a 2D matrix, find the sum of the elements inside the rectangle defined by (row1, col1), (row2, col2). Example: 1 2 3 4 5 6 7 8 9 10 11 Given matrix = [ [3, 0, 1, 4, 2], [5, 6, 3, 2, 1], [1, 2, 0, 1, 5], [4, 1, 0, 1, 7], [1, 0, 3, 0, 5] ] sumRegion(2, 1, 4, 3) - 8 sumRegion(1, 1, 2, 2) - 11 sumRegion(1, 2, 2, 4) - 12 Note: You may assume that the matrix does not change. There are many calls to sumRegion function. You may assume that row1 \u2264 row2 and col1 \u2264 col2. Solution binary indexed tree 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 class NumMatrix { vector vector int tree ; vector vector int ma ; public : NumMatrix ( vector vector int matrix ) { int n = matrix . size (); int m = n == 0 ? 0 : matrix [ 0 ]. size (); if ( n == 0 || m == 0 ) { return ; } tree = vector vector int ( n + 1 , vector int ( m + 1 , 0 )); ma = vector vector int ( n , vector int ( m , 0 )); for ( int i = 0 ; i n ; ++ i ) { for ( int j = 0 ; j m ; ++ j ) { update ( i , j , matrix [ i ][ j ]); } } } void update ( int row , int col , int val ) { int delta = val - ma [ row ][ col ]; ma [ row ][ col ] = val ; for ( int i = row + 1 ; i = ma . size (); i += i ( - i )) { for ( int j = col + 1 ; j = ma [ 0 ]. size (); j += j ( - j )) { tree [ i ][ j ] += delta ; } //for (int j = col + 1; j 0; j -= j (-j)) { // sol += tree[i][j]; //} } return sol ; } int sumRegion ( int row1 , int col1 , int row2 , int col2 ) { } }; // Your NumMatrix object will be instantiated and called as such: // NumMatrix numMatrix(matrix); // numMatrix.sumRegion(0, 1, 2, 3); // numMatrix.update(1, 1, 10); // numMatrix.sumRegion(1, 2, 3, 4); another implementation 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 class NumMatrix { vector vector int rowSums ; vector vector int ma ; public : NumMatrix ( vector vector int matrix ) { int n = matrix . size (); int m = ( n == 0 ) ? 0 : matrix [ 0 ]. size (); if ( n == 0 || m == 0 ) { return ; } ma = matrix ; rowSums = vector vector int ( n , vector int ( m + 1 , 0 )); for ( int i = 0 ; i n ; i ++ ) { for ( int j = 1 ; j = m ; j ++ ) { rowSums [ i ][ j ] = rowSums [ i ][ j - 1 ] + matrix [ i ][ j - 1 ]; } } } void update ( int row , int col , int val ) { for ( int i = col + 1 ; i = ma [ 0 ]. size (); i ++ ) { rowSums [ row ][ i ] += ( - ma [ row ][ col ] + val ); } ma [ row ][ col ] = val ; } int sumRegion ( int row1 , int col1 , int row2 , int col2 ) { int sol = 0 ; for ( int i = row1 ; i = row2 ; i ++ ) { sol += ( rowSums [ i ][ col2 + 1 ] - rowSums [ i ][ col1 ]); } return sol ; } };","title":"Range Sum Query 2D - Mutable"},{"location":"LeetCodeLocked/c1.34/","text":"Sparse Matrix Multiplication Question Given two sparse matrices A and B , return the result of AB . You may assume that A's column number is equal to B's row number. Example: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 A = [ [ 1, 0, 0], [-1, 0, 3] ] B = [ [ 7, 0, 0 ], [ 0, 0, 0 ], [ 0, 0, 1 ] ] | 1 0 0 | | 7 0 0 | | 7 0 0 | AB = | -1 0 3 | x | 0 0 0 | = | -7 0 3 | | 0 0 1 | Solution Here and here 1 2 3 4 5 6 7 8 9 10 11 12 13 class Solution { public : vector vector int multiply ( vector vector int A , vector vector int B ) { int m = A . size (), n = B . size (), p = B [ 0 ]. size (); vector vector int C ( m , vector int ( p , 0 )); for ( int i = 0 ; i m ; i ++ ) for ( int j = 0 ; j n ; j ++ ) if ( A [ i ][ j ]) for ( int k = 0 ; k p ; k ++ ) C [ i ][ k ] += A [ i ][ j ] * B [ j ][ k ]; return C ; } };","title":"Sparse Matrix Multiplication"},{"location":"LeetCodeLocked/c1.34/#sparse-matrix-multiplication","text":"Question Given two sparse matrices A and B , return the result of AB . You may assume that A's column number is equal to B's row number. Example: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 A = [ [ 1, 0, 0], [-1, 0, 3] ] B = [ [ 7, 0, 0 ], [ 0, 0, 0 ], [ 0, 0, 1 ] ] | 1 0 0 | | 7 0 0 | | 7 0 0 | AB = | -1 0 3 | x | 0 0 0 | = | -7 0 3 | | 0 0 1 | Solution Here and here 1 2 3 4 5 6 7 8 9 10 11 12 13 class Solution { public : vector vector int multiply ( vector vector int A , vector vector int B ) { int m = A . size (), n = B . size (), p = B [ 0 ]. size (); vector vector int C ( m , vector int ( p , 0 )); for ( int i = 0 ; i m ; i ++ ) for ( int j = 0 ; j n ; j ++ ) if ( A [ i ][ j ]) for ( int k = 0 ; k p ; k ++ ) C [ i ][ k ] += A [ i ][ j ] * B [ j ][ k ]; return C ; } };","title":"Sparse Matrix Multiplication"},{"location":"LeetCodeLocked/c1.35/","text":"Binary Tree Vertical Order Traversal Question Given a binary tree, return the vertical order traversal of its nodes' values. (ie, from top to bottom, column by column). If two nodes are in the same row and column, the order should be from left to right. Examples: Given binary tree [3,9,20,null,null,15,7] , 1 2 3 4 5 3 / \\ 9 20 / \\ 15 7 return its vertical order traversal as: 1 2 3 4 5 6 [ [9], [3,15], [20], [7] ] Given binary tree [3,9,20,4,5,2,7] , 1 2 3 4 5 _3_ / \\ 9 20 / \\ / \\ 4 5 2 7 return its vertical order traversal as: 1 2 3 4 5 6 7 [ [4], [9], [3,5,2], [20], [7] ] Solution BFS 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 Class Solution { public : vector vector int verticalOrder ( TreeNode * root ) { vector vector int ret ; if ( root == nullptr ) { return ret ; } ret . resize ( 1 ); int l = 0 , r = 0 ; queue pair TreeNode * , int que ; //node, col que . push ( pair TreeNode * , int ( root , 0 )); while ( ! que . empty ()){ TreeNode * node = que . front (). first ; int col = que . front (). second ; que . pop (); if ( l = col col = r ){ int i = col - l ; ret [ i ]. push_back ( node - val ); } else if ( col l ){ l -- ; ret . insert ( ret . begin (), vector int ()); ret . front (). push_back ( node - val ); } else { r ++ ; ret . insert ( ret . end (), vector int ()); ret . back (). push_back ( node - val ); } if ( node - left ) que . push ( pair TreeNode * , int ( node - left , col - 1 )); if ( node - right ) que . push ( pair TreeNode * , int ( node - right , col + 1 )); } return ret ; } }; another solution: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 class Solution { public : vector vector int verticalOrder ( TreeNode * root ) { vector vector int result ; if ( ! root ) return result ; map int , pair int , int pos ; map int , vector int mp ; //do bfs to traverse first queue TreeNode * que ; que . push ( root ); mp [ 0 ]. push_back ( root - val ); pos [ root - val ] = make_pair ( 0 , 0 ); while ( ! que . empty ()) { int size = que . size (); for ( int i = 0 ; i size ; i ++ ) { TreeNode * cur = que . front (); que . pop (); int x = pos [ cur - val ]. first ; int y = pos [ cur - val ]. second ; if ( cur - left ) { que . push ( cur - left ); pos [ cur - left - val ] = make_pair ( x + 1 , y - 1 ); mp [ y - 1 ]. push_back ( cur - left - val ); } if ( cur - right ) { que . push ( cur - right ); pos [ cur - right - val ] = make_pair ( x + 1 , y + 1 ); mp [ y + 1 ]. push_back ( cur - right - val ); } } } //generate result for ( auto pair : mp ) { result . push_back ( pair . second ); } return result ; } };","title":"Binary Tree Vertical Order Traversal"},{"location":"LeetCodeLocked/c1.35/#binary-tree-vertical-order-traversal","text":"Question Given a binary tree, return the vertical order traversal of its nodes' values. (ie, from top to bottom, column by column). If two nodes are in the same row and column, the order should be from left to right. Examples: Given binary tree [3,9,20,null,null,15,7] , 1 2 3 4 5 3 / \\ 9 20 / \\ 15 7 return its vertical order traversal as: 1 2 3 4 5 6 [ [9], [3,15], [20], [7] ] Given binary tree [3,9,20,4,5,2,7] , 1 2 3 4 5 _3_ / \\ 9 20 / \\ / \\ 4 5 2 7 return its vertical order traversal as: 1 2 3 4 5 6 7 [ [4], [9], [3,5,2], [20], [7] ] Solution BFS 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 Class Solution { public : vector vector int verticalOrder ( TreeNode * root ) { vector vector int ret ; if ( root == nullptr ) { return ret ; } ret . resize ( 1 ); int l = 0 , r = 0 ; queue pair TreeNode * , int que ; //node, col que . push ( pair TreeNode * , int ( root , 0 )); while ( ! que . empty ()){ TreeNode * node = que . front (). first ; int col = que . front (). second ; que . pop (); if ( l = col col = r ){ int i = col - l ; ret [ i ]. push_back ( node - val ); } else if ( col l ){ l -- ; ret . insert ( ret . begin (), vector int ()); ret . front (). push_back ( node - val ); } else { r ++ ; ret . insert ( ret . end (), vector int ()); ret . back (). push_back ( node - val ); } if ( node - left ) que . push ( pair TreeNode * , int ( node - left , col - 1 )); if ( node - right ) que . push ( pair TreeNode * , int ( node - right , col + 1 )); } return ret ; } }; another solution: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 class Solution { public : vector vector int verticalOrder ( TreeNode * root ) { vector vector int result ; if ( ! root ) return result ; map int , pair int , int pos ; map int , vector int mp ; //do bfs to traverse first queue TreeNode * que ; que . push ( root ); mp [ 0 ]. push_back ( root - val ); pos [ root - val ] = make_pair ( 0 , 0 ); while ( ! que . empty ()) { int size = que . size (); for ( int i = 0 ; i size ; i ++ ) { TreeNode * cur = que . front (); que . pop (); int x = pos [ cur - val ]. first ; int y = pos [ cur - val ]. second ; if ( cur - left ) { que . push ( cur - left ); pos [ cur - left - val ] = make_pair ( x + 1 , y - 1 ); mp [ y - 1 ]. push_back ( cur - left - val ); } if ( cur - right ) { que . push ( cur - right ); pos [ cur - right - val ] = make_pair ( x + 1 , y + 1 ); mp [ y + 1 ]. push_back ( cur - right - val ); } } } //generate result for ( auto pair : mp ) { result . push_back ( pair . second ); } return result ; } };","title":"Binary Tree Vertical Order Traversal"},{"location":"LeetCodeLocked/c1.36/","text":"Shortest Distance from All Buildings Question You want to build a house on an empty land which reaches all buildings in the shortest amount of distance. You can only move up, down, left and right. You are given a 2D grid of values 0, 1 or 2 , where: Each 0 marks an empty land which you can pass by freely. Each 1 marks a building which you cannot pass through. Each 2 marks an obstacle which you cannot pass through. For example, given three buildings at (0,0), (0,4), (2,2) , and an obstacle at (0,2) : 1 2 3 4 5 1 - 0 - 2 - 0 - 1 | | | | | 0 - 0 - 0 - 0 - 0 | | | | | 0 - 0 - 1 - 0 - 0 The point (1,2) is an ideal empty land to build a house, as the total travel distance of 3+3+1=7 is minimal. So return 7. Note: There will be at least one building. If it is not possible to build such house according to the above rules, return -1. Solution BFS 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 Class Solution { public : int shortestDistance ( vector vector int grid ) { int rows = grid . size (); if ( rows == 0 ) { return - 1 ; } int cols = grid [ 0 ]. size (); // sum of distances to all the buildings vector vector int dist ( rows , vector int ( cols , 0 )); // number of reachable buildings vector vector int nums ( rows , vector int ( cols , 0 )); int buildingNum = 0 ; // BFS from each building for ( int i = 0 ; i rows ; ++ i ) { for ( int j = 0 ; j cols ; ++ j ) { if ( grid [ i ][ j ] == 1 ) { buildingNum ++ ; bfs ( grid , i , j , dist , nums ); } } } int minval = INT_MAX ; for ( int i = 0 ; i rows ; ++ i ) { for ( int j = 0 ; j cols ; ++ j ) { if ( grid [ i ][ j ] == 0 dist [ i ][ j ] != 0 nums [ i ][ j ] == buildingNum ) { minval = min ( minval , dist [ i ][ j ]); } } } if ( minval INT_MIN ) { return minval ; } return - 1 ; } private : void bfs ( vector vector int grid , int row , int col , vector vector int dist , vector vector int nums ) { int rows = grid . size (); int cols = grid [ 0 ]. size (); queue pair int , int q ; q . push ( make_pair ( row , col )); vector vector int dirs = {{ - 1 , 0 }, { 0 , 1 }, { 1 , 0 }, { 0 , - 1 }}; // record visited node vector vector bool visited ( rows , vector bool ( cols , false )); int level = 0 ; while ( ! q . empty ()) { level ++ ; int size = q . size (); for ( int i = 0 ; i size ; ++ i ) { pair int , int coords = q . front (); q . pop (); for ( int k = 0 ; k dirs . size (); ++ k ) { int x = coords . first + dirs [ k ][ 0 ]; int y = coords . second + dirs [ k ][ 1 ]; if ( x = 0 x rows y = 0 y cols ! visited [ x ][ y ] grid [ x ][ y ] == 0 ) { visited [ x ][ y ] = true ; dist [ x ][ y ] += level ; nums [ x ][ y ] ++ ; q . push ( make_pair ( x , y )); } } } } } };","title":"Shortest Distance from All Buildings"},{"location":"LeetCodeLocked/c1.36/#shortest-distance-from-all-buildings","text":"Question You want to build a house on an empty land which reaches all buildings in the shortest amount of distance. You can only move up, down, left and right. You are given a 2D grid of values 0, 1 or 2 , where: Each 0 marks an empty land which you can pass by freely. Each 1 marks a building which you cannot pass through. Each 2 marks an obstacle which you cannot pass through. For example, given three buildings at (0,0), (0,4), (2,2) , and an obstacle at (0,2) : 1 2 3 4 5 1 - 0 - 2 - 0 - 1 | | | | | 0 - 0 - 0 - 0 - 0 | | | | | 0 - 0 - 1 - 0 - 0 The point (1,2) is an ideal empty land to build a house, as the total travel distance of 3+3+1=7 is minimal. So return 7. Note: There will be at least one building. If it is not possible to build such house according to the above rules, return -1. Solution BFS 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 Class Solution { public : int shortestDistance ( vector vector int grid ) { int rows = grid . size (); if ( rows == 0 ) { return - 1 ; } int cols = grid [ 0 ]. size (); // sum of distances to all the buildings vector vector int dist ( rows , vector int ( cols , 0 )); // number of reachable buildings vector vector int nums ( rows , vector int ( cols , 0 )); int buildingNum = 0 ; // BFS from each building for ( int i = 0 ; i rows ; ++ i ) { for ( int j = 0 ; j cols ; ++ j ) { if ( grid [ i ][ j ] == 1 ) { buildingNum ++ ; bfs ( grid , i , j , dist , nums ); } } } int minval = INT_MAX ; for ( int i = 0 ; i rows ; ++ i ) { for ( int j = 0 ; j cols ; ++ j ) { if ( grid [ i ][ j ] == 0 dist [ i ][ j ] != 0 nums [ i ][ j ] == buildingNum ) { minval = min ( minval , dist [ i ][ j ]); } } } if ( minval INT_MIN ) { return minval ; } return - 1 ; } private : void bfs ( vector vector int grid , int row , int col , vector vector int dist , vector vector int nums ) { int rows = grid . size (); int cols = grid [ 0 ]. size (); queue pair int , int q ; q . push ( make_pair ( row , col )); vector vector int dirs = {{ - 1 , 0 }, { 0 , 1 }, { 1 , 0 }, { 0 , - 1 }}; // record visited node vector vector bool visited ( rows , vector bool ( cols , false )); int level = 0 ; while ( ! q . empty ()) { level ++ ; int size = q . size (); for ( int i = 0 ; i size ; ++ i ) { pair int , int coords = q . front (); q . pop (); for ( int k = 0 ; k dirs . size (); ++ k ) { int x = coords . first + dirs [ k ][ 0 ]; int y = coords . second + dirs [ k ][ 1 ]; if ( x = 0 x rows y = 0 y cols ! visited [ x ][ y ] grid [ x ][ y ] == 0 ) { visited [ x ][ y ] = true ; dist [ x ][ y ] += level ; nums [ x ][ y ] ++ ; q . push ( make_pair ( x , y )); } } } } } };","title":"Shortest Distance from All Buildings"},{"location":"LeetCodeLocked/c1.37/","text":"Generalized Abbreviation Question Write a function to generate the generalized abbreviations of a word. Example: Given word = \"word\" , return the following list (order does not matter): 1 2 [ word , 1ord , w1rd , wo1d , wor1 , 2rd , w2d , wo2 , 1o1d , 1or1 , w1r1 , 1o2 , 2r1 , 3d , w3 , 4 ] Solution bit mask 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 class Solution { public : vector string generateAbbreviations ( string word ) { vector string sol ; int len = word . length (); for ( int i = 0 ; i ( 1 len ); i ++ ) { int count = 0 ; string one = ; for ( int j = 0 ; j len ; j ++ ) { if ( i ( 1 j )) { count ++ ; } else { if ( count ) { one += to_string ( count ); count = 0 ; } one += word [ j ]; } } if ( count ) { one += to_string ( count ); } sol . push_back ( one ); } return sol ; } }; DFS 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 class Solution { public : vector string generateAbbreviations ( string word ) { //time: O(2^n), space: O(n) vector string res ; dfs ( res , , 0 , word ); return res ; } private : void dfs ( vector string res , string curr , int start , string s ) { // stop recursion if ( start s . size ()) { return ; } // record valid result res . push_back ( curr + s . substr ( start )); // restart int i = 0 ; // if ( start 0 ) { i = start + 1 ; } for (; i s . size (); i ++ ) { for ( int j = 1 ; j = s . size (); j ++ ) { // append substr before Number dfs ( res , curr + s . substr ( start , i - start ) + to_string ( j ), i + j , s ); } } } };","title":"Generalized Abbreviation"},{"location":"LeetCodeLocked/c1.37/#generalized-abbreviation","text":"Question Write a function to generate the generalized abbreviations of a word. Example: Given word = \"word\" , return the following list (order does not matter): 1 2 [ word , 1ord , w1rd , wo1d , wor1 , 2rd , w2d , wo2 , 1o1d , 1or1 , w1r1 , 1o2 , 2r1 , 3d , w3 , 4 ] Solution bit mask 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 class Solution { public : vector string generateAbbreviations ( string word ) { vector string sol ; int len = word . length (); for ( int i = 0 ; i ( 1 len ); i ++ ) { int count = 0 ; string one = ; for ( int j = 0 ; j len ; j ++ ) { if ( i ( 1 j )) { count ++ ; } else { if ( count ) { one += to_string ( count ); count = 0 ; } one += word [ j ]; } } if ( count ) { one += to_string ( count ); } sol . push_back ( one ); } return sol ; } }; DFS 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 class Solution { public : vector string generateAbbreviations ( string word ) { //time: O(2^n), space: O(n) vector string res ; dfs ( res , , 0 , word ); return res ; } private : void dfs ( vector string res , string curr , int start , string s ) { // stop recursion if ( start s . size ()) { return ; } // record valid result res . push_back ( curr + s . substr ( start )); // restart int i = 0 ; // if ( start 0 ) { i = start + 1 ; } for (; i s . size (); i ++ ) { for ( int j = 1 ; j = s . size (); j ++ ) { // append substr before Number dfs ( res , curr + s . substr ( start , i - start ) + to_string ( j ), i + j , s ); } } } };","title":"Generalized Abbreviation"},{"location":"LeetCodeLocked/c1.38/","text":"Number of Connected Components in an Undirected Graph Question Given n nodes labeled from 0 to n - 1 and a list of undirected edges (each edge is a pair of nodes), write a function to find the number of connected components in an undirected graph. Example 1: 1 2 3 0 3 | | 1 --- 2 4 Given n = 5 and edges = [[0, 1], [1, 2], [3, 4]] , return 2 . Example 2: 1 2 3 0 4 | | 1 --- 2 --- 3 Given n = 5 and edges = [[0, 1], [1, 2], [2, 3], [3, 4]] , return 1 . Note: You can assume that no duplicate edges will appear in edges. Since all edges are undirected, [0, 1] is the same as [1, 0] and thus will not appear together in edges. Solution Union Find 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 public class Solution { public int countComponents ( int n , int [][] edges ) { unionFind uf = new unionFind ( n ); for ( int [] edge : edges ) { if (! uf . isConnected ( edge [ 0 ], edge [ 1 ])) { uf . union ( edge [ 0 ], edge [ 1 ]); } } return uf . findCount (); } public class unionFind { int [] ids ; int count ; public unionFind ( int num ) { this . ids = new int [ num ]; for ( int i = 0 ; i num ; i ++) { ids [ i ] = i ; } this . count = num ; } public int find ( int i ) { return ids [ i ]; } public void union ( int i1 , int i2 ) { int id1 = find ( i1 ); int id2 = find ( i2 ); if ( id1 != id2 ) { for ( int i = 0 ; i ids . length ; i ++) { if ( ids [ i ] == id2 ) { ids [ i ] = id1 ; } } count --; } } public boolean isConnected ( int i1 , int i2 ) { return find ( i1 )== find ( i2 ); } public int findCount () { return count ; } } } another solution time: O(m*h), space: O(n), m\u8868\u793aedge\u7684\u6570\u91cf 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 public class Solution { public int countComponents ( int n , int [][] edges ) { int [] id = new int [ n ]; // \u521d\u59cb\u5316 for ( int i = 0 ; i n ; i ++) { id [ i ] = i ; } // union for ( int [] edge : edges ) { int i = root ( id , edge [ 0 ]); int j = root ( id , edge [ 1 ]); id [ i ] = j ; } // \u7edf\u8ba1\u6839\u8282\u70b9\u4e2a\u6570 int count = 0 ; for ( int i = 0 ; i n ; i ++) { if ( id [ i ] == i ) count ++; } return count ; } // \u627e\u6839\u8282\u70b9 public int root ( int [] id , int i ) { while ( i != id [ i ]) { id [ i ] = id [ id [ i ]]; i = id [ i ]; } return i ; } }","title":"Number of Connected Components in an Undirected Graph"},{"location":"LeetCodeLocked/c1.38/#number-of-connected-components-in-an-undirected-graph","text":"Question Given n nodes labeled from 0 to n - 1 and a list of undirected edges (each edge is a pair of nodes), write a function to find the number of connected components in an undirected graph. Example 1: 1 2 3 0 3 | | 1 --- 2 4 Given n = 5 and edges = [[0, 1], [1, 2], [3, 4]] , return 2 . Example 2: 1 2 3 0 4 | | 1 --- 2 --- 3 Given n = 5 and edges = [[0, 1], [1, 2], [2, 3], [3, 4]] , return 1 . Note: You can assume that no duplicate edges will appear in edges. Since all edges are undirected, [0, 1] is the same as [1, 0] and thus will not appear together in edges. Solution Union Find 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 public class Solution { public int countComponents ( int n , int [][] edges ) { unionFind uf = new unionFind ( n ); for ( int [] edge : edges ) { if (! uf . isConnected ( edge [ 0 ], edge [ 1 ])) { uf . union ( edge [ 0 ], edge [ 1 ]); } } return uf . findCount (); } public class unionFind { int [] ids ; int count ; public unionFind ( int num ) { this . ids = new int [ num ]; for ( int i = 0 ; i num ; i ++) { ids [ i ] = i ; } this . count = num ; } public int find ( int i ) { return ids [ i ]; } public void union ( int i1 , int i2 ) { int id1 = find ( i1 ); int id2 = find ( i2 ); if ( id1 != id2 ) { for ( int i = 0 ; i ids . length ; i ++) { if ( ids [ i ] == id2 ) { ids [ i ] = id1 ; } } count --; } } public boolean isConnected ( int i1 , int i2 ) { return find ( i1 )== find ( i2 ); } public int findCount () { return count ; } } } another solution time: O(m*h), space: O(n), m\u8868\u793aedge\u7684\u6570\u91cf 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 public class Solution { public int countComponents ( int n , int [][] edges ) { int [] id = new int [ n ]; // \u521d\u59cb\u5316 for ( int i = 0 ; i n ; i ++) { id [ i ] = i ; } // union for ( int [] edge : edges ) { int i = root ( id , edge [ 0 ]); int j = root ( id , edge [ 1 ]); id [ i ] = j ; } // \u7edf\u8ba1\u6839\u8282\u70b9\u4e2a\u6570 int count = 0 ; for ( int i = 0 ; i n ; i ++) { if ( id [ i ] == i ) count ++; } return count ; } // \u627e\u6839\u8282\u70b9 public int root ( int [] id , int i ) { while ( i != id [ i ]) { id [ i ] = id [ id [ i ]]; i = id [ i ]; } return i ; } }","title":"Number of Connected Components in an Undirected Graph"},{"location":"LeetCodeLocked/c1.39/","text":"Count of Range Sum Question Given an integer array nums, return the number of range sums that lie in [lower, upper] inclusive. Range sum S(i, j) is defined as the sum of the elements in nums between indices i and j (i \u2264 j) , inclusive. Note: A naive algorithm of O(n2) is trivial. You MUST do better than that. Example: Given nums = [-2, 5, -1] , lower = -2 , upper = 2 , Return 3 . The three ranges are : [0, 0] , [2, 2] , [0, 2] and their respective sums are: -2 , -1 , 2 . Solution","title":"C1.39"},{"location":"LeetCodeLocked/c1.39/#count-of-range-sum","text":"Question Given an integer array nums, return the number of range sums that lie in [lower, upper] inclusive. Range sum S(i, j) is defined as the sum of the elements in nums between indices i and j (i \u2264 j) , inclusive. Note: A naive algorithm of O(n2) is trivial. You MUST do better than that. Example: Given nums = [-2, 5, -1] , lower = -2 , upper = 2 , Return 3 . The three ranges are : [0, 0] , [2, 2] , [0, 2] and their respective sums are: -2 , -1 , 2 . Solution","title":"Count of Range Sum"},{"location":"LeetCodeLocked/c1.4/","text":"Shortest Word Distance I, II, III Question 1 Given a list of words and two words word1 and word2, return the shortest distance between these two words in the list. For example, Assume that words = [\"practice\", \"makes\", \"perfect\", \"coding\", \"makes\"] . Given word1 = \"coding\" , word2 = \"practice\" , return 3. Given word1 = \"makes\" , word2 = \"coding\" , return 1. Note You may assume that word1 does not equal to word2, and word1 and word2 are both in the list. Solution The naive idea is very easy. But could you solve it in one-pass? Well, the one-pass code (taken from here ) is rewritten in C++ as follows. 1 2 3 4 5 6 7 8 9 10 11 12 13 class Solution { public : int shortestDistance ( vector string words , string word1 , string word2 ) { int n = words . size (), idx1 = - 1 , idx2 = - 1 , dist = INT_MAX ; for ( int i = 0 ; i n ; i ++ ) { if ( words [ i ] == word1 ) idx1 = i ; else if ( words [ i ] == word2 ) idx2 = i ; if ( idx1 != - 1 idx2 != - 1 ) dist = min ( dist , abs ( idx1 - idx2 )); } return dist ; } }; Question 2 Given a list of words and two words word1 and word2, return the shortest distance between these two words in the list. For example, Assume that words = [\"practice\", \"makes\", \"perfect\", \"coding\", \"makes\"] . Given word1 = \"coding\u201d , word2 = \"practice\u201d , return 3. Given word1 = \"makes\" , word2 = \"coding\" , return 1. Note You may assume that word1 does not equal to word2, and word1 and word2 are both in the list. Solution This is a follow up of Shortest Word Distance. The only difference is now you are given the list of words and your method will be called repeatedly many times with different parameters. How would you optimize it? The key idea is to store the indexes of each word using a hash map. Then the function shortest() is just to find the minimum difference between two sorted lists (see here for a method). 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 class WordDistance { public : WordDistance ( vector string words ) { int n = words . size (); for ( int i = 0 ; i n ; i ++ ) wordInd [ words [ i ]]. push_back ( i ); } int shortest ( string word1 , string word2 ) { vector int indexes1 = wordInd [ word1 ]; vector int indexes2 = wordInd [ word2 ]; int m = indexes1 . size (), n = indexes2 . size (); int i = 0 , j = 0 , dist = INT_MAX ; while ( i m j n ) { dist = min ( dist , abs ( indexes1 [ i ] - indexes2 [ j ])); if ( indexes1 [ i ] indexes2 [ j ]) i ++ ; else j ++ ; } return dist ; } private : unordered_map string , vector int wordInd ; }; // Your WordDistance object will be instantiated and called as such: // WordDistance wordDistance(words); // wordDistance.shortest( word1 , word2 ); // wordDistance.shortest( anotherWord1 , anotherWord2 ); Question 3 Given a list of words and two words word1 and word2, return the shortest distance between these two words in the list. word1 and word2 may be the same and they represent two individual words in the list. For example, Assume that words = [\"practice\", \"makes\", \"perfect\", \"coding\", \"makes\"] . Given word1 = \"makes\" , word2 = \"coding\" , return 1. Given word1 = \"makes\" , word2 = \"makes\" , return 3. Note: You may assume word1 and word2 are both in the list. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 //C++: 20ms class Solution { public : int shortestWordDistance ( vector string words , string word1 , string word2 ) { int n = words . size (); int p1 = - 1 , p2 = - 1 , dist = INT_MAX ; for ( int i = 0 ; i n ; ++ i ){ if ( word1 == word2 ){ if ( words [ i ] == word1 ){ if ( p1 p2 ) p2 = i ; else p1 = i ; } } else { if ( words [ i ] == word1 ) p1 = i ; if ( words [ i ] == word2 ) p2 = i ; } if ( p1 = 0 p2 = 0 ) dist = min ( dist , abs ( p1 - p2 )); } return dist ; } };","title":"Shortest Word Distance I, II, III"},{"location":"LeetCodeLocked/c1.4/#shortest-word-distance-i-ii-iii","text":"Question 1 Given a list of words and two words word1 and word2, return the shortest distance between these two words in the list. For example, Assume that words = [\"practice\", \"makes\", \"perfect\", \"coding\", \"makes\"] . Given word1 = \"coding\" , word2 = \"practice\" , return 3. Given word1 = \"makes\" , word2 = \"coding\" , return 1. Note You may assume that word1 does not equal to word2, and word1 and word2 are both in the list. Solution The naive idea is very easy. But could you solve it in one-pass? Well, the one-pass code (taken from here ) is rewritten in C++ as follows. 1 2 3 4 5 6 7 8 9 10 11 12 13 class Solution { public : int shortestDistance ( vector string words , string word1 , string word2 ) { int n = words . size (), idx1 = - 1 , idx2 = - 1 , dist = INT_MAX ; for ( int i = 0 ; i n ; i ++ ) { if ( words [ i ] == word1 ) idx1 = i ; else if ( words [ i ] == word2 ) idx2 = i ; if ( idx1 != - 1 idx2 != - 1 ) dist = min ( dist , abs ( idx1 - idx2 )); } return dist ; } }; Question 2 Given a list of words and two words word1 and word2, return the shortest distance between these two words in the list. For example, Assume that words = [\"practice\", \"makes\", \"perfect\", \"coding\", \"makes\"] . Given word1 = \"coding\u201d , word2 = \"practice\u201d , return 3. Given word1 = \"makes\" , word2 = \"coding\" , return 1. Note You may assume that word1 does not equal to word2, and word1 and word2 are both in the list. Solution This is a follow up of Shortest Word Distance. The only difference is now you are given the list of words and your method will be called repeatedly many times with different parameters. How would you optimize it? The key idea is to store the indexes of each word using a hash map. Then the function shortest() is just to find the minimum difference between two sorted lists (see here for a method). 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 class WordDistance { public : WordDistance ( vector string words ) { int n = words . size (); for ( int i = 0 ; i n ; i ++ ) wordInd [ words [ i ]]. push_back ( i ); } int shortest ( string word1 , string word2 ) { vector int indexes1 = wordInd [ word1 ]; vector int indexes2 = wordInd [ word2 ]; int m = indexes1 . size (), n = indexes2 . size (); int i = 0 , j = 0 , dist = INT_MAX ; while ( i m j n ) { dist = min ( dist , abs ( indexes1 [ i ] - indexes2 [ j ])); if ( indexes1 [ i ] indexes2 [ j ]) i ++ ; else j ++ ; } return dist ; } private : unordered_map string , vector int wordInd ; }; // Your WordDistance object will be instantiated and called as such: // WordDistance wordDistance(words); // wordDistance.shortest( word1 , word2 ); // wordDistance.shortest( anotherWord1 , anotherWord2 ); Question 3 Given a list of words and two words word1 and word2, return the shortest distance between these two words in the list. word1 and word2 may be the same and they represent two individual words in the list. For example, Assume that words = [\"practice\", \"makes\", \"perfect\", \"coding\", \"makes\"] . Given word1 = \"makes\" , word2 = \"coding\" , return 1. Given word1 = \"makes\" , word2 = \"makes\" , return 3. Note: You may assume word1 and word2 are both in the list. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 //C++: 20ms class Solution { public : int shortestWordDistance ( vector string words , string word1 , string word2 ) { int n = words . size (); int p1 = - 1 , p2 = - 1 , dist = INT_MAX ; for ( int i = 0 ; i n ; ++ i ){ if ( word1 == word2 ){ if ( words [ i ] == word1 ){ if ( p1 p2 ) p2 = i ; else p1 = i ; } } else { if ( words [ i ] == word1 ) p1 = i ; if ( words [ i ] == word2 ) p2 = i ; } if ( p1 = 0 p2 = 0 ) dist = min ( dist , abs ( p1 - p2 )); } return dist ; } };","title":"Shortest Word Distance I, II, III"},{"location":"LeetCodeLocked/c1.40/","text":"Maximum Size Subarray Sum Equals K Qustions Given an array nums and a target value k, find the maximum length of a subarray that sums to k. If there isn't one, return 0 instead. Example 1: Given nums = [1, -1, 5, -2, 3] , k = 3 , return 4. (because the subarray [1, -1, 5, -2] sums to 3 and is the longest) Example 2: Given nums = [-2, -1, 2, 1] , k = 1 , return 2. (because the subarray [-1, 2] sums to 1 and is the longest) Follow Up: Can you do it in O(n) time? Solution 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 class Solution { public : int maxSubArrayLen ( vector int nums , int k ) { if ( nums . empty ()) { return 0 ; } int maxLen = 0 ; unordered_map int , int summap ; summap [ 0 ] = - 1 ; // important int sum = 0 ; for ( int i = 0 ; i nums . size (); ++ i ) { sum += nums [ i ]; if ( summap . find ( sum ) == summap . end ()) { summap [ sum ] = i ; } if ( summap . find ( sum - k ) != summap . end ()) { maxLen = max ( maxLen , i - summap [ sum - k ]); } } return maxLen ; } };","title":"Maximum Size Subarray Sum Equals K"},{"location":"LeetCodeLocked/c1.40/#maximum-size-subarray-sum-equals-k","text":"Qustions Given an array nums and a target value k, find the maximum length of a subarray that sums to k. If there isn't one, return 0 instead. Example 1: Given nums = [1, -1, 5, -2, 3] , k = 3 , return 4. (because the subarray [1, -1, 5, -2] sums to 3 and is the longest) Example 2: Given nums = [-2, -1, 2, 1] , k = 1 , return 2. (because the subarray [-1, 2] sums to 1 and is the longest) Follow Up: Can you do it in O(n) time? Solution 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 class Solution { public : int maxSubArrayLen ( vector int nums , int k ) { if ( nums . empty ()) { return 0 ; } int maxLen = 0 ; unordered_map int , int summap ; summap [ 0 ] = - 1 ; // important int sum = 0 ; for ( int i = 0 ; i nums . size (); ++ i ) { sum += nums [ i ]; if ( summap . find ( sum ) == summap . end ()) { summap [ sum ] = i ; } if ( summap . find ( sum - k ) != summap . end ()) { maxLen = max ( maxLen , i - summap [ sum - k ]); } } return maxLen ; } };","title":"Maximum Size Subarray Sum Equals K"},{"location":"LeetCodeLocked/c1.41/","text":"Largest BST Subtree Questions Given a binary tree, find the largest subtree which is a Binary Search Tree (BST), where largest means subtree with largest number of nodes in it. Note: A subtree must include all of its descendants. Here's an example: 1 2 3 4 5 10 / \\ 5 15 / \\ \\ 1 8 7 The Largest BST Subtree in this case is the highlighted one. The return value is the subtree's size, which is 3. Show Hint: You can recursively use algorithm similar to 98. Validate Binary Search Tree at each node of the tree, which will result in O(nlogn) time complexity. Follow up: Can you figure out ways to solve it with O(n) time complexity? Solutions 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 /** * Definition for a binary tree node. * struct TreeNode { * int val; * TreeNode *left; * TreeNode *right; * TreeNode(int x) : val(x), left(NULL), right(NULL) {} * }; */ struct Data { int size ; int lower ; int upper ; bool isBST ; Data () : size ( 0 ), lower ( INT_MAX ), upper ( INT_MIN ), isBST ( false ){} }; class Solution { public : int largestBSTSubtree ( TreeNode * root ) { if ( root == nullptr ) { return 0 ; } largestBSTHelper ( root ); return max ; } private : Data largestBSTHelper ( TreeNode * root ) { Data curr ; if ( root == nullptr ) { curr . isBST = true ; return curr ; } Data left = largestBSTHelper ( root . left ); Data right = largestBSTHelper ( root . right ); curr . lower = min ( root - val , min ( left - lower , right - lower )); curr . upper = min ( root - val , min ( left - upper , right - upper )); if ( left . isBST root - val left - upper right . isBST root - val right - lower ) { curr . size = left - size + right - size + 1 ; cur . isBST = true ; max = max ( max , curr . size ); } else { curr . size = - ; } return curr ; } int max = 0 ; };","title":"Largest BST Subtree"},{"location":"LeetCodeLocked/c1.41/#largest-bst-subtree","text":"Questions Given a binary tree, find the largest subtree which is a Binary Search Tree (BST), where largest means subtree with largest number of nodes in it. Note: A subtree must include all of its descendants. Here's an example: 1 2 3 4 5 10 / \\ 5 15 / \\ \\ 1 8 7 The Largest BST Subtree in this case is the highlighted one. The return value is the subtree's size, which is 3. Show Hint: You can recursively use algorithm similar to 98. Validate Binary Search Tree at each node of the tree, which will result in O(nlogn) time complexity. Follow up: Can you figure out ways to solve it with O(n) time complexity? Solutions 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 /** * Definition for a binary tree node. * struct TreeNode { * int val; * TreeNode *left; * TreeNode *right; * TreeNode(int x) : val(x), left(NULL), right(NULL) {} * }; */ struct Data { int size ; int lower ; int upper ; bool isBST ; Data () : size ( 0 ), lower ( INT_MAX ), upper ( INT_MIN ), isBST ( false ){} }; class Solution { public : int largestBSTSubtree ( TreeNode * root ) { if ( root == nullptr ) { return 0 ; } largestBSTHelper ( root ); return max ; } private : Data largestBSTHelper ( TreeNode * root ) { Data curr ; if ( root == nullptr ) { curr . isBST = true ; return curr ; } Data left = largestBSTHelper ( root . left ); Data right = largestBSTHelper ( root . right ); curr . lower = min ( root - val , min ( left - lower , right - lower )); curr . upper = min ( root - val , min ( left - upper , right - upper )); if ( left . isBST root - val left - upper right . isBST root - val right - lower ) { curr . size = left - size + right - size + 1 ; cur . isBST = true ; max = max ( max , curr . size ); } else { curr . size = - ; } return curr ; } int max = 0 ; };","title":"Largest BST Subtree"},{"location":"LeetCodeLocked/c1.42/","text":"Wiggle Sort Questions Given an unsorted array nums, reorder it in-place such that nums[0] = nums[1] = nums[2] = nums[3].... For example, given nums = [3, 5, 2, 1, 6, 4] , one possible answer is `[1, 6, 2, 5, 3, 4] . Solutions method 1: sort 1 2 3 4 5 6 7 8 9 10 11 12 class Solution { public : void wiggleSort ( vector int nums ) { sort ( nums . begin (), nums . end ()); for ( int i = 2 ; i nums . size (); i += 2 ) { int tmp = nums [ i - 1 ]; nums [ i - 1 ] = nums [ i ]; nums [ i ] = tmp ; } } }; method 2: one pass time O(N), space O(1) 1 2 3 4 5 6 7 8 9 10 11 12 class Solution { public : void wiggleSort ( vector int nums ) { for ( int i = 1 ; i nums . size (); i ++ ) { if (( i % 2 == 1 nums [ i ] nums [ i - 1 ]) || i % 2 == 0 nums [ i ] nums [ i - 1 ]) { int tmp = nums [ i - 1 ]; nums [ i - 1 ] = nums [ i ]; nums [ i ] = tmp ; } } } };","title":"Wiggle Sort"},{"location":"LeetCodeLocked/c1.42/#wiggle-sort","text":"Questions Given an unsorted array nums, reorder it in-place such that nums[0] = nums[1] = nums[2] = nums[3].... For example, given nums = [3, 5, 2, 1, 6, 4] , one possible answer is `[1, 6, 2, 5, 3, 4] . Solutions method 1: sort 1 2 3 4 5 6 7 8 9 10 11 12 class Solution { public : void wiggleSort ( vector int nums ) { sort ( nums . begin (), nums . end ()); for ( int i = 2 ; i nums . size (); i += 2 ) { int tmp = nums [ i - 1 ]; nums [ i - 1 ] = nums [ i ]; nums [ i ] = tmp ; } } }; method 2: one pass time O(N), space O(1) 1 2 3 4 5 6 7 8 9 10 11 12 class Solution { public : void wiggleSort ( vector int nums ) { for ( int i = 1 ; i nums . size (); i ++ ) { if (( i % 2 == 1 nums [ i ] nums [ i - 1 ]) || i % 2 == 0 nums [ i ] nums [ i - 1 ]) { int tmp = nums [ i - 1 ]; nums [ i - 1 ] = nums [ i ]; nums [ i ] = tmp ; } } } };","title":"Wiggle Sort"},{"location":"LeetCodeLocked/c1.43/","text":"Zigzag Iterator Questions Given two 1d vectors, implement an iterator to return their elements alternately. For example, given two 1d vectors: v1 = [1, 2] v2 = [3, 4, 5, 6] By calling next repeatedly until hasNext returns false, the order of elements returned by next should be: [1, 3, 2, 4, 5, 6] . Follow up: What if you are given k 1d vectors? How well can your code be extended to such cases? Solutions from here The idea is as follows: keep the two beginning iterators and the two end iterators of v1 and v2into two arrays of type vector ::iterator with size 2. Then we keep a variable p(initialized to be 0) to record which iterator should be used: p takes values ranging from 0 to1. Each time we call next, update p by p = (p + 1) % 2 to circulate it to point to the next vector. The code is as follows. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 class ZigzagIterator { public : ZigzagIterator ( vector int v1 , vector int v2 ) { bs [ 0 ] = v1 . begin (), bs [ 1 ] = v2 . begin (); es [ 0 ] = v1 . end (), es [ 1 ] = v2 . end (); p = 0 ; } int next () { int elem ; if ( bs [ 0 ] == es [ 0 ]) elem = * bs [ 1 ] ++ ; else if ( bs [ 1 ] == es [ 1 ]) elem = * bs [ 0 ] ++ ; else { elem = * bs [ p ] ++ ; p = ( p + 1 ) % 2 ; } return elem ; } bool hasNext () { return bs [ 0 ] != es [ 0 ] || bs [ 1 ] != es [ 1 ]; } private : int p ; vector int :: iterator bs [ 2 ], es [ 2 ]; };","title":"Zigzag Iterator"},{"location":"LeetCodeLocked/c1.43/#zigzag-iterator","text":"Questions Given two 1d vectors, implement an iterator to return their elements alternately. For example, given two 1d vectors: v1 = [1, 2] v2 = [3, 4, 5, 6] By calling next repeatedly until hasNext returns false, the order of elements returned by next should be: [1, 3, 2, 4, 5, 6] . Follow up: What if you are given k 1d vectors? How well can your code be extended to such cases? Solutions from here The idea is as follows: keep the two beginning iterators and the two end iterators of v1 and v2into two arrays of type vector ::iterator with size 2. Then we keep a variable p(initialized to be 0) to record which iterator should be used: p takes values ranging from 0 to1. Each time we call next, update p by p = (p + 1) % 2 to circulate it to point to the next vector. The code is as follows. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 class ZigzagIterator { public : ZigzagIterator ( vector int v1 , vector int v2 ) { bs [ 0 ] = v1 . begin (), bs [ 1 ] = v2 . begin (); es [ 0 ] = v1 . end (), es [ 1 ] = v2 . end (); p = 0 ; } int next () { int elem ; if ( bs [ 0 ] == es [ 0 ]) elem = * bs [ 1 ] ++ ; else if ( bs [ 1 ] == es [ 1 ]) elem = * bs [ 0 ] ++ ; else { elem = * bs [ p ] ++ ; p = ( p + 1 ) % 2 ; } return elem ; } bool hasNext () { return bs [ 0 ] != es [ 0 ] || bs [ 1 ] != es [ 1 ]; } private : int p ; vector int :: iterator bs [ 2 ], es [ 2 ]; };","title":"Zigzag Iterator"},{"location":"LeetCodeLocked/c1.5/","text":"Strobogrammatic Number I, II, III Question 1 A strobogrammatic number is a number that looks the same when rotated 180 degrees (looked at upside down). Write a function to determine if a number is strobogrammatic. The number is represented as a string. For example, the numbers \"69\", \"88\", and \"818\" are all strobogrammatic. Solution http://www.cnblogs.com/jcliBlogger/p/4708243.html The following is the C++ implementation of the suggested solution using a look-up table (implemented as an unordered_map). It takes 0 ms. But, I wonder, are there any real applications of strobogrammatic numbers? 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 class Solution { public : bool isStrobogrammatic ( string num ) { make_lut (); int n = num . length (); for ( int l = 0 , r = n - 1 ; l = r ; l ++ , r -- ) { if ( lut . find ( num [ l ]) == lut . end () || lut . find ( num [ r ]) == lut . end () || lut [ num [ l ]] != num [ r ]) { return false ; } } return true ; } private : unordered_map char , char lut ; void make_lut ( void ) { lut [ 0 ] = 0 ; lut [ 1 ] = 1 ; lut [ 6 ] = 9 ; lut [ 8 ] = 8 ; lut [ 9 ] = 6 ; } }; Question 2 A strobogrammatic number is a number that looks the same when rotated 180 degrees (looked at upside down). Find all strobogrammatic numbers that are of length = n. For example, Given n = 2 , return [\"11\",\"69\",\"88\",\"96\"] . Solution Strobogrammatic Number II give us all the strings with length n. in python . 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 class Solution { public : vector string findStrobogrammatic ( int n ) { vector string result ; if ( n 1 ) { result = { 0 , 1 , 8 }; } else { result = { }; } vector string bases = { 00 , 11 , 88 , 69 , 96 }; int m = bases . size (); while ( n 1 ) { n -= 2 ; vector string temp ; for ( string strobo : result ) { for ( int i = ( n 2 ? 1 : 0 ); i m ; i ++ ) { temp . push_back ( bases [ i ]. substr ( 0 , 1 ) + strobo + bases [ i ]. substr ( 1 )); } } swap ( temp , result ); } return result ; } }; 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 class Solution { vector string processString ( const vector string vec , int n , int total ) { vector string ret ; for ( string s : vec ) { if ( n != total ) { ret . push_back ( 0 + s + 0 ); } ret . push_back ( 1 + s + 1 ); ret . push_back ( 8 + s + 8 ); ret . push_back ( 6 + s + 9 ); ret . push_back ( 9 + s + 6 ); } return ret ; } vector string findImp ( int n , int total ) { if ( n == 0 ) { return vector string { }; } if ( n == 1 ) { return vector string { 1 , 8 , 0 }; } return processString ( findImp ( n - 2 , total ), n , total ); } public : vector string findStrobogrammatic ( int n ) { return findImp ( n , n ); } }; 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 class Solution { public : vector string findStrobogrammatic ( int n ) { vector string strobos ; if ( n 1 ) strobos = { 0 , 1 , 8 }; else strobos = { }; vector string bases = { 00 , 11 , 88 , 69 , 96 }; int m = bases . size (); while ( n 1 ) { n -= 2 ; vector string temp ; for ( string strobo : strobos ) for ( int i = ( n 2 ? 1 : 0 ); i m ; i ++ ) temp . push_back ( bases [ i ]. substr ( 0 , 1 ) + strobo + bases [ i ]. substr ( 1 )); swap ( temp , strobos ); } return strobos ; } }; Question 3 A strobogrammatic number is a number that looks the same when rotated 180 degrees (looked at upside down). Write a function to count the total strobogrammatic numbers that exist in the range of low = num = high. For example, Given low = \"50\" , high = \"100\" , return 3. Because 69, 88, and 96 are three strobogrammatic numbers. Note: Because the range might be a large number, the low and high numbers are represented as string. Solution Strobogrammatic Number II give us all the strings with length n, then we can call it to get strings with length between low.length() and high.length(), and remove the strings that less than low and larger than high. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 public class Solution { public int strobogrammaticInRange ( String low , String high ) { int m = low . length (), n = high . length (); List String result = new ArrayList String (); for ( int i = m ; i = n ; i ++){ result . addAll ( findStrobogrammatic ( i )); } int i = 0 ; int count = result . size (); while ( i result . size () result . get ( i ). length ()== low . length ()){ if ( result . get ( i ). compareTo ( low ) 0 ){ count --; } i ++; } i = result . size ()- 1 ; while ( i = 0 result . get ( i ). length ()== high . length ()){ if ( result . get ( i ). compareTo ( high ) 0 ){ count --; } i --; } return count ; } public List String findStrobogrammatic ( int n ) { HashMap Character , Character map = new HashMap (); map . put ( 1 , 1 ); map . put ( 0 , 0 ); map . put ( 6 , 9 ); map . put ( 9 , 6 ); map . put ( 8 , 8 ); List String list = new ArrayList (); char [] arr = new char [ n ]; dfs ( list , arr , 0 , n , map ); Collections . sort ( list ); return list ; } public void dfs ( List String list , char [] buffer , int idx , int n , Map Character , Character map ){ if ( idx ==( n + 1 )/ 2 ){ list . add ( String . valueOf ( buffer )); return ; } for ( char key : map . keySet ()){ if ( idx == 0 n 1 key == 0 ){ continue ; } if ( idx ==( n / 2 ) ( key == 6 || key == 9 )){ continue ; } buffer [ idx ] = key ; buffer [ n - idx - 1 ] = map . get ( key ); dfs ( list , buffer , idx + 1 , n , map ); } } 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 //C++: MLE class Solution { public : int compareStr ( string s1 , string s2 ){ int n1 = s1 . size (); int n2 = s2 . size (); if ( n1 n2 ){ for ( int i = 0 ; i n2 - n1 ; ++ i ) s1 = 0 + s1 ; } else if ( n1 n2 ){ for ( int i = 0 ; i n1 - n2 ; ++ i ) s2 = 0 + s2 ; } return s1 . compare ( s2 ); } void findStrobogrammatic ( int n , int nn , vector string res ) { if ( n == 0 ) return ; else if ( n == 1 ){ res . push_back ( 0 ); res . push_back ( 1 ); res . push_back ( 8 ); } else if ( n == 2 ){ findStrobogrammatic ( 1 , nn , res ); res . push_back ( 11 ); res . push_back ( 69 ); res . push_back ( 88 ); res . push_back ( 96 ); if ( n nn ) res . push_back ( 00 ); } else { findStrobogrammatic ( n - 1 , nn , res ); vector string tmp = res ; for ( auto s : tmp ){ if ( s . size () != n - 2 ) continue ; if ( n nn ){ string s0 = 0 + s + 0 ; res . push_back ( s0 ); } string s1 = 1 + s + 1 ; res . push_back ( s1 ); string s2 = 8 + s + 8 ; res . push_back ( s2 ); string s3 = 6 + s + 9 ; res . push_back ( s3 ); string s4 = 9 + s + 6 ; res . push_back ( s4 ); } } } int strobogrammaticInRange ( string low , string high ) { int n = high . size (); // if(low== 0 high== 100000000000000 ) return 124999; vector string res ; findStrobogrammatic ( n , n , res ); int cnt = 0 ; for ( auto s : res ){ if ( s . size () 1 s [ 0 ] == 0 ) continue ; if ( compareStr ( s , low ) = 0 compareStr ( s , high ) = 0 ){ cnt ++ ; } } return cnt ; } };","title":"Strobogrammatic Number I, II, III"},{"location":"LeetCodeLocked/c1.5/#strobogrammatic-number-i-ii-iii","text":"Question 1 A strobogrammatic number is a number that looks the same when rotated 180 degrees (looked at upside down). Write a function to determine if a number is strobogrammatic. The number is represented as a string. For example, the numbers \"69\", \"88\", and \"818\" are all strobogrammatic. Solution http://www.cnblogs.com/jcliBlogger/p/4708243.html The following is the C++ implementation of the suggested solution using a look-up table (implemented as an unordered_map). It takes 0 ms. But, I wonder, are there any real applications of strobogrammatic numbers? 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 class Solution { public : bool isStrobogrammatic ( string num ) { make_lut (); int n = num . length (); for ( int l = 0 , r = n - 1 ; l = r ; l ++ , r -- ) { if ( lut . find ( num [ l ]) == lut . end () || lut . find ( num [ r ]) == lut . end () || lut [ num [ l ]] != num [ r ]) { return false ; } } return true ; } private : unordered_map char , char lut ; void make_lut ( void ) { lut [ 0 ] = 0 ; lut [ 1 ] = 1 ; lut [ 6 ] = 9 ; lut [ 8 ] = 8 ; lut [ 9 ] = 6 ; } }; Question 2 A strobogrammatic number is a number that looks the same when rotated 180 degrees (looked at upside down). Find all strobogrammatic numbers that are of length = n. For example, Given n = 2 , return [\"11\",\"69\",\"88\",\"96\"] . Solution Strobogrammatic Number II give us all the strings with length n. in python . 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 class Solution { public : vector string findStrobogrammatic ( int n ) { vector string result ; if ( n 1 ) { result = { 0 , 1 , 8 }; } else { result = { }; } vector string bases = { 00 , 11 , 88 , 69 , 96 }; int m = bases . size (); while ( n 1 ) { n -= 2 ; vector string temp ; for ( string strobo : result ) { for ( int i = ( n 2 ? 1 : 0 ); i m ; i ++ ) { temp . push_back ( bases [ i ]. substr ( 0 , 1 ) + strobo + bases [ i ]. substr ( 1 )); } } swap ( temp , result ); } return result ; } }; 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 class Solution { vector string processString ( const vector string vec , int n , int total ) { vector string ret ; for ( string s : vec ) { if ( n != total ) { ret . push_back ( 0 + s + 0 ); } ret . push_back ( 1 + s + 1 ); ret . push_back ( 8 + s + 8 ); ret . push_back ( 6 + s + 9 ); ret . push_back ( 9 + s + 6 ); } return ret ; } vector string findImp ( int n , int total ) { if ( n == 0 ) { return vector string { }; } if ( n == 1 ) { return vector string { 1 , 8 , 0 }; } return processString ( findImp ( n - 2 , total ), n , total ); } public : vector string findStrobogrammatic ( int n ) { return findImp ( n , n ); } }; 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 class Solution { public : vector string findStrobogrammatic ( int n ) { vector string strobos ; if ( n 1 ) strobos = { 0 , 1 , 8 }; else strobos = { }; vector string bases = { 00 , 11 , 88 , 69 , 96 }; int m = bases . size (); while ( n 1 ) { n -= 2 ; vector string temp ; for ( string strobo : strobos ) for ( int i = ( n 2 ? 1 : 0 ); i m ; i ++ ) temp . push_back ( bases [ i ]. substr ( 0 , 1 ) + strobo + bases [ i ]. substr ( 1 )); swap ( temp , strobos ); } return strobos ; } }; Question 3 A strobogrammatic number is a number that looks the same when rotated 180 degrees (looked at upside down). Write a function to count the total strobogrammatic numbers that exist in the range of low = num = high. For example, Given low = \"50\" , high = \"100\" , return 3. Because 69, 88, and 96 are three strobogrammatic numbers. Note: Because the range might be a large number, the low and high numbers are represented as string. Solution Strobogrammatic Number II give us all the strings with length n, then we can call it to get strings with length between low.length() and high.length(), and remove the strings that less than low and larger than high. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 public class Solution { public int strobogrammaticInRange ( String low , String high ) { int m = low . length (), n = high . length (); List String result = new ArrayList String (); for ( int i = m ; i = n ; i ++){ result . addAll ( findStrobogrammatic ( i )); } int i = 0 ; int count = result . size (); while ( i result . size () result . get ( i ). length ()== low . length ()){ if ( result . get ( i ). compareTo ( low ) 0 ){ count --; } i ++; } i = result . size ()- 1 ; while ( i = 0 result . get ( i ). length ()== high . length ()){ if ( result . get ( i ). compareTo ( high ) 0 ){ count --; } i --; } return count ; } public List String findStrobogrammatic ( int n ) { HashMap Character , Character map = new HashMap (); map . put ( 1 , 1 ); map . put ( 0 , 0 ); map . put ( 6 , 9 ); map . put ( 9 , 6 ); map . put ( 8 , 8 ); List String list = new ArrayList (); char [] arr = new char [ n ]; dfs ( list , arr , 0 , n , map ); Collections . sort ( list ); return list ; } public void dfs ( List String list , char [] buffer , int idx , int n , Map Character , Character map ){ if ( idx ==( n + 1 )/ 2 ){ list . add ( String . valueOf ( buffer )); return ; } for ( char key : map . keySet ()){ if ( idx == 0 n 1 key == 0 ){ continue ; } if ( idx ==( n / 2 ) ( key == 6 || key == 9 )){ continue ; } buffer [ idx ] = key ; buffer [ n - idx - 1 ] = map . get ( key ); dfs ( list , buffer , idx + 1 , n , map ); } } 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 //C++: MLE class Solution { public : int compareStr ( string s1 , string s2 ){ int n1 = s1 . size (); int n2 = s2 . size (); if ( n1 n2 ){ for ( int i = 0 ; i n2 - n1 ; ++ i ) s1 = 0 + s1 ; } else if ( n1 n2 ){ for ( int i = 0 ; i n1 - n2 ; ++ i ) s2 = 0 + s2 ; } return s1 . compare ( s2 ); } void findStrobogrammatic ( int n , int nn , vector string res ) { if ( n == 0 ) return ; else if ( n == 1 ){ res . push_back ( 0 ); res . push_back ( 1 ); res . push_back ( 8 ); } else if ( n == 2 ){ findStrobogrammatic ( 1 , nn , res ); res . push_back ( 11 ); res . push_back ( 69 ); res . push_back ( 88 ); res . push_back ( 96 ); if ( n nn ) res . push_back ( 00 ); } else { findStrobogrammatic ( n - 1 , nn , res ); vector string tmp = res ; for ( auto s : tmp ){ if ( s . size () != n - 2 ) continue ; if ( n nn ){ string s0 = 0 + s + 0 ; res . push_back ( s0 ); } string s1 = 1 + s + 1 ; res . push_back ( s1 ); string s2 = 8 + s + 8 ; res . push_back ( s2 ); string s3 = 6 + s + 9 ; res . push_back ( s3 ); string s4 = 9 + s + 6 ; res . push_back ( s4 ); } } } int strobogrammaticInRange ( string low , string high ) { int n = high . size (); // if(low== 0 high== 100000000000000 ) return 124999; vector string res ; findStrobogrammatic ( n , n , res ); int cnt = 0 ; for ( auto s : res ){ if ( s . size () 1 s [ 0 ] == 0 ) continue ; if ( compareStr ( s , low ) = 0 compareStr ( s , high ) = 0 ){ cnt ++ ; } } return cnt ; } };","title":"Strobogrammatic Number I, II, III"},{"location":"LeetCodeLocked/c1.6/","text":"Meeting Rooms I, II Question 1 Given an array of meeting time intervals consisting of start and end times [[s1,e1],[s2,e2],...] (si ei) , determine if a person could attend all meetings. For example, Given [[0, 30],[5, 10],[15, 20]] , return false. Solution The idea is pretty simple: first we sort the intervals in the ascending order of start; then we check for the overlapping of each pair of neighboring intervals. If they do, then return false; after we finish all the checks and have not returned false, just return true. Sorting takes O(nlogn) time and the overlapping checks take O(n) time, so this idea is O(nlogn) time in total. The code is as follows. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 /** * Definition for an interval. * struct Interval { * int start; * int end; * Interval() : start(0), end(0) {} * Interval(int s, int e) : start(s), end(e) {} * }; */ class Solution { public : bool canAttendMeetings ( vector Interval intervals ) { // Time: O(NlogN) sort ( intervals . begin (), intervals . end (), compare ); int n = intervals . size (); for ( int i = 0 ; i n - 1 ; i ++ ) if ( overlap ( intervals [ i ], intervals [ i + 1 ])) return false ; return true ; } private : static bool compare ( Interval interval1 , Interval interval2 ) { return interval1 . start interval2 . start ; } bool overlap ( Interval interval1 , Interval interval2 ) { return interval1 . end interval2 . start ; } }; Question 2 Given an array of meeting time intervals consisting of start and end times [[s1,e1],[s2,e2],...] (si ei) , find the minimum number of conference rooms required. For example, Given [[0, 30],[5, 10],[15, 20]] , return 2 . Solution The idea is to group those non-overlapping meetings in the same room and then count how many rooms we need. You may refer to this link . 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 bool myComp ( const Interval a , const Interval b ){ return ( a . start b . start ); } class Solution { public : int minMeetingRooms ( vector Interval intervals ) { int rooms = 0 ; priority_queue int pq ; //prioritize earlier ending time sort ( intervals . begin (), intervals . end (), myComp ); for ( int i = 0 ; i intervals . size (); ++ i ){ while ( ! pq . empty () - pq . top () intervals [ i ]. start ) pq . pop (); pq . push ( - intervals [ i ]. end ); rooms = max ( rooms , ( int ) pq . size ()); } return rooms ; } }; another solution: for each group of non-overlapping intervals, we just need to store the last added one instead of the full list. So we could use a vector Interval instead of vector vector Interval in C++. The code is now as follows. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 class Solution { public : int minMeetingRooms ( vector Interval intervals ) { sort ( intervals . begin (), intervals . end (), compare ); vector Interval rooms ; int n = intervals . size (); for ( int i = 0 ; i n ; i ++ ) { int idx = findNonOverlapping ( rooms , intervals [ i ]); if ( rooms . empty () || idx == - 1 ) rooms . push_back ( intervals [ i ]); else rooms [ idx ] = intervals [ i ]; } return ( int ) rooms . size (); } private : static bool compare ( Interval interval1 , Interval interval2 ) { return interval1 . start interval2 . start ; } int findNonOverlapping ( vector Interval rooms , Interval interval ) { int n = rooms . size (); for ( int i = 0 ; i n ; i ++ ) if ( interval . start = rooms [ i ]. end ) return i ; return - 1 ; } }; another smart solution: here 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 class Solution { public : int minMeetingRooms ( vector Interval intervals ){ // Time O(NlogN) map int , int mp ; // key:time, val:+1 start, -1 end for ( int i = 0 ; i intervals . size (); ++ i ) { mp [ intervals [ i ]. start ] ++ ; mp [ intervals [ i ]. end ] -- ; } int cnt = 0 ; maxcnt = 0 ; for ( auto it = mp . begin (); it != mp . end (); ++ it ) { cnt += it - second ; maxcnt = max ( maxcnt , cnt ); } return maxcnt ; } };","title":"Meeting Rooms I, II"},{"location":"LeetCodeLocked/c1.6/#meeting-rooms-i-ii","text":"Question 1 Given an array of meeting time intervals consisting of start and end times [[s1,e1],[s2,e2],...] (si ei) , determine if a person could attend all meetings. For example, Given [[0, 30],[5, 10],[15, 20]] , return false. Solution The idea is pretty simple: first we sort the intervals in the ascending order of start; then we check for the overlapping of each pair of neighboring intervals. If they do, then return false; after we finish all the checks and have not returned false, just return true. Sorting takes O(nlogn) time and the overlapping checks take O(n) time, so this idea is O(nlogn) time in total. The code is as follows. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 /** * Definition for an interval. * struct Interval { * int start; * int end; * Interval() : start(0), end(0) {} * Interval(int s, int e) : start(s), end(e) {} * }; */ class Solution { public : bool canAttendMeetings ( vector Interval intervals ) { // Time: O(NlogN) sort ( intervals . begin (), intervals . end (), compare ); int n = intervals . size (); for ( int i = 0 ; i n - 1 ; i ++ ) if ( overlap ( intervals [ i ], intervals [ i + 1 ])) return false ; return true ; } private : static bool compare ( Interval interval1 , Interval interval2 ) { return interval1 . start interval2 . start ; } bool overlap ( Interval interval1 , Interval interval2 ) { return interval1 . end interval2 . start ; } }; Question 2 Given an array of meeting time intervals consisting of start and end times [[s1,e1],[s2,e2],...] (si ei) , find the minimum number of conference rooms required. For example, Given [[0, 30],[5, 10],[15, 20]] , return 2 . Solution The idea is to group those non-overlapping meetings in the same room and then count how many rooms we need. You may refer to this link . 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 bool myComp ( const Interval a , const Interval b ){ return ( a . start b . start ); } class Solution { public : int minMeetingRooms ( vector Interval intervals ) { int rooms = 0 ; priority_queue int pq ; //prioritize earlier ending time sort ( intervals . begin (), intervals . end (), myComp ); for ( int i = 0 ; i intervals . size (); ++ i ){ while ( ! pq . empty () - pq . top () intervals [ i ]. start ) pq . pop (); pq . push ( - intervals [ i ]. end ); rooms = max ( rooms , ( int ) pq . size ()); } return rooms ; } }; another solution: for each group of non-overlapping intervals, we just need to store the last added one instead of the full list. So we could use a vector Interval instead of vector vector Interval in C++. The code is now as follows. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 class Solution { public : int minMeetingRooms ( vector Interval intervals ) { sort ( intervals . begin (), intervals . end (), compare ); vector Interval rooms ; int n = intervals . size (); for ( int i = 0 ; i n ; i ++ ) { int idx = findNonOverlapping ( rooms , intervals [ i ]); if ( rooms . empty () || idx == - 1 ) rooms . push_back ( intervals [ i ]); else rooms [ idx ] = intervals [ i ]; } return ( int ) rooms . size (); } private : static bool compare ( Interval interval1 , Interval interval2 ) { return interval1 . start interval2 . start ; } int findNonOverlapping ( vector Interval rooms , Interval interval ) { int n = rooms . size (); for ( int i = 0 ; i n ; i ++ ) if ( interval . start = rooms [ i ]. end ) return i ; return - 1 ; } }; another smart solution: here 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 class Solution { public : int minMeetingRooms ( vector Interval intervals ){ // Time O(NlogN) map int , int mp ; // key:time, val:+1 start, -1 end for ( int i = 0 ; i intervals . size (); ++ i ) { mp [ intervals [ i ]. start ] ++ ; mp [ intervals [ i ]. end ] -- ; } int cnt = 0 ; maxcnt = 0 ; for ( auto it = mp . begin (); it != mp . end (); ++ it ) { cnt += it - second ; maxcnt = max ( maxcnt , cnt ); } return maxcnt ; } };","title":"Meeting Rooms I, II"},{"location":"LeetCodeLocked/c1.7/","text":"Longest Substring with At Most Two Distinct Characters Question Given a string S, find the length of the longest substring T that contains at most two distinct characters. For example, Given S = \u201ceceba\u201d , T is `\"ece\" which its length is 3. Solution First, we could simplify the problem by assuming that S contains two or more distinct characters, which means T must contain exactly two distinct characters. The brute force approach is O(n3) where n is the length of S. We can form every possible substring, and for each substring insert all characters into a Set which the Set\u2019s size indicating the number of distinct characters. This could be easily improved to O(n2) by reusing the same Set when adding a character to form a new substring. The trick is to maintain a sliding window that always satisfies the invariant where there are always at most two distinct characters in it. When we add a new character that breaks this invariant, how can we move the begin pointer to satisfy the invariant? Using the above example, our first window is the substring \u201cabba\u201d. When we add the character \u2018c\u2019 into the sliding window, it breaks the invariant. Therefore, we have to readjust the window to satisfy the invariant again. The question is which starting point to choose so the invariant is satisfied. Let\u2019s look at another example where S = \u201cabaac\u201d. We found our first window \u201cabaa\u201d. When we add \u2018c\u2019 to the window, the next sliding window should be \u201caac\u201d. This method iterates n times and therefore its runtime complexity is O(n). We use three pointers: i, j, and k. 1 2 3 4 5 6 7 8 9 10 public int lengthOfLongestSubstringTwoDistinct ( String s ) { int i = 0 , j = - 1 , maxLen = 0 ; for ( int k = 1 ; k s . length (); k ++) { if ( s . charAt ( k ) == s . charAt ( k - 1 )) continue ; if ( j = 0 s . charAt ( j ) != s . charAt ( k )) { maxLen = Math . max ( k - i , maxLen ); i = j + 1 ; } j = k - 1 ; } return Math . max ( s . length () - i , maxLen ); } 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 #include iostream #include cmath using namespace std ; class Solution { public : int lengthOfLongestSubstringTwoDistinct ( string s ) { int i = 0 , j = - 1 , maxLen = 0 ; for ( int k = 1 ; k s . length (); k ++ ) { if ( s [ k ] == s [ k - 1 ]) continue ; if ( j = 0 s [ j ] != s [ k ]) { maxLen = max ( k - i , maxLen ); i = j + 1 ; } j = k - 1 ; } return max (( int )( s . length () - i ), maxLen ); } }; int main () { Solution sol ; string s ( eceba ); cout sol . lengthOfLongestSubstringTwoDistinct ( s ) endl ; return 0 ; } Further Thoughts Although the above method works fine, it could not be easily generalized to the case where T contains at most k distinct characters. The key is when we adjust the sliding window to satisfy the invariant, we need a counter of the number of times each character appears in the substring. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 public int lengthOfLongestSubstringTwoDistinct ( String s ) { int [] count = new int [ 256 ]; int i = 0 , numDistinct = 0 , maxLen = 0 ; for ( int j = 0 ; j s . length (); j ++) { if ( count [ s . charAt ( j )] == 0 ) numDistinct ++; count [ s . charAt ( j )]++; while ( numDistinct 2 ) { count [ s . charAt ( i )]--; if ( count [ s . charAt ( i )] == 0 ) numDistinct --; i ++; } maxLen = Math . max ( j - i + 1 , maxLen ); } return maxLen ; }","title":"Longest Substring with At Most Two Distinct Characters"},{"location":"LeetCodeLocked/c1.7/#longest-substring-with-at-most-two-distinct-characters","text":"Question Given a string S, find the length of the longest substring T that contains at most two distinct characters. For example, Given S = \u201ceceba\u201d , T is `\"ece\" which its length is 3. Solution First, we could simplify the problem by assuming that S contains two or more distinct characters, which means T must contain exactly two distinct characters. The brute force approach is O(n3) where n is the length of S. We can form every possible substring, and for each substring insert all characters into a Set which the Set\u2019s size indicating the number of distinct characters. This could be easily improved to O(n2) by reusing the same Set when adding a character to form a new substring. The trick is to maintain a sliding window that always satisfies the invariant where there are always at most two distinct characters in it. When we add a new character that breaks this invariant, how can we move the begin pointer to satisfy the invariant? Using the above example, our first window is the substring \u201cabba\u201d. When we add the character \u2018c\u2019 into the sliding window, it breaks the invariant. Therefore, we have to readjust the window to satisfy the invariant again. The question is which starting point to choose so the invariant is satisfied. Let\u2019s look at another example where S = \u201cabaac\u201d. We found our first window \u201cabaa\u201d. When we add \u2018c\u2019 to the window, the next sliding window should be \u201caac\u201d. This method iterates n times and therefore its runtime complexity is O(n). We use three pointers: i, j, and k. 1 2 3 4 5 6 7 8 9 10 public int lengthOfLongestSubstringTwoDistinct ( String s ) { int i = 0 , j = - 1 , maxLen = 0 ; for ( int k = 1 ; k s . length (); k ++) { if ( s . charAt ( k ) == s . charAt ( k - 1 )) continue ; if ( j = 0 s . charAt ( j ) != s . charAt ( k )) { maxLen = Math . max ( k - i , maxLen ); i = j + 1 ; } j = k - 1 ; } return Math . max ( s . length () - i , maxLen ); } 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 #include iostream #include cmath using namespace std ; class Solution { public : int lengthOfLongestSubstringTwoDistinct ( string s ) { int i = 0 , j = - 1 , maxLen = 0 ; for ( int k = 1 ; k s . length (); k ++ ) { if ( s [ k ] == s [ k - 1 ]) continue ; if ( j = 0 s [ j ] != s [ k ]) { maxLen = max ( k - i , maxLen ); i = j + 1 ; } j = k - 1 ; } return max (( int )( s . length () - i ), maxLen ); } }; int main () { Solution sol ; string s ( eceba ); cout sol . lengthOfLongestSubstringTwoDistinct ( s ) endl ; return 0 ; } Further Thoughts Although the above method works fine, it could not be easily generalized to the case where T contains at most k distinct characters. The key is when we adjust the sliding window to satisfy the invariant, we need a counter of the number of times each character appears in the substring. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 public int lengthOfLongestSubstringTwoDistinct ( String s ) { int [] count = new int [ 256 ]; int i = 0 , numDistinct = 0 , maxLen = 0 ; for ( int j = 0 ; j s . length (); j ++) { if ( count [ s . charAt ( j )] == 0 ) numDistinct ++; count [ s . charAt ( j )]++; while ( numDistinct 2 ) { count [ s . charAt ( i )]--; if ( count [ s . charAt ( i )] == 0 ) numDistinct --; i ++; } maxLen = Math . max ( j - i + 1 , maxLen ); } return maxLen ; }","title":"Longest Substring with At Most Two Distinct Characters"},{"location":"LeetCodeLocked/c1.8/","text":"Missing Ranges Question Given a sorted integer array where the range of elements are [0, 99] inclusive, return its missing ranges. For example, given [0, 1, 3, 50, 75], return [\u201c2\u201d, \u201c4- 49\u201d, \u201c51- 74\u201d, \u201c76- 99\u201d] Example Questions Candidate Might Ask: Q: What if the given array is empty? A: Then you should return [\u201c0- 99\u201d] as those ranges are missing. Q: What if the given array contains all elements from the ranges? A: Return an empty list, which means no range is missing. Solution Compare the gap between two neighbor elements and output its range, simple as that right? This seems deceptively easy, except there are multiple edge cases to consider, such as the first and last element, which does not have previous and next element respectively. Also, what happens when the given array is empty? We should output the range \u201c0- 99\u201d. As it turns out, if we could add two \u201cartificial\u201d elements, \u20131 before the first element and 100 after the last element, we could avoid all the above pesky cases. Further Thoughts i. List out test cases. ii. You should be able to extend the above cases not only for the range [0,99], but any arbitrary range [start, end]. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 public List String findMissingRanges ( int [] vals , int start , int end ) { List String ranges = new ArrayList (); int prev = start - 1 ; for ( int i = 0 ; i = vals . length ; i ++) { int curr = ( i == vals . length ) ? end + 1 : vals [ i ]; if ( curr - prev = 2 ) { ranges . add ( getRange ( prev + 1 , curr - 1 )); } prev = curr ; } return ranges ; } private String getRange ( int from , int to ) { return ( from == to ) ? String . valueOf ( from ) : from + - + to ; } 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 #include iostream #include string #include vector #include queue #include algorithm using namespace std ; vector string missingRange ( vector int a , int start , int end ){ vector string res ; int prev = start - 1 ; for ( int i = 0 ; i = a . size (); i ++ ) { int curr = ( i == a . size ()) ? end + 1 : a [ i ]; if ( curr - prev = 2 ) { if ( prev + 1 == curr - 1 ) res . push_back ( to_string ( prev + 1 )); else res . push_back ( to_string ( prev + 1 ) + - + to_string ( curr - 1 )); } prev = curr ; } return res ; } void display ( vector string ret ) { for ( int i = 0 ; i ret . size (); i ++ ) { cout ret [ i ] ; } cout endl ; } int main () { vector int a = { 1 }; vector string ret = missingRange ( a , 0 , 99 ); display ( ret ); vector int b = { 6 }; //ret.clear() ret = missingRange ( b , 0 , 99 ); display ( ret ); vector int d = { 0 , 1 , 3 , 50 , 75 }; //expect: [ 2 , 4- 49 , 51- 74 , 76- 99 ] ret = missingRange ( d , 0 , 99 ); display ( ret ); //cout double(nums[0] + nums[nums.size()-1])/2.0 endl; return 0 ; }","title":"Missing Ranges"},{"location":"LeetCodeLocked/c1.8/#missing-ranges","text":"Question Given a sorted integer array where the range of elements are [0, 99] inclusive, return its missing ranges. For example, given [0, 1, 3, 50, 75], return [\u201c2\u201d, \u201c4- 49\u201d, \u201c51- 74\u201d, \u201c76- 99\u201d] Example Questions Candidate Might Ask: Q: What if the given array is empty? A: Then you should return [\u201c0- 99\u201d] as those ranges are missing. Q: What if the given array contains all elements from the ranges? A: Return an empty list, which means no range is missing. Solution Compare the gap between two neighbor elements and output its range, simple as that right? This seems deceptively easy, except there are multiple edge cases to consider, such as the first and last element, which does not have previous and next element respectively. Also, what happens when the given array is empty? We should output the range \u201c0- 99\u201d. As it turns out, if we could add two \u201cartificial\u201d elements, \u20131 before the first element and 100 after the last element, we could avoid all the above pesky cases. Further Thoughts i. List out test cases. ii. You should be able to extend the above cases not only for the range [0,99], but any arbitrary range [start, end]. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 public List String findMissingRanges ( int [] vals , int start , int end ) { List String ranges = new ArrayList (); int prev = start - 1 ; for ( int i = 0 ; i = vals . length ; i ++) { int curr = ( i == vals . length ) ? end + 1 : vals [ i ]; if ( curr - prev = 2 ) { ranges . add ( getRange ( prev + 1 , curr - 1 )); } prev = curr ; } return ranges ; } private String getRange ( int from , int to ) { return ( from == to ) ? String . valueOf ( from ) : from + - + to ; } 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 #include iostream #include string #include vector #include queue #include algorithm using namespace std ; vector string missingRange ( vector int a , int start , int end ){ vector string res ; int prev = start - 1 ; for ( int i = 0 ; i = a . size (); i ++ ) { int curr = ( i == a . size ()) ? end + 1 : a [ i ]; if ( curr - prev = 2 ) { if ( prev + 1 == curr - 1 ) res . push_back ( to_string ( prev + 1 )); else res . push_back ( to_string ( prev + 1 ) + - + to_string ( curr - 1 )); } prev = curr ; } return res ; } void display ( vector string ret ) { for ( int i = 0 ; i ret . size (); i ++ ) { cout ret [ i ] ; } cout endl ; } int main () { vector int a = { 1 }; vector string ret = missingRange ( a , 0 , 99 ); display ( ret ); vector int b = { 6 }; //ret.clear() ret = missingRange ( b , 0 , 99 ); display ( ret ); vector int d = { 0 , 1 , 3 , 50 , 75 }; //expect: [ 2 , 4- 49 , 51- 74 , 76- 99 ] ret = missingRange ( d , 0 , 99 ); display ( ret ); //cout double(nums[0] + nums[nums.size()-1])/2.0 endl; return 0 ; }","title":"Missing Ranges"},{"location":"LeetCodeLocked/c1.9/","text":"One Edit Distance Question: Given two strings S and T, determine if they are both one edit distance apart. Hint: 1. If | n \u2013 m |`` is greater than 1, we know immediately both are not one-edit distance apart. 2. It might help if you consider these cases separately, m == n and m =\u0338 n . 3. Assume that m is always \u2264 n, which greatly simplifies the conditional statements. If m n , we could just simply swap S and T. 4. If m == n , it becomes finding if there is exactly one modified operation. If m =\u0338 n` you do not have to consider the delete operation. Just consider the insert operation in T. Solution: Let us assume m = length of S, n = length of T. Although this problem is solvable by directly applying the famous Edit distance dynamic programming algorithm with runtime complexity of O(mn) and space complexity of O(mn) (could be optimized to O(min(m,n)), it is far from desirable as there exists a simpler and more efficient one-pass algorithm. O(n) runtime, O(1) space \u2013 Simple one-pass: For the case where m is equal to n, it becomes finding if there is exactly one modified character. Now let\u2019s assume m \u2264 n. (If m n we could just swap them). Assume X represents the one-edit character. There are three one-edit distance operations that could be applied to S. i. Modify operation \u2013 Modify a character to X in S. ii. Insert operation \u2013 X was inserted before a character in S. iii. Append operation \u2013 X was appended at the end of S. 1 2 3 S = \u201cabcde\u201d T = \u201cabXde\u201d S = \u201cabcde\u201d T = \u201cabcXde\u201d S = \u201cabcde\u201d T = \u201cabcdeX\u201d We make a first pass over S and T concurrently and stop at the first non-matching character between S and T. 1. If S matches all characters in T, then check if there is an extra character at the end of T. (Modify operation) 2. If | n \u2013 m | == 1, that means we must skip this non-matching character only in T and make sure the remaining characters between S and T are exactly matching. (Insert operation) 3. If | n \u2013 m | == 0, then we skip both non-matching characters in S and T and make sure the remaining characters between S and T are exactly matching. (Append operation) 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 public boolean isOneEditDistance ( String s , String t ) { int m = s . length (), n = t . length (); if ( m n ) { return isOneEditDistance ( t , s ); } if ( n - m 1 ) { return false ; } int i = 0 , shift = n - m ; while ( i m s . charAt ( i ) == t . charAt ( i )) i ++; if ( i == m ) return shift 0 ; if ( shift == 0 ) i ++; while ( i m s . charAt ( i ) == t . charAt ( i + shift )) i ++; return i == m ; }","title":"One Edit Distance"},{"location":"LeetCodeLocked/c1.9/#one-edit-distance","text":"Question: Given two strings S and T, determine if they are both one edit distance apart. Hint: 1. If | n \u2013 m |`` is greater than 1, we know immediately both are not one-edit distance apart. 2. It might help if you consider these cases separately, m == n and m =\u0338 n . 3. Assume that m is always \u2264 n, which greatly simplifies the conditional statements. If m n , we could just simply swap S and T. 4. If m == n , it becomes finding if there is exactly one modified operation. If m =\u0338 n` you do not have to consider the delete operation. Just consider the insert operation in T. Solution: Let us assume m = length of S, n = length of T. Although this problem is solvable by directly applying the famous Edit distance dynamic programming algorithm with runtime complexity of O(mn) and space complexity of O(mn) (could be optimized to O(min(m,n)), it is far from desirable as there exists a simpler and more efficient one-pass algorithm. O(n) runtime, O(1) space \u2013 Simple one-pass: For the case where m is equal to n, it becomes finding if there is exactly one modified character. Now let\u2019s assume m \u2264 n. (If m n we could just swap them). Assume X represents the one-edit character. There are three one-edit distance operations that could be applied to S. i. Modify operation \u2013 Modify a character to X in S. ii. Insert operation \u2013 X was inserted before a character in S. iii. Append operation \u2013 X was appended at the end of S. 1 2 3 S = \u201cabcde\u201d T = \u201cabXde\u201d S = \u201cabcde\u201d T = \u201cabcXde\u201d S = \u201cabcde\u201d T = \u201cabcdeX\u201d We make a first pass over S and T concurrently and stop at the first non-matching character between S and T. 1. If S matches all characters in T, then check if there is an extra character at the end of T. (Modify operation) 2. If | n \u2013 m | == 1, that means we must skip this non-matching character only in T and make sure the remaining characters between S and T are exactly matching. (Insert operation) 3. If | n \u2013 m | == 0, then we skip both non-matching characters in S and T and make sure the remaining characters between S and T are exactly matching. (Append operation) 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 public boolean isOneEditDistance ( String s , String t ) { int m = s . length (), n = t . length (); if ( m n ) { return isOneEditDistance ( t , s ); } if ( n - m 1 ) { return false ; } int i = 0 , shift = n - m ; while ( i m s . charAt ( i ) == t . charAt ( i )) i ++; if ( i == m ) return shift 0 ; if ( shift == 0 ) i ++; while ( i m s . charAt ( i ) == t . charAt ( i + shift )) i ++; return i == m ; }","title":"One Edit Distance"},{"location":"LeetCodeLocked/c1/","text":"Reverse Words in a String II Question Given an input string, reverse the string word by word. A word is defined as a sequence of non-space characters. The input string does not contain leading or trailing spaces and the words are always separated by a single space. For example, Given s = \"the sky is blue\", return \"blue is sky the\". Could you do it in-place without allocating extra space? Idea Reverse twice, both in place. Time O(n) Space: O(1) 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 class Solution { public : void reverseWords ( string s ) { if ( s . size () == 0 ) return ; reverse ( s , 0 , s . size () - 1 ); while ( s . size () 0 s [ 0 ] == ) { s . erase ( 0 , 1 ); } int begin = 0 ; for ( int i = 0 ; i s . size (); ++ i ) { if ( i == s . size () || s [ i ] == ) { reverse ( s , begin , i - 1 ); while ( i s . size () - 1 s [ i + 1 ] == ) s . erase ( i , 1 ); if ( i == s . size () - 1 ) s . erase ( i , 1 ); begin = i + 1 ; } } } private : void reverse ( string s , int begin , int end ) { while ( begin end ) { char tmp = s [ begin ]; s [ begin ] = s [ end ]; s [ end ] = tmp ; } } };","title":"Reverse Words in a String II"},{"location":"LeetCodeLocked/c1/#reverse-words-in-a-string-ii","text":"Question Given an input string, reverse the string word by word. A word is defined as a sequence of non-space characters. The input string does not contain leading or trailing spaces and the words are always separated by a single space. For example, Given s = \"the sky is blue\", return \"blue is sky the\". Could you do it in-place without allocating extra space? Idea Reverse twice, both in place. Time O(n) Space: O(1) 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 class Solution { public : void reverseWords ( string s ) { if ( s . size () == 0 ) return ; reverse ( s , 0 , s . size () - 1 ); while ( s . size () 0 s [ 0 ] == ) { s . erase ( 0 , 1 ); } int begin = 0 ; for ( int i = 0 ; i s . size (); ++ i ) { if ( i == s . size () || s [ i ] == ) { reverse ( s , begin , i - 1 ); while ( i s . size () - 1 s [ i + 1 ] == ) s . erase ( i , 1 ); if ( i == s . size () - 1 ) s . erase ( i , 1 ); begin = i + 1 ; } } } private : void reverse ( string s , int begin , int end ) { while ( begin end ) { char tmp = s [ begin ]; s [ begin ] = s [ end ]; s [ end ] = tmp ; } } };","title":"Reverse Words in a String II"},{"location":"LeetcodeSolved/0001-two-sum/","text":"0001-two-sum Problem Given an array of integers, return indices of the two numbers such that they add up to a specific target. You may assume that each input would have exactly one solution, and you may not use the same element twice. Example: Given nums = [2, 7, 11, 15], target = 9, Because nums[ 0 ] + nums[ 1 ] = 2 + 7 = 9, return [ 0 , 1 ]. Solution c++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 class Solution { public : vector int twoSum ( vector int nums , int target ) { unordered_map int , int hash ; for ( int i = 0 ; i nums . size (); i ++ ){ if ( hash . find ( target - nums [ i ]) != hash . end ()){ return { hash [ target - nums [ i ]], i }; } hash [ nums [ i ]] = i ; } return {}; } }; \u200b","title":"0001-two-sum"},{"location":"LeetcodeSolved/0001-two-sum/#0001-two-sum","text":"","title":"0001-two-sum"},{"location":"LeetcodeSolved/0001-two-sum/#problem","text":"Given an array of integers, return indices of the two numbers such that they add up to a specific target. You may assume that each input would have exactly one solution, and you may not use the same element twice. Example: Given nums = [2, 7, 11, 15], target = 9, Because nums[ 0 ] + nums[ 1 ] = 2 + 7 = 9, return [ 0 , 1 ].","title":"Problem"},{"location":"LeetcodeSolved/0001-two-sum/#solution","text":"c++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 class Solution { public : vector int twoSum ( vector int nums , int target ) { unordered_map int , int hash ; for ( int i = 0 ; i nums . size (); i ++ ){ if ( hash . find ( target - nums [ i ]) != hash . end ()){ return { hash [ target - nums [ i ]], i }; } hash [ nums [ i ]] = i ; } return {}; } }; \u200b","title":"Solution"},{"location":"LeetcodeSolved/0002-add-two-numbers/","text":"0002-add-two-numbers Problem You are given two non-empty linked lists representing two non-negative integers. The digits are stored in reverse order and each of their nodes contain a single digit. Add the two numbers and return it as a linked list. You may assume the two numbers do not contain any leading zero, except the number 0 itself. Example: Input: (2 - 4 - 3) + (5 - 6 - 4) Output: 7 - 0 - 8 Explanation: 342 + 465 = 807. Solution c++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 /** * Definition for singly-linked list. * struct ListNode { * int val; * ListNode *next; * ListNode(int x) : val(x), next(NULL) {} * }; */ class Solution { public : ListNode * addTwoNumbers ( ListNode * l1 , ListNode * l2 ) { ListNode dummy ( 0 ); ListNode * curr = dummy ; ListNode * p = l1 ; ListNode * q = l2 ; int carry = 0 ; while ( p != NULL || q != NULL ){ int sum = 0 ; sum += ( p == NULL ) ? 0 : p - val ; sum += ( q == NULL ) ? 0 : q - val ; sum += carry ; carry = sum / 10 ; curr - next = new ListNode ( sum % 10 ); curr = curr - next ; if ( p ) p = p - next ; if ( q ) q = q - next ; } if ( carry ){ curr - next = new ListNode ( carry ); } return dummy . next ; } }; \u200b","title":"0002-add-two-numbers"},{"location":"LeetcodeSolved/0002-add-two-numbers/#0002-add-two-numbers","text":"","title":"0002-add-two-numbers"},{"location":"LeetcodeSolved/0002-add-two-numbers/#problem","text":"You are given two non-empty linked lists representing two non-negative integers. The digits are stored in reverse order and each of their nodes contain a single digit. Add the two numbers and return it as a linked list. You may assume the two numbers do not contain any leading zero, except the number 0 itself. Example: Input: (2 - 4 - 3) + (5 - 6 - 4) Output: 7 - 0 - 8 Explanation: 342 + 465 = 807.","title":"Problem"},{"location":"LeetcodeSolved/0002-add-two-numbers/#solution","text":"c++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 /** * Definition for singly-linked list. * struct ListNode { * int val; * ListNode *next; * ListNode(int x) : val(x), next(NULL) {} * }; */ class Solution { public : ListNode * addTwoNumbers ( ListNode * l1 , ListNode * l2 ) { ListNode dummy ( 0 ); ListNode * curr = dummy ; ListNode * p = l1 ; ListNode * q = l2 ; int carry = 0 ; while ( p != NULL || q != NULL ){ int sum = 0 ; sum += ( p == NULL ) ? 0 : p - val ; sum += ( q == NULL ) ? 0 : q - val ; sum += carry ; carry = sum / 10 ; curr - next = new ListNode ( sum % 10 ); curr = curr - next ; if ( p ) p = p - next ; if ( q ) q = q - next ; } if ( carry ){ curr - next = new ListNode ( carry ); } return dummy . next ; } }; \u200b","title":"Solution"},{"location":"LeetcodeSolved/0003-longest-substring-without-repeating-characters/","text":"0003-longest-substring-without-repeating-characters Problem Given a string, find the length of the longest substring without repeating characters. Example 1: Input: \"abcabcbb\" Output: 3 Explanation: The answer is \"abc\" , with the length of 3. Example 2: Input: \"bbbbb\" Output: 1 Explanation: T he answer is \"b\" , with the length of 1. Example 3: Input: \"pwwkew\" Output: 3 Explanation: The answer is \"wke\" , with the length of 3. Note that the answer must be a substring , \"pwke\" is a subsequence and not a substring. Solution c++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 class Solution { public : int lengthOfLongestSubstring ( string s ) { if ( s . size () == 0 ) return 0 ; if ( s . size () == 1 ) return 1 ; unordered_map char , int hash ; // Sliding window Concept int i = 0 , j = 1 ; int maxsofar = 1 ; hash [ s [ 0 ]] = 0 ; while ( j s . size ()){ if ( i == j ){ hash [ s [ j ]] = j ; j ++ ; } else if ( hash . find ( s [ j ]) == hash . end ()){ hash [ s [ j ]] = j ; j ++ ; } else { int temp = i ; i = hash [ s [ j ]] + 1 ; while ( temp i ) hash . erase ( hash . find ( s [ temp ++ ])); } if ( maxsofar j - i ) maxsofar = j - i ; } return maxsofar ; } }; \u200b","title":"0003-longest-substring-without-repeating-characters"},{"location":"LeetcodeSolved/0003-longest-substring-without-repeating-characters/#0003-longest-substring-without-repeating-characters","text":"","title":"0003-longest-substring-without-repeating-characters"},{"location":"LeetcodeSolved/0003-longest-substring-without-repeating-characters/#problem","text":"Given a string, find the length of the longest substring without repeating characters. Example 1: Input: \"abcabcbb\" Output: 3 Explanation: The answer is \"abc\" , with the length of 3. Example 2: Input: \"bbbbb\" Output: 1 Explanation: T he answer is \"b\" , with the length of 1. Example 3: Input: \"pwwkew\" Output: 3 Explanation: The answer is \"wke\" , with the length of 3. Note that the answer must be a substring , \"pwke\" is a subsequence and not a substring.","title":"Problem"},{"location":"LeetcodeSolved/0003-longest-substring-without-repeating-characters/#solution","text":"c++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 class Solution { public : int lengthOfLongestSubstring ( string s ) { if ( s . size () == 0 ) return 0 ; if ( s . size () == 1 ) return 1 ; unordered_map char , int hash ; // Sliding window Concept int i = 0 , j = 1 ; int maxsofar = 1 ; hash [ s [ 0 ]] = 0 ; while ( j s . size ()){ if ( i == j ){ hash [ s [ j ]] = j ; j ++ ; } else if ( hash . find ( s [ j ]) == hash . end ()){ hash [ s [ j ]] = j ; j ++ ; } else { int temp = i ; i = hash [ s [ j ]] + 1 ; while ( temp i ) hash . erase ( hash . find ( s [ temp ++ ])); } if ( maxsofar j - i ) maxsofar = j - i ; } return maxsofar ; } }; \u200b","title":"Solution"},{"location":"LeetcodeSolved/0015-3sum/","text":"0015-3sum Problem Given an array nums of n integers, are there elements a , b , c in nums such that a + b + c = 0? Find all unique triplets in the array which gives the sum of zero. Note: The solution set must not contain duplicate triplets. Example: Given array nums = [-1, 0, 1, 2, -1, -4], A solution set is: [ [-1, 0, 1], [-1, -1, 2] ] Solution c++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 class Solution { public : vector vector int threeSum ( vector int nums ) { vector vector int result ; if ( nums . size () = 2 ) return result ; sort ( nums . begin (), nums . end ()); if ( nums [ 0 ] 0 || nums [ nums . size () - 1 ] 0 ) return result ; int len = upper_bound ( nums . begin (), nums . end (), 0 ) - nums . begin (); for ( int i = 0 ; i len ; i ++ ){ int target = nums [ i ] *- 1 ; int front = i + 1 ; int back = nums . size () - 1 ; while ( front back ){ int sum = nums [ front ] + nums [ back ]; if ( sum target ) front ++ ; else if ( sum target ) back -- ; else if ( sum == target ){ vector int triplet ( 3 , 0 ); triplet [ 0 ] = nums [ i ]; triplet [ 1 ] = nums [ front ]; triplet [ 2 ] = nums [ back ]; result . push_back ( triplet ); while ( front back nums [ front ] == nums [ front + 1 ]) front ++ ; while ( front back nums [ back ] == nums [ back - 1 ]) back -- ; front ++ ; back -- ; } } while ( i len - 1 nums [ i ] == nums [ i + 1 ]) i ++ ; } return result ; } }; \u200b","title":"0015-3sum"},{"location":"LeetcodeSolved/0015-3sum/#0015-3sum","text":"","title":"0015-3sum"},{"location":"LeetcodeSolved/0015-3sum/#problem","text":"Given an array nums of n integers, are there elements a , b , c in nums such that a + b + c = 0? Find all unique triplets in the array which gives the sum of zero. Note: The solution set must not contain duplicate triplets. Example: Given array nums = [-1, 0, 1, 2, -1, -4], A solution set is: [ [-1, 0, 1], [-1, -1, 2] ]","title":"Problem"},{"location":"LeetcodeSolved/0015-3sum/#solution","text":"c++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 class Solution { public : vector vector int threeSum ( vector int nums ) { vector vector int result ; if ( nums . size () = 2 ) return result ; sort ( nums . begin (), nums . end ()); if ( nums [ 0 ] 0 || nums [ nums . size () - 1 ] 0 ) return result ; int len = upper_bound ( nums . begin (), nums . end (), 0 ) - nums . begin (); for ( int i = 0 ; i len ; i ++ ){ int target = nums [ i ] *- 1 ; int front = i + 1 ; int back = nums . size () - 1 ; while ( front back ){ int sum = nums [ front ] + nums [ back ]; if ( sum target ) front ++ ; else if ( sum target ) back -- ; else if ( sum == target ){ vector int triplet ( 3 , 0 ); triplet [ 0 ] = nums [ i ]; triplet [ 1 ] = nums [ front ]; triplet [ 2 ] = nums [ back ]; result . push_back ( triplet ); while ( front back nums [ front ] == nums [ front + 1 ]) front ++ ; while ( front back nums [ back ] == nums [ back - 1 ]) back -- ; front ++ ; back -- ; } } while ( i len - 1 nums [ i ] == nums [ i + 1 ]) i ++ ; } return result ; } }; \u200b","title":"Solution"},{"location":"LeetcodeSolved/0017-letter-combinations-of-a-phone-number/","text":"0017-letter-combinations-of-a-phone-number Problem Given a string containing digits from 2-9 inclusive, return all possible letter combinations that the number could represent. A mapping of digit to letters (just like on the telephone buttons) is given below. Note that 1 does not map to any letters. Example: Input: \"23\" Output: [\"ad\", \"ae\", \"af\", \"bd\", \"be\", \"bf\", \"cd\", \"ce\", \"cf\"]. Note: Although the above answer is in lexicographical order, your answer could be in any order you want. Solution c++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 class Solution { private : vector string result ; public : vector string letterCombinations ( string digits ) { if ( digits . size () == 0 ) return result ; unordered_map int , string hash = {{ 2 , abc },{ 3 , def },{ 4 , ghi },{ 5 , jkl }, { 6 , mno },{ 7 , pqrs },{ 8 , tuv },{ 9 , wxyz }}; addCombination ( digits , hash , 0 , ); return result ; } void addCombination ( string digits , unordered_map int , string hash , int i , string tempString ){ if ( i == digits . size ()){ result . push_back ( tempString ); return ; } string letters = hash [ digits [ i ] - 0 ]; for ( char letter : letters ){ addCombination ( digits , hash , i + 1 , tempString + letter ); } return ; } }; \u200b","title":"0017-letter-combinations-of-a-phone-number"},{"location":"LeetcodeSolved/0017-letter-combinations-of-a-phone-number/#0017-letter-combinations-of-a-phone-number","text":"","title":"0017-letter-combinations-of-a-phone-number"},{"location":"LeetcodeSolved/0017-letter-combinations-of-a-phone-number/#problem","text":"Given a string containing digits from 2-9 inclusive, return all possible letter combinations that the number could represent. A mapping of digit to letters (just like on the telephone buttons) is given below. Note that 1 does not map to any letters. Example: Input: \"23\" Output: [\"ad\", \"ae\", \"af\", \"bd\", \"be\", \"bf\", \"cd\", \"ce\", \"cf\"]. Note: Although the above answer is in lexicographical order, your answer could be in any order you want.","title":"Problem"},{"location":"LeetcodeSolved/0017-letter-combinations-of-a-phone-number/#solution","text":"c++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 class Solution { private : vector string result ; public : vector string letterCombinations ( string digits ) { if ( digits . size () == 0 ) return result ; unordered_map int , string hash = {{ 2 , abc },{ 3 , def },{ 4 , ghi },{ 5 , jkl }, { 6 , mno },{ 7 , pqrs },{ 8 , tuv },{ 9 , wxyz }}; addCombination ( digits , hash , 0 , ); return result ; } void addCombination ( string digits , unordered_map int , string hash , int i , string tempString ){ if ( i == digits . size ()){ result . push_back ( tempString ); return ; } string letters = hash [ digits [ i ] - 0 ]; for ( char letter : letters ){ addCombination ( digits , hash , i + 1 , tempString + letter ); } return ; } }; \u200b","title":"Solution"},{"location":"LeetcodeSolved/0019-remove-nth-node-from-end-of-list/","text":"0019-remove-nth-node-from-end-of-list Problem Given a linked list, remove the n -th node from the end of list and return its head. Example: Given linked list: 1- 2- 3- 4- 5 , and n = 2 . After removing the second node from the end, the linked list becomes 1- 2- 3- 5 . Note: Given n will always be valid. Follow up: Could you do this in one pass? Solution c++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 /** * Definition for singly-linked list. * struct ListNode { * int val; * ListNode *next; * ListNode(int x) : val(x), next(NULL) {} * }; */ class Solution { public : ListNode * removeNthFromEnd ( ListNode * head , int n ) { if ( ! head ) return head ; ListNode dummy ( 0 ); dummy . next = head ; ListNode * fast = dummy ; ListNode * slow = dummy ; for ( int i = 1 ; i = n + 1 ; i ++ ){ fast = fast - next ; } while ( fast ){ fast = fast - next ; slow = slow - next ; } slow - next = slow - next - next ; return dummy . next ; } }; \u200b","title":"0019-remove-nth-node-from-end-of-list"},{"location":"LeetcodeSolved/0019-remove-nth-node-from-end-of-list/#0019-remove-nth-node-from-end-of-list","text":"","title":"0019-remove-nth-node-from-end-of-list"},{"location":"LeetcodeSolved/0019-remove-nth-node-from-end-of-list/#problem","text":"Given a linked list, remove the n -th node from the end of list and return its head. Example: Given linked list: 1- 2- 3- 4- 5 , and n = 2 . After removing the second node from the end, the linked list becomes 1- 2- 3- 5 . Note: Given n will always be valid. Follow up: Could you do this in one pass?","title":"Problem"},{"location":"LeetcodeSolved/0019-remove-nth-node-from-end-of-list/#solution","text":"c++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 /** * Definition for singly-linked list. * struct ListNode { * int val; * ListNode *next; * ListNode(int x) : val(x), next(NULL) {} * }; */ class Solution { public : ListNode * removeNthFromEnd ( ListNode * head , int n ) { if ( ! head ) return head ; ListNode dummy ( 0 ); dummy . next = head ; ListNode * fast = dummy ; ListNode * slow = dummy ; for ( int i = 1 ; i = n + 1 ; i ++ ){ fast = fast - next ; } while ( fast ){ fast = fast - next ; slow = slow - next ; } slow - next = slow - next - next ; return dummy . next ; } }; \u200b","title":"Solution"},{"location":"LeetcodeSolved/0023-merge-k-sorted-lists/","text":"0023-merge-k-sorted-lists Problem Merge k sorted linked lists and return it as one sorted list. Analyze and describe its complexity. Example: Input: [ 1- 4- 5, 1- 3- 4, 2- 6 ] Output: 1- 1- 2- 3- 4- 4- 5- 6 Solution c++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 /** * Definition for singly-linked list. * struct ListNode { * int val; * ListNode *next; * ListNode(int x) : val(x), next(NULL) {} * }; */ \u200b // Merging like merge sort works in NlogK time. class Solution { public : ListNode * mergeKLists ( vector ListNode * lists ) { if ( lists . size () == 0 ) return NULL ; for ( int i = 0 ; i lists . size () - 1 ; i ++ ){ lists [ i + 1 ] = merge2Lists ( lists [ i ], lists [ i + 1 ]); } return lists [ lists . size () - 1 ]; } ListNode * merge2Lists ( ListNode * l1 , ListNode * l2 ){ ListNode dummy ( INT_MIN ); ListNode * tail = dummy ; while ( l1 l2 ){ if ( l1 - val l2 - val ){ tail - next = l1 ; l1 = l1 - next ; } else { tail - next = l2 ; l2 = l2 - next ; } tail = tail - next ; } tail - next = l1 ? l1 : l2 ; return dummy . next ; } }; \u200b //Merge 2 Lists first \u200b","title":"0023-merge-k-sorted-lists"},{"location":"LeetcodeSolved/0023-merge-k-sorted-lists/#0023-merge-k-sorted-lists","text":"","title":"0023-merge-k-sorted-lists"},{"location":"LeetcodeSolved/0023-merge-k-sorted-lists/#problem","text":"Merge k sorted linked lists and return it as one sorted list. Analyze and describe its complexity. Example: Input: [ 1- 4- 5, 1- 3- 4, 2- 6 ] Output: 1- 1- 2- 3- 4- 4- 5- 6","title":"Problem"},{"location":"LeetcodeSolved/0023-merge-k-sorted-lists/#solution","text":"c++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 /** * Definition for singly-linked list. * struct ListNode { * int val; * ListNode *next; * ListNode(int x) : val(x), next(NULL) {} * }; */ \u200b // Merging like merge sort works in NlogK time. class Solution { public : ListNode * mergeKLists ( vector ListNode * lists ) { if ( lists . size () == 0 ) return NULL ; for ( int i = 0 ; i lists . size () - 1 ; i ++ ){ lists [ i + 1 ] = merge2Lists ( lists [ i ], lists [ i + 1 ]); } return lists [ lists . size () - 1 ]; } ListNode * merge2Lists ( ListNode * l1 , ListNode * l2 ){ ListNode dummy ( INT_MIN ); ListNode * tail = dummy ; while ( l1 l2 ){ if ( l1 - val l2 - val ){ tail - next = l1 ; l1 = l1 - next ; } else { tail - next = l2 ; l2 = l2 - next ; } tail = tail - next ; } tail - next = l1 ? l1 : l2 ; return dummy . next ; } }; \u200b //Merge 2 Lists first \u200b","title":"Solution"},{"location":"LeetcodeSolved/0024-swap-nodes-in-pairs/","text":"0024-swap-nodes-in-pairs Problem Given a linked list, swap every two adjacent nodes and return its head. You may not modify the values in the list's nodes, only nodes itself may be changed. Example: Given 1- 2- 3- 4 , you should return the list as 2- 1- 4- 3 . Solution c++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 /** * Definition for singly-linked list. * struct ListNode { * int val; * ListNode *next; * ListNode(int x) : val(x), next(NULL) {} * }; */ class Solution { public : ListNode * swapPairs ( ListNode * head ) { if ( ! head || ! ( head - next )) return head ; ListNode * prev , * after ; prev = head ; head = head - next ; after = head - next ; head - next = prev ; prev - next = swapPairs ( after ); return head ; } }; \u200b","title":"0024-swap-nodes-in-pairs"},{"location":"LeetcodeSolved/0024-swap-nodes-in-pairs/#0024-swap-nodes-in-pairs","text":"","title":"0024-swap-nodes-in-pairs"},{"location":"LeetcodeSolved/0024-swap-nodes-in-pairs/#problem","text":"Given a linked list, swap every two adjacent nodes and return its head. You may not modify the values in the list's nodes, only nodes itself may be changed. Example: Given 1- 2- 3- 4 , you should return the list as 2- 1- 4- 3 .","title":"Problem"},{"location":"LeetcodeSolved/0024-swap-nodes-in-pairs/#solution","text":"c++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 /** * Definition for singly-linked list. * struct ListNode { * int val; * ListNode *next; * ListNode(int x) : val(x), next(NULL) {} * }; */ class Solution { public : ListNode * swapPairs ( ListNode * head ) { if ( ! head || ! ( head - next )) return head ; ListNode * prev , * after ; prev = head ; head = head - next ; after = head - next ; head - next = prev ; prev - next = swapPairs ( after ); return head ; } }; \u200b","title":"Solution"},{"location":"LeetcodeSolved/0031-next-permutation/","text":"0031-next-permutation Problem Implement next permutation , which rearranges numbers into the lexicographically next greater permutation of numbers. If such arrangement is not possible, it must rearrange it as the lowest possible order (ie, sorted in ascending order). The replacement must be in-place and use only constant extra memory. Here are some examples. Inputs are in the left-hand column and its corresponding outputs are in the right-hand column. 1,2,3 \u2192 1,3,2 3,2,1 \u2192 1,2,3 1,1,5 \u2192 1,5,1 Solution c++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 class Solution { public : void nextPermutation ( vector int nums ) { if ( nums . size () == 0 || nums . size () == 1 ) return ; auto it = is_sorted_until ( nums . rbegin (), nums . rend ()); if ( it != nums . rend ()){ swap ( * it , * upper_bound ( nums . rbegin (), it , * it )); } reverse ( nums . rbegin (), it ); return ; } }; \u200b /* find value from last which does not follow assending order. swap this value to upper bound before it. Means just greater value than it. reverse list after this iterator */ \u200b","title":"0031-next-permutation"},{"location":"LeetcodeSolved/0031-next-permutation/#0031-next-permutation","text":"","title":"0031-next-permutation"},{"location":"LeetcodeSolved/0031-next-permutation/#problem","text":"Implement next permutation , which rearranges numbers into the lexicographically next greater permutation of numbers. If such arrangement is not possible, it must rearrange it as the lowest possible order (ie, sorted in ascending order). The replacement must be in-place and use only constant extra memory. Here are some examples. Inputs are in the left-hand column and its corresponding outputs are in the right-hand column. 1,2,3 \u2192 1,3,2 3,2,1 \u2192 1,2,3 1,1,5 \u2192 1,5,1","title":"Problem"},{"location":"LeetcodeSolved/0031-next-permutation/#solution","text":"c++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 class Solution { public : void nextPermutation ( vector int nums ) { if ( nums . size () == 0 || nums . size () == 1 ) return ; auto it = is_sorted_until ( nums . rbegin (), nums . rend ()); if ( it != nums . rend ()){ swap ( * it , * upper_bound ( nums . rbegin (), it , * it )); } reverse ( nums . rbegin (), it ); return ; } }; \u200b /* find value from last which does not follow assending order. swap this value to upper bound before it. Means just greater value than it. reverse list after this iterator */ \u200b","title":"Solution"},{"location":"LeetcodeSolved/0039-combination-sum/","text":"0039-combination-sum Problem Given a set of candidate numbers ( candidates ) (without duplicates) and a target number ( target ), find all unique combinations in candidates where the candidate numbers sums to target . The same repeated number may be chosen from candidates unlimited number of times. Note: All numbers (including target ) will be positive integers. The solution set must not contain duplicate combinations. Example 1: Input: candidates = [2,3,6,7], target = 7 , A solution set is: [ [7], [2,2,3] ] Example 2: Input: candidates = [2,3,5] , target = 8, A solution set is: [ [2,2,2,2], [2,3,3], [3,5] ] Solution c++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 //Template for backtracing problem class Solution { private : vector vector int powerset ; vector int subset ; int total ; public : vector vector int combinationSum ( vector int nums , int target ) { total = target ; backtrackNum ( nums , 0 ); return powerset ; } void backtrackNum ( vector int nums , int start ){ int tempSum = accumulateNums (); if ( tempSum == total ){ powerset . push_back ( subset ); return ; } else if ( tempSum total ) return ; for ( int i = start ; i nums . size (); i ++ ){ subset . push_back ( nums [ i ]); backtrackNum ( nums , i ); subset . pop_back (); } return ; } int accumulateNums (){ int x = 0 ; for ( int k : subset ) x += k ; return x ; } }; \u200b","title":"0039-combination-sum"},{"location":"LeetcodeSolved/0039-combination-sum/#0039-combination-sum","text":"","title":"0039-combination-sum"},{"location":"LeetcodeSolved/0039-combination-sum/#problem","text":"Given a set of candidate numbers ( candidates ) (without duplicates) and a target number ( target ), find all unique combinations in candidates where the candidate numbers sums to target . The same repeated number may be chosen from candidates unlimited number of times. Note: All numbers (including target ) will be positive integers. The solution set must not contain duplicate combinations. Example 1: Input: candidates = [2,3,6,7], target = 7 , A solution set is: [ [7], [2,2,3] ] Example 2: Input: candidates = [2,3,5] , target = 8, A solution set is: [ [2,2,2,2], [2,3,3], [3,5] ]","title":"Problem"},{"location":"LeetcodeSolved/0039-combination-sum/#solution","text":"c++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 //Template for backtracing problem class Solution { private : vector vector int powerset ; vector int subset ; int total ; public : vector vector int combinationSum ( vector int nums , int target ) { total = target ; backtrackNum ( nums , 0 ); return powerset ; } void backtrackNum ( vector int nums , int start ){ int tempSum = accumulateNums (); if ( tempSum == total ){ powerset . push_back ( subset ); return ; } else if ( tempSum total ) return ; for ( int i = start ; i nums . size (); i ++ ){ subset . push_back ( nums [ i ]); backtrackNum ( nums , i ); subset . pop_back (); } return ; } int accumulateNums (){ int x = 0 ; for ( int k : subset ) x += k ; return x ; } }; \u200b","title":"Solution"},{"location":"LeetcodeSolved/0040-combination-sum-ii/","text":"0040-combination-sum-ii Problem Given a collection of candidate numbers ( candidates ) and a target number ( target ), find all unique combinations in candidates where the candidate numbers sums to target . Each number in candidates may only be used once in the combination. Note: All numbers (including target ) will be positive integers. The solution set must not contain duplicate combinations. Example 1: Input: candidates = [10,1,2,7,6,1,5] , target = 8 , A solution set is: [ [1, 7], [1, 2, 5], [2, 6], [1, 1, 6] ] Example 2: Input: candidates = [2,5,2,1,2], target = 5, A solution set is: [ [1,2,2], [5] ] Solution c++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 class Solution { private : vector vector int powerset ; vector int subset ; int total ; public : vector vector int combinationSum2 ( vector int nums , int target ) { total = target ; sort ( nums . begin (), nums . end ()); backtrackNum ( nums , 0 ); return powerset ; } void backtrackNum ( vector int nums , int start ){ int tempSum = accumulateNums (); if ( tempSum == total ){ powerset . push_back ( subset ); return ; } else if ( tempSum total ) return ; for ( int i = start ; i nums . size (); i ++ ){ if ( i start nums [ i ] == nums [ i - 1 ]) continue ; subset . push_back ( nums [ i ]); backtrackNum ( nums , i + 1 ); subset . pop_back (); } return ; } int accumulateNums (){ int x = 0 ; for ( int k : subset ) x += k ; return x ; } }; \u200b","title":"0040-combination-sum-ii"},{"location":"LeetcodeSolved/0040-combination-sum-ii/#0040-combination-sum-ii","text":"","title":"0040-combination-sum-ii"},{"location":"LeetcodeSolved/0040-combination-sum-ii/#problem","text":"Given a collection of candidate numbers ( candidates ) and a target number ( target ), find all unique combinations in candidates where the candidate numbers sums to target . Each number in candidates may only be used once in the combination. Note: All numbers (including target ) will be positive integers. The solution set must not contain duplicate combinations. Example 1: Input: candidates = [10,1,2,7,6,1,5] , target = 8 , A solution set is: [ [1, 7], [1, 2, 5], [2, 6], [1, 1, 6] ] Example 2: Input: candidates = [2,5,2,1,2], target = 5, A solution set is: [ [1,2,2], [5] ]","title":"Problem"},{"location":"LeetcodeSolved/0040-combination-sum-ii/#solution","text":"c++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 class Solution { private : vector vector int powerset ; vector int subset ; int total ; public : vector vector int combinationSum2 ( vector int nums , int target ) { total = target ; sort ( nums . begin (), nums . end ()); backtrackNum ( nums , 0 ); return powerset ; } void backtrackNum ( vector int nums , int start ){ int tempSum = accumulateNums (); if ( tempSum == total ){ powerset . push_back ( subset ); return ; } else if ( tempSum total ) return ; for ( int i = start ; i nums . size (); i ++ ){ if ( i start nums [ i ] == nums [ i - 1 ]) continue ; subset . push_back ( nums [ i ]); backtrackNum ( nums , i + 1 ); subset . pop_back (); } return ; } int accumulateNums (){ int x = 0 ; for ( int k : subset ) x += k ; return x ; } }; \u200b","title":"Solution"},{"location":"LeetcodeSolved/0042-trapping-rain-water/","text":"0042-trapping-rain-water Problem Given n non-negative integers representing an elevation map where the width of each bar is 1, compute how much water it is able to trap after raining. The above elevation map is represented by array [0,1,0,2,1,0,1,3,2,1,2,1]. In this case, 6 units of rain water (blue section) are being trapped. Thanks Marcos for contributing this image! Example: Input: [0,1,0,2,1,0,1,3,2,1,2,1] Output: 6 Solution c++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 class Solution { public : int trap ( vector int height ) { int n = height . size (); vector pair int , int v ( n ); int maxLeft = 0 ; for ( int i = 0 ; i n ; i ++ ){ maxLeft = max ( maxLeft , height [ i ]); v [ i ]. first = maxLeft ; } int maxRight = 0 ; for ( int i = n - 1 ; i = 0 ; i -- ){ maxRight = max ( maxRight , height [ i ]); v [ i ]. second = maxRight ; } int ans = 0 ; for ( int i = 0 ; i n ; i ++ ){ ans += min ( v [ i ]. first , v [ i ]. second ) - height [ i ]; } return ans ; } }; \u200b \u200b","title":"0042-trapping-rain-water"},{"location":"LeetcodeSolved/0042-trapping-rain-water/#0042-trapping-rain-water","text":"","title":"0042-trapping-rain-water"},{"location":"LeetcodeSolved/0042-trapping-rain-water/#problem","text":"Given n non-negative integers representing an elevation map where the width of each bar is 1, compute how much water it is able to trap after raining. The above elevation map is represented by array [0,1,0,2,1,0,1,3,2,1,2,1]. In this case, 6 units of rain water (blue section) are being trapped. Thanks Marcos for contributing this image! Example: Input: [0,1,0,2,1,0,1,3,2,1,2,1] Output: 6","title":"Problem"},{"location":"LeetcodeSolved/0042-trapping-rain-water/#solution","text":"c++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 class Solution { public : int trap ( vector int height ) { int n = height . size (); vector pair int , int v ( n ); int maxLeft = 0 ; for ( int i = 0 ; i n ; i ++ ){ maxLeft = max ( maxLeft , height [ i ]); v [ i ]. first = maxLeft ; } int maxRight = 0 ; for ( int i = n - 1 ; i = 0 ; i -- ){ maxRight = max ( maxRight , height [ i ]); v [ i ]. second = maxRight ; } int ans = 0 ; for ( int i = 0 ; i n ; i ++ ){ ans += min ( v [ i ]. first , v [ i ]. second ) - height [ i ]; } return ans ; } }; \u200b \u200b","title":"Solution"},{"location":"LeetcodeSolved/0047-permutations-ii/","text":"0047-permutations-ii Problem Given a collection of numbers that might contain duplicates, return all possible unique permutations. Example: Input: [1,1,2] Output: [ [1,1,2], [1,2,1], [2,1,1] ] Solution c++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 class Solution { public : vector vector int permuteUnique ( vector int nums ) { vector vector int powerset ; if ( nums . size () == 0 ) return powerset ; sort ( nums . begin (), nums . end ()); do { powerset . push_back ( nums ); } while ( nextPermutation ( nums )); return powerset ; } bool nextPermutation ( vector int nums ) { auto it = is_sorted_until ( nums . rbegin (), nums . rend ()); int toContinue = false ; if ( it != nums . rend ()){ toContinue = true ; swap ( * it , * upper_bound ( nums . rbegin (), it , * it )); } reverse ( nums . rbegin (), it ); return toContinue ; } }; \u200b","title":"0047-permutations-ii"},{"location":"LeetcodeSolved/0047-permutations-ii/#0047-permutations-ii","text":"","title":"0047-permutations-ii"},{"location":"LeetcodeSolved/0047-permutations-ii/#problem","text":"Given a collection of numbers that might contain duplicates, return all possible unique permutations. Example: Input: [1,1,2] Output: [ [1,1,2], [1,2,1], [2,1,1] ]","title":"Problem"},{"location":"LeetcodeSolved/0047-permutations-ii/#solution","text":"c++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 class Solution { public : vector vector int permuteUnique ( vector int nums ) { vector vector int powerset ; if ( nums . size () == 0 ) return powerset ; sort ( nums . begin (), nums . end ()); do { powerset . push_back ( nums ); } while ( nextPermutation ( nums )); return powerset ; } bool nextPermutation ( vector int nums ) { auto it = is_sorted_until ( nums . rbegin (), nums . rend ()); int toContinue = false ; if ( it != nums . rend ()){ toContinue = true ; swap ( * it , * upper_bound ( nums . rbegin (), it , * it )); } reverse ( nums . rbegin (), it ); return toContinue ; } }; \u200b","title":"Solution"},{"location":"LeetcodeSolved/0048-rotate-image/","text":"0048-rotate-image Problem You are given an n x n 2D matrix representing an image. Rotate the image by 90 degrees (clockwise). Note: You have to rotate the image in-place , which means you have to modify the input 2D matrix directly. DO NOT allocate another 2D matrix and do the rotation. Example 1: Given input matrix = [ [1,2,3], [4,5,6], [7,8,9] ], rotate the input matrix in-place such that it becomes: [ [7,4,1], [8,5,2], [9,6,3] ] Example 2: Given input matrix = [ [ 5, 1, 9,11], [ 2, 4, 8,10], [13, 3, 6, 7], [15,14,12,16] ], rotate the input matrix in-place such that it becomes: [ [15,13, 2, 5], [14, 3, 4, 1], [12, 6, 8, 9], [16, 7,10,11] ] Solution c++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 //General Method // Clockwise Rotation : swap rows, swap symmetry // Anticlock : swap cols, swap symmetry class Solution { public : void rotate ( vector vector int matrix ) { int m = matrix . size (); int n = m ; for ( int i = 0 ; i m ; i ++ ){ reverse ( matrix [ i ]. begin (), matrix [ i ]. end ()); } for ( int i = 0 ; i m - 1 ; i ++ ){ int c = 1 ; for ( int j = n - 2 ; j = 0 ; j -- ){ swap ( matrix [ i ][ j ], matrix [ i + c ][ j + c ]); c ++ ; } n -- ; } } }; \u200b","title":"0048-rotate-image"},{"location":"LeetcodeSolved/0048-rotate-image/#0048-rotate-image","text":"","title":"0048-rotate-image"},{"location":"LeetcodeSolved/0048-rotate-image/#problem","text":"You are given an n x n 2D matrix representing an image. Rotate the image by 90 degrees (clockwise). Note: You have to rotate the image in-place , which means you have to modify the input 2D matrix directly. DO NOT allocate another 2D matrix and do the rotation. Example 1: Given input matrix = [ [1,2,3], [4,5,6], [7,8,9] ], rotate the input matrix in-place such that it becomes: [ [7,4,1], [8,5,2], [9,6,3] ] Example 2: Given input matrix = [ [ 5, 1, 9,11], [ 2, 4, 8,10], [13, 3, 6, 7], [15,14,12,16] ], rotate the input matrix in-place such that it becomes: [ [15,13, 2, 5], [14, 3, 4, 1], [12, 6, 8, 9], [16, 7,10,11] ]","title":"Problem"},{"location":"LeetcodeSolved/0048-rotate-image/#solution","text":"c++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 //General Method // Clockwise Rotation : swap rows, swap symmetry // Anticlock : swap cols, swap symmetry class Solution { public : void rotate ( vector vector int matrix ) { int m = matrix . size (); int n = m ; for ( int i = 0 ; i m ; i ++ ){ reverse ( matrix [ i ]. begin (), matrix [ i ]. end ()); } for ( int i = 0 ; i m - 1 ; i ++ ){ int c = 1 ; for ( int j = n - 2 ; j = 0 ; j -- ){ swap ( matrix [ i ][ j ], matrix [ i + c ][ j + c ]); c ++ ; } n -- ; } } }; \u200b","title":"Solution"},{"location":"LeetcodeSolved/0051-n-queens/","text":"0051-n-queens Problem The n -queens puzzle is the problem of placing n queens on an n \u00d7 n chessboard such that no two queens attack each other. Given an integer n , return all distinct solutions to the n -queens puzzle. Each solution contains a distinct board configuration of the n -queens' placement, where 'Q' and '.' both indicate a queen and an empty space respectively. Example: Input: 4 Output: [ [\".Q..\", // Solution 1 \"...Q\", \"Q...\", \"..Q.\"], [\"..Q.\", // Solution 2 \"Q...\", \"...Q\", \".Q..\"] ] Explanation: There exist two distinct solutions to the 4-queens puzzle as shown above. Solution c++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 class Solution { vector vector string powerset ; public : vector vector string solveNQueens ( int n ) { vector string board ( n , string ( n , . )); solveQueen ( board , 0 , n ); return powerset ; } void solveQueen ( vector string board , int row , int n ){ if ( row == n ) return ; for ( int i = 0 ; i n ; i ++ ){ if ( safeQueen ( board , row , i , n )){ board [ row ][ i ] = Q ; if ( row == n - 1 ){ powerset . push_back ( board ); } solveQueen ( board , row + 1 , n ); board [ row ][ i ] = . ; } } } bool safeQueen ( vector string board , int sr , int sc , int n ){ for ( int j = 0 ; j n ; j ++ ){ if ( j != sc board [ sr ][ j ] == Q ) return false ; } for ( int i = 0 ; i n ; i ++ ){ if ( i != sr board [ i ][ sc ] == Q ) return false ; } for ( int i = 1 ; i n ; i ++ ){ static int dirr [] = { - 1 , - 1 , 1 , 1 }; static int dirc [] = { - 1 , 1 , - 1 , 1 }; for ( int k = 0 ; k 4 ; k ++ ){ int nr = sr + i * dirr [ k ]; int nc = sc + i * dirc [ k ]; if ( nr = n || nr 0 || nc = n || nc 0 ) continue ; if ( board [ nr ][ nc ] == Q ) return false ; } } return true ; } }; \u200b","title":"0051-n-queens"},{"location":"LeetcodeSolved/0051-n-queens/#0051-n-queens","text":"","title":"0051-n-queens"},{"location":"LeetcodeSolved/0051-n-queens/#problem","text":"The n -queens puzzle is the problem of placing n queens on an n \u00d7 n chessboard such that no two queens attack each other. Given an integer n , return all distinct solutions to the n -queens puzzle. Each solution contains a distinct board configuration of the n -queens' placement, where 'Q' and '.' both indicate a queen and an empty space respectively. Example: Input: 4 Output: [ [\".Q..\", // Solution 1 \"...Q\", \"Q...\", \"..Q.\"], [\"..Q.\", // Solution 2 \"Q...\", \"...Q\", \".Q..\"] ] Explanation: There exist two distinct solutions to the 4-queens puzzle as shown above.","title":"Problem"},{"location":"LeetcodeSolved/0051-n-queens/#solution","text":"c++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 class Solution { vector vector string powerset ; public : vector vector string solveNQueens ( int n ) { vector string board ( n , string ( n , . )); solveQueen ( board , 0 , n ); return powerset ; } void solveQueen ( vector string board , int row , int n ){ if ( row == n ) return ; for ( int i = 0 ; i n ; i ++ ){ if ( safeQueen ( board , row , i , n )){ board [ row ][ i ] = Q ; if ( row == n - 1 ){ powerset . push_back ( board ); } solveQueen ( board , row + 1 , n ); board [ row ][ i ] = . ; } } } bool safeQueen ( vector string board , int sr , int sc , int n ){ for ( int j = 0 ; j n ; j ++ ){ if ( j != sc board [ sr ][ j ] == Q ) return false ; } for ( int i = 0 ; i n ; i ++ ){ if ( i != sr board [ i ][ sc ] == Q ) return false ; } for ( int i = 1 ; i n ; i ++ ){ static int dirr [] = { - 1 , - 1 , 1 , 1 }; static int dirc [] = { - 1 , 1 , - 1 , 1 }; for ( int k = 0 ; k 4 ; k ++ ){ int nr = sr + i * dirr [ k ]; int nc = sc + i * dirc [ k ]; if ( nr = n || nr 0 || nc = n || nc 0 ) continue ; if ( board [ nr ][ nc ] == Q ) return false ; } } return true ; } }; \u200b","title":"Solution"},{"location":"LeetcodeSolved/0054-spiral-matrix/","text":"0054-spiral-matrix Problem Given a matrix of m x n elements ( m rows, n columns), return all elements of the matrix in spiral order. Example 1: Input: [ [ 1, 2, 3 ], [ 4, 5, 6 ], [ 7, 8, 9 ] ] Output: [1,2,3,6,9,8,7,4,5] Example 2: Input: [ [1, 2, 3, 4], [5, 6, 7, 8], [9,10,11,12] ] Output: [1,2,3,4,8,12,11,10,9,5,6,7] Solution c++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 class Solution { public : vector int spiralOrder ( vector vector int matrix ) { if ( matrix . size () == 0 ) return vector int (); int cs = 0 , rs = 0 , ce = matrix [ 0 ]. size () - 1 , re = matrix . size () - 1 ; vector int ans ; while ( cs = ce rs = re ){ for ( int i = cs ; i = ce ; i ++ ){ ans . push_back ( matrix [ rs ][ i ]); } if ( cs ce ) break ; rs ++ ; for ( int i = rs ; i = re ; i ++ ){ ans . push_back ( matrix [ i ][ ce ]); } if ( rs re ) break ; ce -- ; for ( int i = ce ; i = cs ; i -- ){ ans . push_back ( matrix [ re ][ i ]); } if ( cs ce ) break ; re -- ; for ( int i = re ; i = rs ; i -- ){ ans . push_back ( matrix [ i ][ cs ]); } if ( rs re ) break ; cs ++ ; } return ans ; } }; \u200b","title":"0054-spiral-matrix"},{"location":"LeetcodeSolved/0054-spiral-matrix/#0054-spiral-matrix","text":"","title":"0054-spiral-matrix"},{"location":"LeetcodeSolved/0054-spiral-matrix/#problem","text":"Given a matrix of m x n elements ( m rows, n columns), return all elements of the matrix in spiral order. Example 1: Input: [ [ 1, 2, 3 ], [ 4, 5, 6 ], [ 7, 8, 9 ] ] Output: [1,2,3,6,9,8,7,4,5] Example 2: Input: [ [1, 2, 3, 4], [5, 6, 7, 8], [9,10,11,12] ] Output: [1,2,3,4,8,12,11,10,9,5,6,7]","title":"Problem"},{"location":"LeetcodeSolved/0054-spiral-matrix/#solution","text":"c++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 class Solution { public : vector int spiralOrder ( vector vector int matrix ) { if ( matrix . size () == 0 ) return vector int (); int cs = 0 , rs = 0 , ce = matrix [ 0 ]. size () - 1 , re = matrix . size () - 1 ; vector int ans ; while ( cs = ce rs = re ){ for ( int i = cs ; i = ce ; i ++ ){ ans . push_back ( matrix [ rs ][ i ]); } if ( cs ce ) break ; rs ++ ; for ( int i = rs ; i = re ; i ++ ){ ans . push_back ( matrix [ i ][ ce ]); } if ( rs re ) break ; ce -- ; for ( int i = ce ; i = cs ; i -- ){ ans . push_back ( matrix [ re ][ i ]); } if ( cs ce ) break ; re -- ; for ( int i = re ; i = rs ; i -- ){ ans . push_back ( matrix [ i ][ cs ]); } if ( rs re ) break ; cs ++ ; } return ans ; } }; \u200b","title":"Solution"},{"location":"LeetcodeSolved/0055-jump-game/","text":"0055-jump-game Problem Given an array of non-negative integers, you are initially positioned at the first index of the array. Each element in the array represents your maximum jump length at that position. Determine if you are able to reach the last index. Example 1: Input: [2,3,1,1,4] Output: true Explanation: Jump 1 step from index 0 to 1, then 3 steps to the last index. Example 2: Input: [3,2,1,0,4] Output: false Explanation: You will always arrive at index 3 no matter what. Its maximum jump length is 0, which makes it impossible to reach the last index. Solution c++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 class Solution { public : bool canJump ( vector int nums ) { int n = nums . size (); if ( n == 1 ) return true ; int targetIndex = n - 1 ; for ( int i = n - 2 ; i = 0 ; i -- ){ // If it is possible to jump from current index(i) to targetIndex // than we only need to reach till current index if ( nums [ i ] = targetIndex - i ) targetIndex = i ; } return targetIndex == 0 ; } }; \u200b","title":"0055-jump-game"},{"location":"LeetcodeSolved/0055-jump-game/#0055-jump-game","text":"","title":"0055-jump-game"},{"location":"LeetcodeSolved/0055-jump-game/#problem","text":"Given an array of non-negative integers, you are initially positioned at the first index of the array. Each element in the array represents your maximum jump length at that position. Determine if you are able to reach the last index. Example 1: Input: [2,3,1,1,4] Output: true Explanation: Jump 1 step from index 0 to 1, then 3 steps to the last index. Example 2: Input: [3,2,1,0,4] Output: false Explanation: You will always arrive at index 3 no matter what. Its maximum jump length is 0, which makes it impossible to reach the last index.","title":"Problem"},{"location":"LeetcodeSolved/0055-jump-game/#solution","text":"c++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 class Solution { public : bool canJump ( vector int nums ) { int n = nums . size (); if ( n == 1 ) return true ; int targetIndex = n - 1 ; for ( int i = n - 2 ; i = 0 ; i -- ){ // If it is possible to jump from current index(i) to targetIndex // than we only need to reach till current index if ( nums [ i ] = targetIndex - i ) targetIndex = i ; } return targetIndex == 0 ; } }; \u200b","title":"Solution"},{"location":"LeetcodeSolved/0056-merge-intervals/","text":"0056-merge-intervals Problem Given a collection of intervals, merge all overlapping intervals. Example 1: Input: [[1,3],[2,6],[8,10],[15,18]] Output: [[1,6],[8,10],[15,18]] Explanation: Since intervals [1,3] and [2,6] overlaps, merge them into [1,6]. Example 2: Input: [[1,4],[4,5]] Output: [[1,5]] Explanation: Intervals [1,4] and [4,5] are considered overlapping. NOTE: input types have been changed on April 15, 2019. Please reset to default code definition to get new method signature. Solution c++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 class Solution { public : vector vector int merge ( vector vector int intervals ) { if ( intervals . size () == 0 ) return intervals ; sort ( intervals . begin (), intervals . end ()); int n = intervals . size (); vector vector int res ; for ( int i = 0 ; i n ;){ int mini = intervals [ i ][ 0 ]; int maxi = intervals [ i ][ 1 ]; i ++ ; while ( i n intervals [ i ][ 0 ] = maxi ){ maxi = max ( maxi , intervals [ i ][ 1 ]); i ++ ; } res . push_back ({ mini , maxi }); } return res ; } }; \u200b","title":"0056-merge-intervals"},{"location":"LeetcodeSolved/0056-merge-intervals/#0056-merge-intervals","text":"","title":"0056-merge-intervals"},{"location":"LeetcodeSolved/0056-merge-intervals/#problem","text":"Given a collection of intervals, merge all overlapping intervals. Example 1: Input: [[1,3],[2,6],[8,10],[15,18]] Output: [[1,6],[8,10],[15,18]] Explanation: Since intervals [1,3] and [2,6] overlaps, merge them into [1,6]. Example 2: Input: [[1,4],[4,5]] Output: [[1,5]] Explanation: Intervals [1,4] and [4,5] are considered overlapping. NOTE: input types have been changed on April 15, 2019. Please reset to default code definition to get new method signature.","title":"Problem"},{"location":"LeetcodeSolved/0056-merge-intervals/#solution","text":"c++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 class Solution { public : vector vector int merge ( vector vector int intervals ) { if ( intervals . size () == 0 ) return intervals ; sort ( intervals . begin (), intervals . end ()); int n = intervals . size (); vector vector int res ; for ( int i = 0 ; i n ;){ int mini = intervals [ i ][ 0 ]; int maxi = intervals [ i ][ 1 ]; i ++ ; while ( i n intervals [ i ][ 0 ] = maxi ){ maxi = max ( maxi , intervals [ i ][ 1 ]); i ++ ; } res . push_back ({ mini , maxi }); } return res ; } }; \u200b","title":"Solution"},{"location":"LeetcodeSolved/0062-unique-paths/","text":"0062-unique-paths Problem A robot is located at the top-left corner of a m x n grid (marked 'Start' in the diagram below). The robot can only move either down or right at any point in time. The robot is trying to reach the bottom-right corner of the grid (marked 'Finish' in the diagram below). How many possible unique paths are there? Above is a 7 x 3 grid. How many possible unique paths are there? Note: m and n will be at most 100. Example 1: Input: m = 3, n = 2 Output: 3 Explanation: From the top-left corner, there are a total of 3 ways to reach the bottom-right corner: 1. Right - Right - Down 2. Right - Down - Right 3. Down - Right - Right Example 2: Input: m = 7, n = 3 Output: 28 Solution c++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 class Solution { public : int uniquePaths ( int m , int n ) { if ( m == 0 || n == 0 ) return 0 ; if ( m == 1 || n == 1 ) return 1 ; vector int dp ( n , 1 ); int upper = 1 ; for ( int i = 1 ; i m ; i ++ ){ for ( int j = n - 2 ; j = 0 ; j -- ){ dp [ j ] = dp [ j ] + dp [ j + 1 ]; } } return dp [ 0 ]; } }; \u200b","title":"0062-unique-paths"},{"location":"LeetcodeSolved/0062-unique-paths/#0062-unique-paths","text":"","title":"0062-unique-paths"},{"location":"LeetcodeSolved/0062-unique-paths/#problem","text":"A robot is located at the top-left corner of a m x n grid (marked 'Start' in the diagram below). The robot can only move either down or right at any point in time. The robot is trying to reach the bottom-right corner of the grid (marked 'Finish' in the diagram below). How many possible unique paths are there? Above is a 7 x 3 grid. How many possible unique paths are there? Note: m and n will be at most 100. Example 1: Input: m = 3, n = 2 Output: 3 Explanation: From the top-left corner, there are a total of 3 ways to reach the bottom-right corner: 1. Right - Right - Down 2. Right - Down - Right 3. Down - Right - Right Example 2: Input: m = 7, n = 3 Output: 28","title":"Problem"},{"location":"LeetcodeSolved/0062-unique-paths/#solution","text":"c++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 class Solution { public : int uniquePaths ( int m , int n ) { if ( m == 0 || n == 0 ) return 0 ; if ( m == 1 || n == 1 ) return 1 ; vector int dp ( n , 1 ); int upper = 1 ; for ( int i = 1 ; i m ; i ++ ){ for ( int j = n - 2 ; j = 0 ; j -- ){ dp [ j ] = dp [ j ] + dp [ j + 1 ]; } } return dp [ 0 ]; } }; \u200b","title":"Solution"},{"location":"LeetcodeSolved/0073-set-matrix-zeroes/","text":"0073-set-matrix-zeroes Problem Given a m x n matrix, if an element is 0, set its entire row and column to 0. Do it in-place . Example 1: Input: [ [1,1,1], [1,0,1], [1,1,1] ] Output: [ [1,0,1], [0,0,0], [1,0,1] ] Example 2: Input: [ [0,1,2,0], [3,4,5,2], [1,3,1,5] ] Output: [ [0,0,0,0], [0,4,5,0], [0,3,1,0] ] Follow up: A straight forward solution using O( m n ) space is probably a bad idea. A simple improvement uses O( m + n ) space, but still not the best solution. Could you devise a constant space solution? Solution c++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 //Constant space solution //First time done by simulting row and then col with -1 if 0 is found // But it didn t work if matrix has -1 or INT_MIN class Solution { public : void setZeroes ( vector vector int matrix ) { int m = matrix . size (); int n = matrix [ 0 ]. size (); bool row = false , col = false ; for ( int i = 0 ; i m ; i ++ ){ for ( int j = 0 ; j n ; j ++ ){ if ( matrix [ i ][ j ] == 0 ){ if ( i == 0 ) row = true ; if ( j == 0 ) col = true ; matrix [ 0 ][ j ] = 0 ; matrix [ i ][ 0 ] = 0 ; } } } for ( int i = 1 ; i m ; i ++ ){ for ( int j = 1 ; j n ; j ++ ){ if ( matrix [ 0 ][ j ] == 0 || matrix [ i ][ 0 ] == 0 ){ matrix [ i ][ j ] = 0 ; } } } if ( row ) for ( int j = 0 ; j n ; j ++ ) matrix [ 0 ][ j ] = 0 ; if ( col ) for ( int i = 0 ; i m ; i ++ ) matrix [ i ][ 0 ] = 0 ; } \u200b","title":"0073-set-matrix-zeroes"},{"location":"LeetcodeSolved/0073-set-matrix-zeroes/#0073-set-matrix-zeroes","text":"","title":"0073-set-matrix-zeroes"},{"location":"LeetcodeSolved/0073-set-matrix-zeroes/#problem","text":"Given a m x n matrix, if an element is 0, set its entire row and column to 0. Do it in-place . Example 1: Input: [ [1,1,1], [1,0,1], [1,1,1] ] Output: [ [1,0,1], [0,0,0], [1,0,1] ] Example 2: Input: [ [0,1,2,0], [3,4,5,2], [1,3,1,5] ] Output: [ [0,0,0,0], [0,4,5,0], [0,3,1,0] ] Follow up: A straight forward solution using O( m n ) space is probably a bad idea. A simple improvement uses O( m + n ) space, but still not the best solution. Could you devise a constant space solution?","title":"Problem"},{"location":"LeetcodeSolved/0073-set-matrix-zeroes/#solution","text":"c++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 //Constant space solution //First time done by simulting row and then col with -1 if 0 is found // But it didn t work if matrix has -1 or INT_MIN class Solution { public : void setZeroes ( vector vector int matrix ) { int m = matrix . size (); int n = matrix [ 0 ]. size (); bool row = false , col = false ; for ( int i = 0 ; i m ; i ++ ){ for ( int j = 0 ; j n ; j ++ ){ if ( matrix [ i ][ j ] == 0 ){ if ( i == 0 ) row = true ; if ( j == 0 ) col = true ; matrix [ 0 ][ j ] = 0 ; matrix [ i ][ 0 ] = 0 ; } } } for ( int i = 1 ; i m ; i ++ ){ for ( int j = 1 ; j n ; j ++ ){ if ( matrix [ 0 ][ j ] == 0 || matrix [ i ][ 0 ] == 0 ){ matrix [ i ][ j ] = 0 ; } } } if ( row ) for ( int j = 0 ; j n ; j ++ ) matrix [ 0 ][ j ] = 0 ; if ( col ) for ( int i = 0 ; i m ; i ++ ) matrix [ i ][ 0 ] = 0 ; } \u200b","title":"Solution"},{"location":"LeetcodeSolved/0075-sort-colors/","text":"0075-sort-colors Problem Given an array with n objects colored red, white or blue, sort them in-place so that objects of the same color are adjacent, with the colors in the order red, white and blue. Here, we will use the integers 0, 1, and 2 to represent the color red, white, and blue respectively. Note: You are not suppose to use the library's sort function for this problem. Example: Input: [2,0,2,1,1,0] Output: [0,0,1,1,2,2] Follow up: A rather straight forward solution is a two-pass algorithm using counting sort. First, iterate the array counting number of 0's, 1's, and 2's, then overwrite array with total number of 0's, then 1's and followed by 2's. Could you come up with a one-pass algorithm using only constant space? Solution c++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 class Solution { public : void sortColors ( vector int nums ) { int low = 0 , mid = 0 , high = nums . size () - 1 ; while ( mid = high ){ if ( nums [ mid ] == 1 ) mid ++ ; else if ( nums [ mid ] == 0 ){ swap ( nums [ mid ], nums [ low ]); low ++ ; mid ++ ; } else if ( nums [ mid ] == 2 ){ swap ( nums [ mid ], nums [ high ]); high -- ; } } } }; \u200b","title":"0075-sort-colors"},{"location":"LeetcodeSolved/0075-sort-colors/#0075-sort-colors","text":"","title":"0075-sort-colors"},{"location":"LeetcodeSolved/0075-sort-colors/#problem","text":"Given an array with n objects colored red, white or blue, sort them in-place so that objects of the same color are adjacent, with the colors in the order red, white and blue. Here, we will use the integers 0, 1, and 2 to represent the color red, white, and blue respectively. Note: You are not suppose to use the library's sort function for this problem. Example: Input: [2,0,2,1,1,0] Output: [0,0,1,1,2,2] Follow up: A rather straight forward solution is a two-pass algorithm using counting sort. First, iterate the array counting number of 0's, 1's, and 2's, then overwrite array with total number of 0's, then 1's and followed by 2's. Could you come up with a one-pass algorithm using only constant space?","title":"Problem"},{"location":"LeetcodeSolved/0075-sort-colors/#solution","text":"c++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 class Solution { public : void sortColors ( vector int nums ) { int low = 0 , mid = 0 , high = nums . size () - 1 ; while ( mid = high ){ if ( nums [ mid ] == 1 ) mid ++ ; else if ( nums [ mid ] == 0 ){ swap ( nums [ mid ], nums [ low ]); low ++ ; mid ++ ; } else if ( nums [ mid ] == 2 ){ swap ( nums [ mid ], nums [ high ]); high -- ; } } } }; \u200b","title":"Solution"},{"location":"LeetcodeSolved/0076-minimum-window-substring/","text":"0076-minimum-window-substring Problem Given a string S and a string T, find the minimum window in S which will contain all the characters in T in complexity O(n). Example: Input: S = \"ADOBECODEBANC\", T = \"ABC\" Output: \"BANC\" Note: If there is no such window in S that covers all characters in T, return the empty string \"\" . If there is such window, you are guaranteed that there will always be only one unique minimum window in S. Solution c++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 class Solution { public : string minWindow ( string s , string t ) { unordered_map char , int m ; for ( char ch : t ) m [ ch ] ++ ; int end = 0 , start = 0 , minLen = INT_MAX , head = 0 , counter = t . size (); while ( end s . size ()){ if ( m [ s [ end ]] 0 ) counter -- ; m [ s [ end ]] -- ; end ++ ; // If char is not in t then they will be negative // If they were in t, then they may be zero or // If end contains higher frequency of them then they will be negative // While loop continue to remove redundent caracter while ( counter == 0 ){ if ( end - start minLen ){ minLen = end - start ; head = start ; } m [ s [ start ]] ++ ; if ( m [ s [ start ]] 0 ) counter ++ ; start ++ ; } } if ( minLen == INT_MAX ) return ; return s . substr ( head , minLen ); } }; \u200b","title":"0076-minimum-window-substring"},{"location":"LeetcodeSolved/0076-minimum-window-substring/#0076-minimum-window-substring","text":"","title":"0076-minimum-window-substring"},{"location":"LeetcodeSolved/0076-minimum-window-substring/#problem","text":"Given a string S and a string T, find the minimum window in S which will contain all the characters in T in complexity O(n). Example: Input: S = \"ADOBECODEBANC\", T = \"ABC\" Output: \"BANC\" Note: If there is no such window in S that covers all characters in T, return the empty string \"\" . If there is such window, you are guaranteed that there will always be only one unique minimum window in S.","title":"Problem"},{"location":"LeetcodeSolved/0076-minimum-window-substring/#solution","text":"c++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 class Solution { public : string minWindow ( string s , string t ) { unordered_map char , int m ; for ( char ch : t ) m [ ch ] ++ ; int end = 0 , start = 0 , minLen = INT_MAX , head = 0 , counter = t . size (); while ( end s . size ()){ if ( m [ s [ end ]] 0 ) counter -- ; m [ s [ end ]] -- ; end ++ ; // If char is not in t then they will be negative // If they were in t, then they may be zero or // If end contains higher frequency of them then they will be negative // While loop continue to remove redundent caracter while ( counter == 0 ){ if ( end - start minLen ){ minLen = end - start ; head = start ; } m [ s [ start ]] ++ ; if ( m [ s [ start ]] 0 ) counter ++ ; start ++ ; } } if ( minLen == INT_MAX ) return ; return s . substr ( head , minLen ); } }; \u200b","title":"Solution"},{"location":"LeetcodeSolved/0079-word-search/","text":"0079-word-search Problem Given a 2D board and a word, find if the word exists in the grid. The word can be constructed from letters of sequentially adjacent cell, where \"adjacent\" cells are those horizontally or vertically neighboring. The same letter cell may not be used more than once. Example: board = [ ['A','B','C','E'], ['S','F','C','S'], ['A','D','E','E'] ] Given word = \" ABCCED \", return true . Given word = \" SEE \", return true . Given word = \" ABCB \", return false . Solution c++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 \u200b class Solution { public : bool exist ( vector vector char board , string word ) { if ( word . size () == 0 ) return true ; int row = board . size (); int col = board [ 0 ]. size (); if ( row * col word . size ()) return false ; vector vector int visited ( row , vector int ( col , 0 )); for ( int i = 0 ; i row ; i ++ ){ for ( int j = 0 ; j col ; j ++ ){ if ( board [ i ][ j ] == word [ 0 ]){ visited [ i ][ j ] = 1 ; if ( boggle ( board , visited , word , 1 , i , j )) return true ; visited [ i ][ j ] = 0 ; } } } return false ; } bool boggle ( vector vector char board , vector vector int visited , string word , int start , int sr , int sc ){ int row = board . size (); int col = board [ 0 ]. size (); if ( start == word . size ()) return true ; if ( sr 0 || sr row - 1 || sc 0 || sc col - 1 ) return false ; //if(visited[sr][sc] == 1) return false; int nrow [] = { - 1 , 0 , 0 , 1 }; int ncol [] = { 0 , - 1 , 1 , 0 }; for ( int k = 0 ; k 4 ; k ++ ){ int x = sr + nrow [ k ]; int y = sc + ncol [ k ]; if ( x 0 || x row - 1 || y 0 || y col - 1 ) continue ; if ( word [ start ] == board [ x ][ y ] visited [ x ][ y ] == 0 ){ visited [ x ][ y ] = 1 ; if ( boggle ( board , visited , word , start + 1 , x , y )) return true ; \u200b","title":"0079-word-search"},{"location":"LeetcodeSolved/0079-word-search/#0079-word-search","text":"","title":"0079-word-search"},{"location":"LeetcodeSolved/0079-word-search/#problem","text":"Given a 2D board and a word, find if the word exists in the grid. The word can be constructed from letters of sequentially adjacent cell, where \"adjacent\" cells are those horizontally or vertically neighboring. The same letter cell may not be used more than once. Example: board = [ ['A','B','C','E'], ['S','F','C','S'], ['A','D','E','E'] ] Given word = \" ABCCED \", return true . Given word = \" SEE \", return true . Given word = \" ABCB \", return false .","title":"Problem"},{"location":"LeetcodeSolved/0079-word-search/#solution","text":"c++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 \u200b class Solution { public : bool exist ( vector vector char board , string word ) { if ( word . size () == 0 ) return true ; int row = board . size (); int col = board [ 0 ]. size (); if ( row * col word . size ()) return false ; vector vector int visited ( row , vector int ( col , 0 )); for ( int i = 0 ; i row ; i ++ ){ for ( int j = 0 ; j col ; j ++ ){ if ( board [ i ][ j ] == word [ 0 ]){ visited [ i ][ j ] = 1 ; if ( boggle ( board , visited , word , 1 , i , j )) return true ; visited [ i ][ j ] = 0 ; } } } return false ; } bool boggle ( vector vector char board , vector vector int visited , string word , int start , int sr , int sc ){ int row = board . size (); int col = board [ 0 ]. size (); if ( start == word . size ()) return true ; if ( sr 0 || sr row - 1 || sc 0 || sc col - 1 ) return false ; //if(visited[sr][sc] == 1) return false; int nrow [] = { - 1 , 0 , 0 , 1 }; int ncol [] = { 0 , - 1 , 1 , 0 }; for ( int k = 0 ; k 4 ; k ++ ){ int x = sr + nrow [ k ]; int y = sc + ncol [ k ]; if ( x 0 || x row - 1 || y 0 || y col - 1 ) continue ; if ( word [ start ] == board [ x ][ y ] visited [ x ][ y ] == 0 ){ visited [ x ][ y ] = 1 ; if ( boggle ( board , visited , word , start + 1 , x , y )) return true ; \u200b","title":"Solution"},{"location":"LeetcodeSolved/0090-subsets-ii/","text":"0090-subsets-ii Problem Given a collection of integers that might contain duplicates, nums , return all possible subsets (the power set). Note: The solution set must not contain duplicate subsets. Example: Input: [1,2,2] Output: [ [2], [1], [1,2,2], [2,2], [1,2], [] ] Solution c++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 class Solution { private : vector vector int powerset ; vector int subset ; public : vector vector int subsetsWithDup ( vector int nums ) { if ( nums . size () == 0 ) return {}; sort ( nums . begin (), nums . end ()); backtrackNums ( nums , 0 ); return powerset ; } void backtrackNums ( vector int nums , int s ){ powerset . push_back ( subset ); for ( int i = s ; i nums . size (); i ++ ){ if ( i s nums [ i ] == nums [ i - 1 ]) continue ; subset . push_back ( nums [ i ]); backtrackNums ( nums , i + 1 ); subset . pop_back (); } } }; //Try using bit masking \u200b","title":"0090-subsets-ii"},{"location":"LeetcodeSolved/0090-subsets-ii/#0090-subsets-ii","text":"","title":"0090-subsets-ii"},{"location":"LeetcodeSolved/0090-subsets-ii/#problem","text":"Given a collection of integers that might contain duplicates, nums , return all possible subsets (the power set). Note: The solution set must not contain duplicate subsets. Example: Input: [1,2,2] Output: [ [2], [1], [1,2,2], [2,2], [1,2], [] ]","title":"Problem"},{"location":"LeetcodeSolved/0090-subsets-ii/#solution","text":"c++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 class Solution { private : vector vector int powerset ; vector int subset ; public : vector vector int subsetsWithDup ( vector int nums ) { if ( nums . size () == 0 ) return {}; sort ( nums . begin (), nums . end ()); backtrackNums ( nums , 0 ); return powerset ; } void backtrackNums ( vector int nums , int s ){ powerset . push_back ( subset ); for ( int i = s ; i nums . size (); i ++ ){ if ( i s nums [ i ] == nums [ i - 1 ]) continue ; subset . push_back ( nums [ i ]); backtrackNums ( nums , i + 1 ); subset . pop_back (); } } }; //Try using bit masking \u200b","title":"Solution"},{"location":"LeetcodeSolved/0091-decode-ways/","text":"0091-decode-ways Problem A message containing letters from A-Z is being encoded to numbers using the following mapping: 'A' - 1 'B' - 2 ... 'Z' - 26 Given a non-empty string containing only digits, determine the total number of ways to decode it. Example 1: Input: \"12\" Output: 2 Explanation: It could be decoded as \"AB\" (1 2) or \"L\" (12). Example 2: Input: \"226\" Output: 3 Explanation: It could be decoded as \"BZ\" (2 26), \"VF\" (22 6), or \"BBF\" (2 2 6). Solution c++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 class Solution { public : int numDecodings ( string s ) { int n = s . size (); // If 0 is string then no way to decode. if ( n == 0 || s [ 0 ] == 0 ) return 0 ; if ( n == 1 ) return 1 ; // dp[i] represents how many way to decode string fron that index till last index. vector int dp ( n ); // Initialize dp[n-1] and dp[n-2] rest is easy. // Before zero must be clubbed with either 1 or 2. Like 10 or 20. // So dp[i] = 0 where zero is at i. You may think like no existance of single zero // Other than 1 and 2 then write 0 at dp[i] since wrong encoded string given. if ( s [ n - 1 ] == 0 ) dp [ n - 1 ] = 0 ; else dp [ n - 1 ] = 1 ; // If 1 or 2 and next is zero. Than only one way. if (( s [ n - 2 ] == 1 || s [ n - 2 ] == 2 ) s [ n - 1 ] == 0 ) dp [ n - 2 ] = 1 ; // Invalid encoded string case else if ( s [ n - 1 ] == 0 || s [ n - 2 ] == 0 ) dp [ n - 2 ] = 0 ; // valid number case. 10 - 26 two possible way else if ( s [ n - 2 ] == 1 || ( s [ n - 2 ] == 2 s [ n - 1 ] = 6 )) dp [ n - 2 ] = 2 ; // 3- 9 digit case else dp [ n - 2 ] = 1 ; for ( int i = n - 3 ; i = 0 ; i -- ){ // If zero incounters leave it now. \u200b","title":"0091-decode-ways"},{"location":"LeetcodeSolved/0091-decode-ways/#0091-decode-ways","text":"","title":"0091-decode-ways"},{"location":"LeetcodeSolved/0091-decode-ways/#problem","text":"A message containing letters from A-Z is being encoded to numbers using the following mapping: 'A' - 1 'B' - 2 ... 'Z' - 26 Given a non-empty string containing only digits, determine the total number of ways to decode it. Example 1: Input: \"12\" Output: 2 Explanation: It could be decoded as \"AB\" (1 2) or \"L\" (12). Example 2: Input: \"226\" Output: 3 Explanation: It could be decoded as \"BZ\" (2 26), \"VF\" (22 6), or \"BBF\" (2 2 6).","title":"Problem"},{"location":"LeetcodeSolved/0091-decode-ways/#solution","text":"c++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 class Solution { public : int numDecodings ( string s ) { int n = s . size (); // If 0 is string then no way to decode. if ( n == 0 || s [ 0 ] == 0 ) return 0 ; if ( n == 1 ) return 1 ; // dp[i] represents how many way to decode string fron that index till last index. vector int dp ( n ); // Initialize dp[n-1] and dp[n-2] rest is easy. // Before zero must be clubbed with either 1 or 2. Like 10 or 20. // So dp[i] = 0 where zero is at i. You may think like no existance of single zero // Other than 1 and 2 then write 0 at dp[i] since wrong encoded string given. if ( s [ n - 1 ] == 0 ) dp [ n - 1 ] = 0 ; else dp [ n - 1 ] = 1 ; // If 1 or 2 and next is zero. Than only one way. if (( s [ n - 2 ] == 1 || s [ n - 2 ] == 2 ) s [ n - 1 ] == 0 ) dp [ n - 2 ] = 1 ; // Invalid encoded string case else if ( s [ n - 1 ] == 0 || s [ n - 2 ] == 0 ) dp [ n - 2 ] = 0 ; // valid number case. 10 - 26 two possible way else if ( s [ n - 2 ] == 1 || ( s [ n - 2 ] == 2 s [ n - 1 ] = 6 )) dp [ n - 2 ] = 2 ; // 3- 9 digit case else dp [ n - 2 ] = 1 ; for ( int i = n - 3 ; i = 0 ; i -- ){ // If zero incounters leave it now. \u200b","title":"Solution"},{"location":"LeetcodeSolved/0092-reverse-linked-list-ii/","text":"0092-reverse-linked-list-ii Problem Reverse a linked list from position m to n . Do it in one-pass. Note: 1 \u2264 m \u2264 n \u2264 length of list. Example: Input: 1- 2- 3- 4- 5- NULL, m = 2, n = 4 Output: 1- 4- 3- 2- 5- NULL Solution c++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 * int val ; * ListNode * next ; * ListNode ( int x ) : val ( x ), next ( NULL ) {} * }; */ class Solution { public : ListNode * reverseBetween ( ListNode * head , int m , int n ) { /* * If head is NULL or single node return it directly. * If m==n means no need of reversing. */ if ( ! head || head - next == NULL ) return head ; if ( m == n ) return head ; /* * prevTail holds tail of list before m. It is node which is connected to mth node. */ ListNode * prevTail = NULL ; ListNode * current = head ; /* * Traverse till mth node. */ for ( int i = 1 ; i m ; i ++ , prevTail = current , current = current - next ); /* * marker holds the mth node address. Its next will connect link after nth node. */ ListNode * prev = current ; ListNode * ahead = current - next ; ListNode * marker = current ; current - next = NULL ; int diff = n - m ; /* * While loop reverse the link list from m to n */ while ( diff -- ){ prev = current ; current = ahead ; ahead = ahead - next ; current - next = prev ; } /* Connect node before m to nth node. * It m = 1, prevTail will be NULL, so give head the * address of current node. Current is pointing to nth node. */ if ( prevTail ) prevTail - next = current ; else head = current ; /* * Connect mth node with node after nth node. */ marker - next = ahead ; return head ; } }; \u200b","title":"0092-reverse-linked-list-ii"},{"location":"LeetcodeSolved/0092-reverse-linked-list-ii/#0092-reverse-linked-list-ii","text":"","title":"0092-reverse-linked-list-ii"},{"location":"LeetcodeSolved/0092-reverse-linked-list-ii/#problem","text":"Reverse a linked list from position m to n . Do it in one-pass. Note: 1 \u2264 m \u2264 n \u2264 length of list. Example: Input: 1- 2- 3- 4- 5- NULL, m = 2, n = 4 Output: 1- 4- 3- 2- 5- NULL","title":"Problem"},{"location":"LeetcodeSolved/0092-reverse-linked-list-ii/#solution","text":"c++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 * int val ; * ListNode * next ; * ListNode ( int x ) : val ( x ), next ( NULL ) {} * }; */ class Solution { public : ListNode * reverseBetween ( ListNode * head , int m , int n ) { /* * If head is NULL or single node return it directly. * If m==n means no need of reversing. */ if ( ! head || head - next == NULL ) return head ; if ( m == n ) return head ; /* * prevTail holds tail of list before m. It is node which is connected to mth node. */ ListNode * prevTail = NULL ; ListNode * current = head ; /* * Traverse till mth node. */ for ( int i = 1 ; i m ; i ++ , prevTail = current , current = current - next ); /* * marker holds the mth node address. Its next will connect link after nth node. */ ListNode * prev = current ; ListNode * ahead = current - next ; ListNode * marker = current ; current - next = NULL ; int diff = n - m ; /* * While loop reverse the link list from m to n */ while ( diff -- ){ prev = current ; current = ahead ; ahead = ahead - next ; current - next = prev ; } /* Connect node before m to nth node. * It m = 1, prevTail will be NULL, so give head the * address of current node. Current is pointing to nth node. */ if ( prevTail ) prevTail - next = current ; else head = current ; /* * Connect mth node with node after nth node. */ marker - next = ahead ; return head ; } }; \u200b","title":"Solution"},{"location":"LeetcodeSolved/0094-binary-tree-inorder-traversal/","text":"0094-binary-tree-inorder-traversal Problem Given a binary tree, return the inorder traversal of its nodes' values. Example: Input: [1,null,2,3] 1 \\ 2 / 3 Output: [1,3,2] Follow up: Recursive solution is trivial, could you do it iteratively? Solution c++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 /** * Definition for a binary tree node. * struct TreeNode { * int val; * TreeNode *left; * TreeNode *right; * TreeNode(int x) : val(x), left(NULL), right(NULL) {} * }; */ class Solution { public : vector int inorderTraversal ( TreeNode * root ) { vector int result ; stack TreeNode * todo ; if ( root == NULL ) return result ; while ( root != NULL || ! todo . empty ()){ while ( root != NULL ){ todo . push ( root ); root = root - left ; } root = todo . top (); todo . pop (); result . push_back ( root - val ); root = root - right ; } return result ; } }; \u200b","title":"0094-binary-tree-inorder-traversal"},{"location":"LeetcodeSolved/0094-binary-tree-inorder-traversal/#0094-binary-tree-inorder-traversal","text":"","title":"0094-binary-tree-inorder-traversal"},{"location":"LeetcodeSolved/0094-binary-tree-inorder-traversal/#problem","text":"Given a binary tree, return the inorder traversal of its nodes' values. Example: Input: [1,null,2,3] 1 \\ 2 / 3 Output: [1,3,2] Follow up: Recursive solution is trivial, could you do it iteratively?","title":"Problem"},{"location":"LeetcodeSolved/0094-binary-tree-inorder-traversal/#solution","text":"c++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 /** * Definition for a binary tree node. * struct TreeNode { * int val; * TreeNode *left; * TreeNode *right; * TreeNode(int x) : val(x), left(NULL), right(NULL) {} * }; */ class Solution { public : vector int inorderTraversal ( TreeNode * root ) { vector int result ; stack TreeNode * todo ; if ( root == NULL ) return result ; while ( root != NULL || ! todo . empty ()){ while ( root != NULL ){ todo . push ( root ); root = root - left ; } root = todo . top (); todo . pop (); result . push_back ( root - val ); root = root - right ; } return result ; } }; \u200b","title":"Solution"},{"location":"LeetcodeSolved/0098-validate-binary-search-tree/","text":"0098-validate-binary-search-tree Problem Given a binary tree, determine if it is a valid binary search tree (BST). Assume a BST is defined as follows: The left subtree of a node contains only nodes with keys less than the node's key. The right subtree of a node contains only nodes with keys greater than the node's key. Both the left and right subtrees must also be binary search trees. Example 1: 2 / \\ 1 3 Input: [2,1,3] Output: true Example 2: 5 / \\ 1 4 / \\ 3 6 Input: [5,1,4,null,null,3,6] Output: false Explanation: The root node's value is 5 but its right child's value is 4. Solution c++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 /** * Definition for a binary tree node. * struct TreeNode { * int val; * TreeNode *left; * TreeNode *right; * TreeNode(int x) : val(x), left(NULL), right(NULL) {} * }; */ \u200b //via inorder template class Solution { public : bool isValidBST ( TreeNode * root ) { stack TreeNode * todo ; TreeNode * prev = NULL ; if ( root == NULL ) return true ; while ( root != NULL || ! todo . empty ()){ while ( root != NULL ){ todo . push ( root ); root = root - left ; } root = todo . top (); todo . pop (); if ( prev != NULL prev - val = root - val ) return false ; prev = root ; root = root - right ; } return true ; } }; \u200b","title":"0098-validate-binary-search-tree"},{"location":"LeetcodeSolved/0098-validate-binary-search-tree/#0098-validate-binary-search-tree","text":"","title":"0098-validate-binary-search-tree"},{"location":"LeetcodeSolved/0098-validate-binary-search-tree/#problem","text":"Given a binary tree, determine if it is a valid binary search tree (BST). Assume a BST is defined as follows: The left subtree of a node contains only nodes with keys less than the node's key. The right subtree of a node contains only nodes with keys greater than the node's key. Both the left and right subtrees must also be binary search trees. Example 1: 2 / \\ 1 3 Input: [2,1,3] Output: true Example 2: 5 / \\ 1 4 / \\ 3 6 Input: [5,1,4,null,null,3,6] Output: false Explanation: The root node's value is 5 but its right child's value is 4.","title":"Problem"},{"location":"LeetcodeSolved/0098-validate-binary-search-tree/#solution","text":"c++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 /** * Definition for a binary tree node. * struct TreeNode { * int val; * TreeNode *left; * TreeNode *right; * TreeNode(int x) : val(x), left(NULL), right(NULL) {} * }; */ \u200b //via inorder template class Solution { public : bool isValidBST ( TreeNode * root ) { stack TreeNode * todo ; TreeNode * prev = NULL ; if ( root == NULL ) return true ; while ( root != NULL || ! todo . empty ()){ while ( root != NULL ){ todo . push ( root ); root = root - left ; } root = todo . top (); todo . pop (); if ( prev != NULL prev - val = root - val ) return false ; prev = root ; root = root - right ; } return true ; } }; \u200b","title":"Solution"},{"location":"LeetcodeSolved/0102-binary-tree-level-order-traversal/","text":"0102-binary-tree-level-order-traversal Problem Given a binary tree, return the level order traversal of its nodes' values. (ie, from left to right, level by level). For example: Given binary tree [3,9,20,null,null,15,7] , 3 / \\ 9 20 / \\ 15 7 return its level order traversal as: [ [3], [9,20], [15,7] ] Solution c++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 /** * Definition for a binary tree node. * struct TreeNode { * int val; * TreeNode *left; * TreeNode *right; * TreeNode(int x) : val(x), left(NULL), right(NULL) {} * }; */ \u200b //Using two queue method class Solution { public : vector vector int levelOrder ( TreeNode * root ) { queue TreeNode * even , odd ; vector vector int ans ; if ( ! root ) return ans ; even . push ( root ); TreeNode * temp ; while ( ! even . empty () || ! odd . empty ()){ vector int level ; if ( odd . empty ()){ while ( ! even . empty ()){ temp = even . front (); even . pop (); level . push_back ( temp - val ); if ( temp - left ) odd . push ( temp - left ); if ( temp - right ) odd . push ( temp - right ); } } else if ( even . empty ()){ while ( ! odd . empty ()){ temp = odd . front (); odd . pop (); level . push_back ( temp - val ); if ( temp - left ) even . push ( temp - left ); if ( temp - right ) even . push ( temp - right ); } } ans . push_back ( level ); } return ans ; } }; \u200b","title":"0102-binary-tree-level-order-traversal"},{"location":"LeetcodeSolved/0102-binary-tree-level-order-traversal/#0102-binary-tree-level-order-traversal","text":"","title":"0102-binary-tree-level-order-traversal"},{"location":"LeetcodeSolved/0102-binary-tree-level-order-traversal/#problem","text":"Given a binary tree, return the level order traversal of its nodes' values. (ie, from left to right, level by level). For example: Given binary tree [3,9,20,null,null,15,7] , 3 / \\ 9 20 / \\ 15 7 return its level order traversal as: [ [3], [9,20], [15,7] ]","title":"Problem"},{"location":"LeetcodeSolved/0102-binary-tree-level-order-traversal/#solution","text":"c++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 /** * Definition for a binary tree node. * struct TreeNode { * int val; * TreeNode *left; * TreeNode *right; * TreeNode(int x) : val(x), left(NULL), right(NULL) {} * }; */ \u200b //Using two queue method class Solution { public : vector vector int levelOrder ( TreeNode * root ) { queue TreeNode * even , odd ; vector vector int ans ; if ( ! root ) return ans ; even . push ( root ); TreeNode * temp ; while ( ! even . empty () || ! odd . empty ()){ vector int level ; if ( odd . empty ()){ while ( ! even . empty ()){ temp = even . front (); even . pop (); level . push_back ( temp - val ); if ( temp - left ) odd . push ( temp - left ); if ( temp - right ) odd . push ( temp - right ); } } else if ( even . empty ()){ while ( ! odd . empty ()){ temp = odd . front (); odd . pop (); level . push_back ( temp - val ); if ( temp - left ) even . push ( temp - left ); if ( temp - right ) even . push ( temp - right ); } } ans . push_back ( level ); } return ans ; } }; \u200b","title":"Solution"},{"location":"LeetcodeSolved/0103-binary-tree-zigzag-level-order-traversal/","text":"0103-binary-tree-zigzag-level-order-traversal Problem Given a binary tree, return the zigzag level order traversal of its nodes' values. (ie, from left to right, then right to left for the next level and alternate between). For example: Given binary tree [3,9,20,null,null,15,7] , 3 / \\ 9 20 / \\ 15 7 return its zigzag level order traversal as: [ [3], [20,9], [15,7] ] Solution c++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 /** * Definition for a binary tree node. * struct TreeNode { * int val; * TreeNode *left; * TreeNode *right; * TreeNode(int x) : val(x), left(NULL), right(NULL) {} * }; */ \u200b //level order traversal with marker class Solution { public : vector vector int zigzagLevelOrder ( TreeNode * root ) { vector vector int powerset ; TreeNode * marker = new TreeNode ( INT_MIN ); if ( ! root ) return powerset ; vector int subset ; queue TreeNode * q ; int even = 1 ; q . push ( root ); q . push ( marker ); while ( ! q . empty ()){ root = q . front (); q . pop (); \u200b while ( root - val != INT_MIN ){ subset . push_back ( root - val ); if ( root - left ) q . push ( root - left ); if ( root - right ) q . push ( root - right ); root = q . front (); q . pop (); } q . push ( root ); if ( ! even ) reverse ( subset . begin (), subset . end ()); powerset . push_back ( subset ); subset = vector int (); even = ( even + 1 ) % 2 ; if ( q . front () - val == INT_MIN ) break ; } return powerset ; } }; \u200b","title":"0103-binary-tree-zigzag-level-order-traversal"},{"location":"LeetcodeSolved/0103-binary-tree-zigzag-level-order-traversal/#0103-binary-tree-zigzag-level-order-traversal","text":"","title":"0103-binary-tree-zigzag-level-order-traversal"},{"location":"LeetcodeSolved/0103-binary-tree-zigzag-level-order-traversal/#problem","text":"Given a binary tree, return the zigzag level order traversal of its nodes' values. (ie, from left to right, then right to left for the next level and alternate between). For example: Given binary tree [3,9,20,null,null,15,7] , 3 / \\ 9 20 / \\ 15 7 return its zigzag level order traversal as: [ [3], [20,9], [15,7] ]","title":"Problem"},{"location":"LeetcodeSolved/0103-binary-tree-zigzag-level-order-traversal/#solution","text":"c++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 /** * Definition for a binary tree node. * struct TreeNode { * int val; * TreeNode *left; * TreeNode *right; * TreeNode(int x) : val(x), left(NULL), right(NULL) {} * }; */ \u200b //level order traversal with marker class Solution { public : vector vector int zigzagLevelOrder ( TreeNode * root ) { vector vector int powerset ; TreeNode * marker = new TreeNode ( INT_MIN ); if ( ! root ) return powerset ; vector int subset ; queue TreeNode * q ; int even = 1 ; q . push ( root ); q . push ( marker ); while ( ! q . empty ()){ root = q . front (); q . pop (); \u200b while ( root - val != INT_MIN ){ subset . push_back ( root - val ); if ( root - left ) q . push ( root - left ); if ( root - right ) q . push ( root - right ); root = q . front (); q . pop (); } q . push ( root ); if ( ! even ) reverse ( subset . begin (), subset . end ()); powerset . push_back ( subset ); subset = vector int (); even = ( even + 1 ) % 2 ; if ( q . front () - val == INT_MIN ) break ; } return powerset ; } }; \u200b","title":"Solution"},{"location":"LeetcodeSolved/0105-construct-binary-tree-from-preorder-and-inorder-traversal/","text":"0105-construct-binary-tree-from-preorder-and-inorder-traversal Problem Given preorder and inorder traversal of a tree, construct the binary tree. Note: You may assume that duplicates do not exist in the tree. For example, given preorder = [3,9,20,15,7] inorder = [9,3,15,20,7] Return the following binary tree: 3 / \\ 9 20 / \\ 15 7 Solution c++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 /** * Definition for a binary tree node. * struct TreeNode { * int val; * TreeNode *left; * TreeNode *right; * TreeNode(int x) : val(x), left(NULL), right(NULL) {} * }; */ class Solution { public : TreeNode * buildTree ( vector int preorder , vector int inorder ) { if ( inorder . empty () || preorder . empty ()) return nullptr ; unordered_map int , int m ; for ( int i = 0 ; i inorder . size (); i ++ ){ m [ inorder [ i ]] = i ; } return construct ( preorder , inorder , m , 0 , inorder . size () - 1 , 0 ); } TreeNode * construct ( vector int preorder , vector int inorder , unordered_map int , int m , int start , int end , int node ){ if ( start == end ){ return ( new TreeNode ( inorder [ start ])); } if ( node == preorder . size ()) return nullptr ; int rootPos = m [ preorder [ node ]]; if ( rootPos start || rootPos end ){ return construct ( preorder , inorder , m , start , end , node + 1 ); } TreeNode * root = new TreeNode ( preorder [ node ]); root - left = construct ( preorder , inorder , m , start , rootPos - 1 , node + 1 ); root - right = construct ( preorder , inorder , m , rootPos + 1 , end , node + 1 ); return root ; } }; \u200b","title":"0105-construct-binary-tree-from-preorder-and-inorder-traversal"},{"location":"LeetcodeSolved/0105-construct-binary-tree-from-preorder-and-inorder-traversal/#0105-construct-binary-tree-from-preorder-and-inorder-traversal","text":"","title":"0105-construct-binary-tree-from-preorder-and-inorder-traversal"},{"location":"LeetcodeSolved/0105-construct-binary-tree-from-preorder-and-inorder-traversal/#problem","text":"Given preorder and inorder traversal of a tree, construct the binary tree. Note: You may assume that duplicates do not exist in the tree. For example, given preorder = [3,9,20,15,7] inorder = [9,3,15,20,7] Return the following binary tree: 3 / \\ 9 20 / \\ 15 7","title":"Problem"},{"location":"LeetcodeSolved/0105-construct-binary-tree-from-preorder-and-inorder-traversal/#solution","text":"c++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 /** * Definition for a binary tree node. * struct TreeNode { * int val; * TreeNode *left; * TreeNode *right; * TreeNode(int x) : val(x), left(NULL), right(NULL) {} * }; */ class Solution { public : TreeNode * buildTree ( vector int preorder , vector int inorder ) { if ( inorder . empty () || preorder . empty ()) return nullptr ; unordered_map int , int m ; for ( int i = 0 ; i inorder . size (); i ++ ){ m [ inorder [ i ]] = i ; } return construct ( preorder , inorder , m , 0 , inorder . size () - 1 , 0 ); } TreeNode * construct ( vector int preorder , vector int inorder , unordered_map int , int m , int start , int end , int node ){ if ( start == end ){ return ( new TreeNode ( inorder [ start ])); } if ( node == preorder . size ()) return nullptr ; int rootPos = m [ preorder [ node ]]; if ( rootPos start || rootPos end ){ return construct ( preorder , inorder , m , start , end , node + 1 ); } TreeNode * root = new TreeNode ( preorder [ node ]); root - left = construct ( preorder , inorder , m , start , rootPos - 1 , node + 1 ); root - right = construct ( preorder , inorder , m , rootPos + 1 , end , node + 1 ); return root ; } }; \u200b","title":"Solution"},{"location":"LeetcodeSolved/0106-construct-binary-tree-from-inorder-and-postorder-traversal/","text":"0106-construct-binary-tree-from-inorder-and-postorder-traversal Problem Given inorder and postorder traversal of a tree, construct the binary tree. Note: You may assume that duplicates do not exist in the tree. For example, given inorder = [9,3,15,20,7] postorder = [9,15,7,20,3] Return the following binary tree: 3 / \\ 9 20 / \\ 15 7 Solution c++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 /** * Definition for a binary tree node. * struct TreeNode { * int val; * TreeNode *left; * TreeNode *right; * TreeNode(int x) : val(x), left(NULL), right(NULL) {} * }; */ \u200b // Finding in inorder can be done easily with map class Solution { public : TreeNode * buildTree ( vector int inorder , vector int postorder ) { //helper function return makeTree ( inorder , 0 , inorder . size () - 1 , postorder , postorder . size () - 1 ); } TreeNode * makeTree ( vector int inorder , int start , int last , vector int postorder , int pos ){ // If only one node in subtree if ( start == last ){ TreeNode * root = new TreeNode ( inorder [ start ]); return root ; } if ( start last ) return NULL ; // reached till every root if ( pos 0 ) return NULL ; // It stores index of root in inorder path int rootPos = - 1 ; // Since postorder[pos] may contain root in either left or right subtree // So we keep checking we didn t find root in our subtree while ( pos = 0 rootPos == - 1 ){ \u200b","title":"0106-construct-binary-tree-from-inorder-and-postorder-traversal"},{"location":"LeetcodeSolved/0106-construct-binary-tree-from-inorder-and-postorder-traversal/#0106-construct-binary-tree-from-inorder-and-postorder-traversal","text":"","title":"0106-construct-binary-tree-from-inorder-and-postorder-traversal"},{"location":"LeetcodeSolved/0106-construct-binary-tree-from-inorder-and-postorder-traversal/#problem","text":"Given inorder and postorder traversal of a tree, construct the binary tree. Note: You may assume that duplicates do not exist in the tree. For example, given inorder = [9,3,15,20,7] postorder = [9,15,7,20,3] Return the following binary tree: 3 / \\ 9 20 / \\ 15 7","title":"Problem"},{"location":"LeetcodeSolved/0106-construct-binary-tree-from-inorder-and-postorder-traversal/#solution","text":"c++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 /** * Definition for a binary tree node. * struct TreeNode { * int val; * TreeNode *left; * TreeNode *right; * TreeNode(int x) : val(x), left(NULL), right(NULL) {} * }; */ \u200b // Finding in inorder can be done easily with map class Solution { public : TreeNode * buildTree ( vector int inorder , vector int postorder ) { //helper function return makeTree ( inorder , 0 , inorder . size () - 1 , postorder , postorder . size () - 1 ); } TreeNode * makeTree ( vector int inorder , int start , int last , vector int postorder , int pos ){ // If only one node in subtree if ( start == last ){ TreeNode * root = new TreeNode ( inorder [ start ]); return root ; } if ( start last ) return NULL ; // reached till every root if ( pos 0 ) return NULL ; // It stores index of root in inorder path int rootPos = - 1 ; // Since postorder[pos] may contain root in either left or right subtree // So we keep checking we didn t find root in our subtree while ( pos = 0 rootPos == - 1 ){ \u200b","title":"Solution"},{"location":"LeetcodeSolved/0114-flatten-binary-tree-to-linked-list/","text":"0114-flatten-binary-tree-to-linked-list Problem Given a binary tree, flatten it to a linked list in-place. For example, given the following tree: 1 / \\ 2 5 / \\ \\ 3 4 6 The flattened tree should look like: 1 \\ 2 \\ 3 \\ 4 \\ 5 \\ 6 Solution c++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 /* * @lc app=leetcode id=114 lang=cpp * * [114] Flatten Binary Tree to Linked List */ /** * Definition for a binary tree node. * struct TreeNode { * int val; * TreeNode *left; * TreeNode *right; * TreeNode(int x) : val(x), left(NULL), right(NULL) {} * }; */ \u200b //root s left is child and right is next node class Solution { public : void flatten ( TreeNode * p ) { while ( p ){ if ( p - left == NULL ){ p = p - right ; continue ; } \u200b TreeNode * tmp = p - left ; while ( tmp - right ) tmp = tmp - right ; tmp - right = p - right ; p - right = p - left ; p - left = NULL ; p = p - right ; } } }; \u200b \u200b \u200b","title":"0114-flatten-binary-tree-to-linked-list"},{"location":"LeetcodeSolved/0114-flatten-binary-tree-to-linked-list/#0114-flatten-binary-tree-to-linked-list","text":"","title":"0114-flatten-binary-tree-to-linked-list"},{"location":"LeetcodeSolved/0114-flatten-binary-tree-to-linked-list/#problem","text":"Given a binary tree, flatten it to a linked list in-place. For example, given the following tree: 1 / \\ 2 5 / \\ \\ 3 4 6 The flattened tree should look like: 1 \\ 2 \\ 3 \\ 4 \\ 5 \\ 6","title":"Problem"},{"location":"LeetcodeSolved/0114-flatten-binary-tree-to-linked-list/#solution","text":"c++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 /* * @lc app=leetcode id=114 lang=cpp * * [114] Flatten Binary Tree to Linked List */ /** * Definition for a binary tree node. * struct TreeNode { * int val; * TreeNode *left; * TreeNode *right; * TreeNode(int x) : val(x), left(NULL), right(NULL) {} * }; */ \u200b //root s left is child and right is next node class Solution { public : void flatten ( TreeNode * p ) { while ( p ){ if ( p - left == NULL ){ p = p - right ; continue ; } \u200b TreeNode * tmp = p - left ; while ( tmp - right ) tmp = tmp - right ; tmp - right = p - right ; p - right = p - left ; p - left = NULL ; p = p - right ; } } }; \u200b \u200b \u200b","title":"Solution"},{"location":"LeetcodeSolved/0117-populating-next-right-pointers-in-each-node-ii/","text":"0117-populating-next-right-pointers-in-each-node-ii Problem Given a binary tree struct Node { int val; Node left; Node right; Node *next; } Populate each next pointer to point to its next right node. If there is no next right node, the next pointer should be set to NULL . Initially, all next pointers are set to NULL . Example: Input: {\"$id\":\"1\",\"left\":{\"$id\":\"2\",\"left\":{\"$id\":\"3\",\"left\":null,\"next\":null,\"right\":null,\"val\":4},\"next\":null,\"right\":{\"$id\":\"4\",\"left\":null,\"next\":null,\"right\":null,\"val\":5},\"val\":2},\"next\":null,\"right\":{\"$id\":\"5\",\"left\":null,\"next\":null,\"right\":{\"$id\":\"6\",\"left\":null,\"next\":null,\"right\":null,\"val\":7},\"val\":3},\"val\":1} Output: {\"$id\":\"1\",\"left\":{\"$id\":\"2\",\"left\":{\"$id\":\"3\",\"left\":null,\"next\":{\"$id\":\"4\",\"left\":null,\"next\":{\"$id\":\"5\",\"left\":null,\"next\":null,\"right\":null,\"val\":7},\"right\":null,\"val\":5},\"right\":null,\"val\":4},\"next\":{\"$id\":\"6\",\"left\":null,\"next\":null,\"right\":{\"$ref\":\"5\"},\"val\":3},\"right\":{\"$ref\":\"4\"},\"val\":2},\"next\":null,\"right\":{\"$ref\":\"6\"},\"val\":1} Explanation: Given the above binary tree (Figure A), your function should populate each next pointer to point to its next right node, just like in Figure B. Note: You may only use constant extra space. Recursive approach is fine, implicit stack space does not count as extra space for this problem. Solution c++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 /* // Definition for a Node. class Node { public: int val; Node* left; Node* right; Node* next; \u200b Node() {} \u200b Node(int _val, Node* _left, Node* _right, Node* _next) { val = _val; left = _left; right = _right; next = _next; } }; */ class Solution { public : Node * connect ( Node * root ) { Node * head = NULL , * pre = NULL , * curr = root ; while ( curr ){ //levelwise while ( curr ){ //In a level if ( pre ){ if ( curr - left ){ pre - next = curr - left ; pre = pre - next ; } if ( curr - right ){ pre - next = curr - right ; pre = pre - next ; } } else { if ( curr - left head == nullptr ) head = curr - left ; if ( curr - right head == nullptr ) head = curr - right ; pre = head ; if ( curr - left curr - right ){ pre - next = curr - right ; pre = pre - next ; } } curr = curr - next ; } pre = NULL ; curr = head ; head = NULL ; } return root ; } }; \u200b","title":"0117-populating-next-right-pointers-in-each-node-ii"},{"location":"LeetcodeSolved/0117-populating-next-right-pointers-in-each-node-ii/#0117-populating-next-right-pointers-in-each-node-ii","text":"","title":"0117-populating-next-right-pointers-in-each-node-ii"},{"location":"LeetcodeSolved/0117-populating-next-right-pointers-in-each-node-ii/#problem","text":"Given a binary tree struct Node { int val; Node left; Node right; Node *next; } Populate each next pointer to point to its next right node. If there is no next right node, the next pointer should be set to NULL . Initially, all next pointers are set to NULL . Example: Input: {\"$id\":\"1\",\"left\":{\"$id\":\"2\",\"left\":{\"$id\":\"3\",\"left\":null,\"next\":null,\"right\":null,\"val\":4},\"next\":null,\"right\":{\"$id\":\"4\",\"left\":null,\"next\":null,\"right\":null,\"val\":5},\"val\":2},\"next\":null,\"right\":{\"$id\":\"5\",\"left\":null,\"next\":null,\"right\":{\"$id\":\"6\",\"left\":null,\"next\":null,\"right\":null,\"val\":7},\"val\":3},\"val\":1} Output: {\"$id\":\"1\",\"left\":{\"$id\":\"2\",\"left\":{\"$id\":\"3\",\"left\":null,\"next\":{\"$id\":\"4\",\"left\":null,\"next\":{\"$id\":\"5\",\"left\":null,\"next\":null,\"right\":null,\"val\":7},\"right\":null,\"val\":5},\"right\":null,\"val\":4},\"next\":{\"$id\":\"6\",\"left\":null,\"next\":null,\"right\":{\"$ref\":\"5\"},\"val\":3},\"right\":{\"$ref\":\"4\"},\"val\":2},\"next\":null,\"right\":{\"$ref\":\"6\"},\"val\":1} Explanation: Given the above binary tree (Figure A), your function should populate each next pointer to point to its next right node, just like in Figure B. Note: You may only use constant extra space. Recursive approach is fine, implicit stack space does not count as extra space for this problem.","title":"Problem"},{"location":"LeetcodeSolved/0117-populating-next-right-pointers-in-each-node-ii/#solution","text":"c++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 /* // Definition for a Node. class Node { public: int val; Node* left; Node* right; Node* next; \u200b Node() {} \u200b Node(int _val, Node* _left, Node* _right, Node* _next) { val = _val; left = _left; right = _right; next = _next; } }; */ class Solution { public : Node * connect ( Node * root ) { Node * head = NULL , * pre = NULL , * curr = root ; while ( curr ){ //levelwise while ( curr ){ //In a level if ( pre ){ if ( curr - left ){ pre - next = curr - left ; pre = pre - next ; } if ( curr - right ){ pre - next = curr - right ; pre = pre - next ; } } else { if ( curr - left head == nullptr ) head = curr - left ; if ( curr - right head == nullptr ) head = curr - right ; pre = head ; if ( curr - left curr - right ){ pre - next = curr - right ; pre = pre - next ; } } curr = curr - next ; } pre = NULL ; curr = head ; head = NULL ; } return root ; } }; \u200b","title":"Solution"},{"location":"LeetcodeSolved/0124-binary-tree-maximum-path-sum/","text":"0124-binary-tree-maximum-path-sum Problem Given a non-empty binary tree, find the maximum path sum. For this problem, a path is defined as any sequence of nodes from some starting node to any node in the tree along the parent-child connections. The path must contain at least one node and does not need to go through the root. Example 1: Input: [1,2,3] 1 / \\ 2 3 Output: 6 Example 2: Input: [-10,9,20,null,null,15,7] -10 / \\ 9 20 / \\ 15 7 Output: 42 Solution c++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 /** * Definition for a binary tree node. * struct TreeNode { * int val; * TreeNode *left; * TreeNode *right; * TreeNode(int x) : val(x), left(NULL), right(NULL) {} * }; */ class Solution { int globalMax ; public : int maxPathSum ( TreeNode * root ) { if ( root == NULL ) return 0 ; globalMax = INT_MIN ; int res = maxPath ( root ); return max ( res , globalMax ); } int maxPath ( TreeNode * root ){ if ( root == NULL ) return 0 ; int curr = root - val ; int left = maxPath ( root - left ); int right = maxPath ( root - right ); int maxSum = max ({ curr , curr + left , curr + right }); globalMax = max ({ maxSum , curr + left + right , globalMax }); return maxSum ; } }; \u200b","title":"0124-binary-tree-maximum-path-sum"},{"location":"LeetcodeSolved/0124-binary-tree-maximum-path-sum/#0124-binary-tree-maximum-path-sum","text":"","title":"0124-binary-tree-maximum-path-sum"},{"location":"LeetcodeSolved/0124-binary-tree-maximum-path-sum/#problem","text":"Given a non-empty binary tree, find the maximum path sum. For this problem, a path is defined as any sequence of nodes from some starting node to any node in the tree along the parent-child connections. The path must contain at least one node and does not need to go through the root. Example 1: Input: [1,2,3] 1 / \\ 2 3 Output: 6 Example 2: Input: [-10,9,20,null,null,15,7] -10 / \\ 9 20 / \\ 15 7 Output: 42","title":"Problem"},{"location":"LeetcodeSolved/0124-binary-tree-maximum-path-sum/#solution","text":"c++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 /** * Definition for a binary tree node. * struct TreeNode { * int val; * TreeNode *left; * TreeNode *right; * TreeNode(int x) : val(x), left(NULL), right(NULL) {} * }; */ class Solution { int globalMax ; public : int maxPathSum ( TreeNode * root ) { if ( root == NULL ) return 0 ; globalMax = INT_MIN ; int res = maxPath ( root ); return max ( res , globalMax ); } int maxPath ( TreeNode * root ){ if ( root == NULL ) return 0 ; int curr = root - val ; int left = maxPath ( root - left ); int right = maxPath ( root - right ); int maxSum = max ({ curr , curr + left , curr + right }); globalMax = max ({ maxSum , curr + left + right , globalMax }); return maxSum ; } }; \u200b","title":"Solution"},{"location":"LeetcodeSolved/0133-clone-graph/","text":"0133-clone-graph Problem Given a reference of a node in a connected undirected graph, return a deep copy (clone) of the graph. Each node in the graph contains a val ( int ) and a list ( List[Node] ) of its neighbors. Example: Input: {\"$id\":\"1\",\"neighbors\":[{\"$id\":\"2\",\"neighbors\":[{\"$ref\":\"1\"},{\"$id\":\"3\",\"neighbors\":[{\"$ref\":\"2\"},{\"$id\":\"4\",\"neighbors\":[{\"$ref\":\"3\"},{\"$ref\":\"1\"}],\"val\":4}],\"val\":3}],\"val\":2},{\"$ref\":\"4\"}],\"val\":1} Explanation: Node 1's value is 1, and it has two neighbors: Node 2 and 4. Node 2's value is 2, and it has two neighbors: Node 1 and 3. Node 3's value is 3, and it has two neighbors: Node 2 and 4. Node 4's value is 4, and it has two neighbors: Node 1 and 3. Note: The number of nodes will be between 1 and 100. The undirected graph is a simple graph , which means no repeated edges and no self-loops in the graph. Since the graph is undirected, if node p has node q as neighbor, then node q must have node p as neighbor too. You must return the copy of the given node as a reference to the cloned graph. Solution c++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 /* // Definition for a Node. class Node { public: int val; vector Node* neighbors; \u200b Node() {} \u200b Node(int _val, vector Node* _neighbors) { val = _val; neighbors = _neighbors; } }; */ class Solution { unordered_map Node * , Node * m ; public : Node * cloneGraph ( Node * node ) { Node * root = new Node ( node - val ); m [ node ] = root ; for ( auto n : node - neighbors ){ if ( m . count ( n ) == 0 ) root - neighbors . push_back ( cloneGraph ( n )); else root - neighbors . push_back ( m [ n ]); } return root ; } }; \u200b","title":"0133-clone-graph"},{"location":"LeetcodeSolved/0133-clone-graph/#0133-clone-graph","text":"","title":"0133-clone-graph"},{"location":"LeetcodeSolved/0133-clone-graph/#problem","text":"Given a reference of a node in a connected undirected graph, return a deep copy (clone) of the graph. Each node in the graph contains a val ( int ) and a list ( List[Node] ) of its neighbors. Example: Input: {\"$id\":\"1\",\"neighbors\":[{\"$id\":\"2\",\"neighbors\":[{\"$ref\":\"1\"},{\"$id\":\"3\",\"neighbors\":[{\"$ref\":\"2\"},{\"$id\":\"4\",\"neighbors\":[{\"$ref\":\"3\"},{\"$ref\":\"1\"}],\"val\":4}],\"val\":3}],\"val\":2},{\"$ref\":\"4\"}],\"val\":1} Explanation: Node 1's value is 1, and it has two neighbors: Node 2 and 4. Node 2's value is 2, and it has two neighbors: Node 1 and 3. Node 3's value is 3, and it has two neighbors: Node 2 and 4. Node 4's value is 4, and it has two neighbors: Node 1 and 3. Note: The number of nodes will be between 1 and 100. The undirected graph is a simple graph , which means no repeated edges and no self-loops in the graph. Since the graph is undirected, if node p has node q as neighbor, then node q must have node p as neighbor too. You must return the copy of the given node as a reference to the cloned graph.","title":"Problem"},{"location":"LeetcodeSolved/0133-clone-graph/#solution","text":"c++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 /* // Definition for a Node. class Node { public: int val; vector Node* neighbors; \u200b Node() {} \u200b Node(int _val, vector Node* _neighbors) { val = _val; neighbors = _neighbors; } }; */ class Solution { unordered_map Node * , Node * m ; public : Node * cloneGraph ( Node * node ) { Node * root = new Node ( node - val ); m [ node ] = root ; for ( auto n : node - neighbors ){ if ( m . count ( n ) == 0 ) root - neighbors . push_back ( cloneGraph ( n )); else root - neighbors . push_back ( m [ n ]); } return root ; } }; \u200b","title":"Solution"},{"location":"LeetcodeSolved/0139-word-break/","text":"0139-word-break Problem Given a non-empty string s and a dictionary wordDict containing a list of non-empty words, determine if s can be segmented into a space-separated sequence of one or more dictionary words. Note: The same word in the dictionary may be reused multiple times in the segmentation. You may assume the dictionary does not contain duplicate words. Example 1: Input: s = \"leetcode\", wordDict = [\"leet\", \"code\"] Output: true Explanation: Return true because \"leetcode\" can be segmented as \"leet code\" . Example 2: Input: s = \"applepenapple\", wordDict = [\"apple\", \"pen\"] Output: true Explanation: Return true because \" applepenapple \" can be segmented as \" apple pen apple \" . Note that you are allowed to reuse a dictionary word. Example 3: Input: s = \"catsandog\", wordDict = [\"cats\", \"dog\", \"sand\", \"and\", \"cat\"] Output: false Solution c++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 class Solution { public : bool wordBreak ( string s , vector string wordDict ) { vector int table ( s . size (), - 1 ); if ( isSegmented ( s , wordDict , table , 0 )) return true ; return false ; } }; \u200b int isSegmented ( string s , vector string wordDict , vector int table , int start ){ if ( start == s . size ()) return true ; if ( start s . size ()) return false ; if ( table [ start ] != - 1 ) return table [ start ]; int tempRes ; for ( int i = 0 ; i wordDict . size (); i ++ ){ int lenS = s . size () - start ; if ( lenS = wordDict [ i ]. size ()){ if ( s . substr ( start , wordDict [ i ]. size ()) == wordDict [ i ]){ tempRes = isSegmented ( s , wordDict , table , start + wordDict [ i ]. size ()); if ( tempRes == 1 ){ return table [ start ] = 1 ; } } } } return table [ start ] = 0 ; } \u200b","title":"0139-word-break"},{"location":"LeetcodeSolved/0139-word-break/#0139-word-break","text":"","title":"0139-word-break"},{"location":"LeetcodeSolved/0139-word-break/#problem","text":"Given a non-empty string s and a dictionary wordDict containing a list of non-empty words, determine if s can be segmented into a space-separated sequence of one or more dictionary words. Note: The same word in the dictionary may be reused multiple times in the segmentation. You may assume the dictionary does not contain duplicate words. Example 1: Input: s = \"leetcode\", wordDict = [\"leet\", \"code\"] Output: true Explanation: Return true because \"leetcode\" can be segmented as \"leet code\" . Example 2: Input: s = \"applepenapple\", wordDict = [\"apple\", \"pen\"] Output: true Explanation: Return true because \" applepenapple \" can be segmented as \" apple pen apple \" . Note that you are allowed to reuse a dictionary word. Example 3: Input: s = \"catsandog\", wordDict = [\"cats\", \"dog\", \"sand\", \"and\", \"cat\"] Output: false","title":"Problem"},{"location":"LeetcodeSolved/0139-word-break/#solution","text":"c++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 class Solution { public : bool wordBreak ( string s , vector string wordDict ) { vector int table ( s . size (), - 1 ); if ( isSegmented ( s , wordDict , table , 0 )) return true ; return false ; } }; \u200b int isSegmented ( string s , vector string wordDict , vector int table , int start ){ if ( start == s . size ()) return true ; if ( start s . size ()) return false ; if ( table [ start ] != - 1 ) return table [ start ]; int tempRes ; for ( int i = 0 ; i wordDict . size (); i ++ ){ int lenS = s . size () - start ; if ( lenS = wordDict [ i ]. size ()){ if ( s . substr ( start , wordDict [ i ]. size ()) == wordDict [ i ]){ tempRes = isSegmented ( s , wordDict , table , start + wordDict [ i ]. size ()); if ( tempRes == 1 ){ return table [ start ] = 1 ; } } } } return table [ start ] = 0 ; } \u200b","title":"Solution"},{"location":"LeetcodeSolved/0142-linked-list-cycle-ii/","text":"0142-linked-list-cycle-ii Problem Given a linked list, return the node where the cycle begins. If there is no cycle, return null . To represent a cycle in the given linked list, we use an integer pos which represents the position (0-indexed) in the linked list where tail connects to. If pos is -1 , then there is no cycle in the linked list. Note: Do not modify the linked list. Example 1: Input: head = [3,2,0,-4], pos = 1 Output: tail connects to node index 1 Explanation: There is a cycle in the linked list, where tail connects to the second node. Example 2: Input: head = [1,2], pos = 0 Output: tail connects to node index 0 Explanation: There is a cycle in the linked list, where tail connects to the first node. Example 3: Input: head = [1], pos = -1 Output: no cycle Explanation: There is no cycle in the linked list. Follow up : Can you solve it without using extra space? Solution c++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 /** * Definition for singly-linked list. * struct ListNode { * int val; * ListNode *next; * ListNode(int x) : val(x), next(NULL) {} * }; */ class Solution { public : ListNode * detectCycle ( ListNode * head ) { if ( head == NULL ) return head ; ListNode * walker = head ; ListNode * runner = head ; int flag = 0 ; while ( runner runner - next ){ walker = walker - next ; runner = runner - next - next ; if ( walker == runner ){ flag = 1 ; break ; } } if ( flag ){ while ( head != walker ){ head = head - next ; walker = walker - next ; } return head ; } return NULL ; } }; \u200b","title":"0142-linked-list-cycle-ii"},{"location":"LeetcodeSolved/0142-linked-list-cycle-ii/#0142-linked-list-cycle-ii","text":"","title":"0142-linked-list-cycle-ii"},{"location":"LeetcodeSolved/0142-linked-list-cycle-ii/#problem","text":"Given a linked list, return the node where the cycle begins. If there is no cycle, return null . To represent a cycle in the given linked list, we use an integer pos which represents the position (0-indexed) in the linked list where tail connects to. If pos is -1 , then there is no cycle in the linked list. Note: Do not modify the linked list. Example 1: Input: head = [3,2,0,-4], pos = 1 Output: tail connects to node index 1 Explanation: There is a cycle in the linked list, where tail connects to the second node. Example 2: Input: head = [1,2], pos = 0 Output: tail connects to node index 0 Explanation: There is a cycle in the linked list, where tail connects to the first node. Example 3: Input: head = [1], pos = -1 Output: no cycle Explanation: There is no cycle in the linked list. Follow up : Can you solve it without using extra space?","title":"Problem"},{"location":"LeetcodeSolved/0142-linked-list-cycle-ii/#solution","text":"c++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 /** * Definition for singly-linked list. * struct ListNode { * int val; * ListNode *next; * ListNode(int x) : val(x), next(NULL) {} * }; */ class Solution { public : ListNode * detectCycle ( ListNode * head ) { if ( head == NULL ) return head ; ListNode * walker = head ; ListNode * runner = head ; int flag = 0 ; while ( runner runner - next ){ walker = walker - next ; runner = runner - next - next ; if ( walker == runner ){ flag = 1 ; break ; } } if ( flag ){ while ( head != walker ){ head = head - next ; walker = walker - next ; } return head ; } return NULL ; } }; \u200b","title":"Solution"},{"location":"LeetcodeSolved/0143-reorder-list/","text":"0143-reorder-list Problem Given a singly linked list L : L 0 \u2192 L 1 \u2192\u2026\u2192 L n -1 \u2192 L n , reorder it to: L 0 \u2192 L n \u2192 L 1 \u2192 L n -1 \u2192 L 2 \u2192 L n -2 \u2192\u2026 You may not modify the values in the list's nodes, only nodes itself may be changed. Example 1: Given 1- 2- 3- 4, reorder it to 1- 4- 2- 3. Example 2: Given 1- 2- 3- 4- 5, reorder it to 1- 5- 2- 4- 3. Solution c++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 /** * Definition for singly-linked list. * struct ListNode { * int val; * ListNode *next; * ListNode(int x) : val(x), next(NULL) {} * }; */ class Solution { public : void reorderList ( ListNode * head ) { if ( ! head ) return ; ListNode * p = head ; ListNode * q = getMidNode ( head ); q = reverseList ( q ); mergeList ( p , q ); } ListNode * getMidNode ( ListNode * head ){ ListNode * slow = head , * fast = head ; while ( slow fast fast - next fast - next - next ){ slow = slow - next ; fast = fast - next - next ; } ListNode * mid = slow - next ; slow - next = nullptr ; return mid ; } ListNode * reverseList ( ListNode * root ){ ListNode * prev = NULL , * next = root , * curr = root ; while ( curr ){ next = curr - next ; curr - next = prev ; prev = curr ; curr = next ; } return prev ; // returning head of reversed list } void mergeList ( ListNode * p , ListNode * q ){ ListNode * tmp ; while ( q ){ tmp = p - next ; // store address of next p - next = q ; // link to 2nd list q = q - next ; // increase 2nd list pointer p = p - next ; p - next = tmp ; // link to 1st list p = p - next ; // increase 1st list pointer } } \u200b","title":"0143-reorder-list"},{"location":"LeetcodeSolved/0143-reorder-list/#0143-reorder-list","text":"","title":"0143-reorder-list"},{"location":"LeetcodeSolved/0143-reorder-list/#problem","text":"Given a singly linked list L : L 0 \u2192 L 1 \u2192\u2026\u2192 L n -1 \u2192 L n , reorder it to: L 0 \u2192 L n \u2192 L 1 \u2192 L n -1 \u2192 L 2 \u2192 L n -2 \u2192\u2026 You may not modify the values in the list's nodes, only nodes itself may be changed. Example 1: Given 1- 2- 3- 4, reorder it to 1- 4- 2- 3. Example 2: Given 1- 2- 3- 4- 5, reorder it to 1- 5- 2- 4- 3.","title":"Problem"},{"location":"LeetcodeSolved/0143-reorder-list/#solution","text":"c++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 /** * Definition for singly-linked list. * struct ListNode { * int val; * ListNode *next; * ListNode(int x) : val(x), next(NULL) {} * }; */ class Solution { public : void reorderList ( ListNode * head ) { if ( ! head ) return ; ListNode * p = head ; ListNode * q = getMidNode ( head ); q = reverseList ( q ); mergeList ( p , q ); } ListNode * getMidNode ( ListNode * head ){ ListNode * slow = head , * fast = head ; while ( slow fast fast - next fast - next - next ){ slow = slow - next ; fast = fast - next - next ; } ListNode * mid = slow - next ; slow - next = nullptr ; return mid ; } ListNode * reverseList ( ListNode * root ){ ListNode * prev = NULL , * next = root , * curr = root ; while ( curr ){ next = curr - next ; curr - next = prev ; prev = curr ; curr = next ; } return prev ; // returning head of reversed list } void mergeList ( ListNode * p , ListNode * q ){ ListNode * tmp ; while ( q ){ tmp = p - next ; // store address of next p - next = q ; // link to 2nd list q = q - next ; // increase 2nd list pointer p = p - next ; p - next = tmp ; // link to 1st list p = p - next ; // increase 1st list pointer } } \u200b","title":"Solution"},{"location":"LeetcodeSolved/0146-lru-cache/","text":"0146-lru-cache Problem Design and implement a data structure for Least Recently Used (LRU) cache . It should support the following operations: get and put . get(key) - Get the value (will always be positive) of the key if the key exists in the cache, otherwise return -1. put(key, value) - Set or insert the value if the key is not already present. When the cache reached its capacity, it should invalidate the least recently used item before inserting a new item. The cache is initialized with a positive capacity. Follow up: Could you do both operations in O(1) time complexity? Example: LRUCache cache = new LRUCache( 2 / capacity / ); cache.put(1, 1); cache.put(2, 2); cache.get(1); // returns 1 cache.put(3, 3); // evicts key 2 cache.get(2); // returns -1 (not found) cache.put(4, 4); // evicts key 1 cache.get(1); // returns -1 (not found) cache.get(3); // returns 3 cache.get(4); // returns 4 Solution c++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 class LRUCache { private : typedef list int LI ; //Contains KEy typedef pair int , list int :: iterator PII ; // Contains value and iterator to key in list typedef unordered_map int , PII HMIP ; // maps key to pair LI chain ; HMIP hash ; int _capacity ; void touch ( HMIP :: iterator it ){ // it is iterator to hash hold {key,{valuee,keyIterator}} chain . erase ( it - second . second ); //Removing key Node holding address iterator from chain chain . push_front ( it - first ); //Pushing key in front of list it - second . second = chain . begin (); // Chaning } public : LRUCache ( int capacity ) { _capacity = capacity ; } int get ( int key ) { auto it = hash . find ( key ); if ( it != hash . end ()){ touch ( it ); return it - second . first ; } return - 1 ; } void put ( int key , int value ) { auto it = hash . find ( key ); if ( it != hash . end ()){ //If key exit in hash then change its value touch ( it ); it - second . first = value ; return ; } if ( chain . size () == _capacity ){ int toDel = chain . back (); hash . erase ( hash . find ( toDel )); //delete entry in hash chain . pop_back (); } if ( chain . size () _capacity ){ chain . push_front ( key ); hash [ key ] = { value , chain . begin ()}; } } }; \u200b /** * Your LRUCache object will be instantiated and called as such: * LRUCache* obj = new LRUCache(capacity); * int param_1 = obj- get(key); * obj- put(key,value); */ \u200b","title":"0146-lru-cache"},{"location":"LeetcodeSolved/0146-lru-cache/#0146-lru-cache","text":"","title":"0146-lru-cache"},{"location":"LeetcodeSolved/0146-lru-cache/#problem","text":"Design and implement a data structure for Least Recently Used (LRU) cache . It should support the following operations: get and put . get(key) - Get the value (will always be positive) of the key if the key exists in the cache, otherwise return -1. put(key, value) - Set or insert the value if the key is not already present. When the cache reached its capacity, it should invalidate the least recently used item before inserting a new item. The cache is initialized with a positive capacity. Follow up: Could you do both operations in O(1) time complexity? Example: LRUCache cache = new LRUCache( 2 / capacity / ); cache.put(1, 1); cache.put(2, 2); cache.get(1); // returns 1 cache.put(3, 3); // evicts key 2 cache.get(2); // returns -1 (not found) cache.put(4, 4); // evicts key 1 cache.get(1); // returns -1 (not found) cache.get(3); // returns 3 cache.get(4); // returns 4","title":"Problem"},{"location":"LeetcodeSolved/0146-lru-cache/#solution","text":"c++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 class LRUCache { private : typedef list int LI ; //Contains KEy typedef pair int , list int :: iterator PII ; // Contains value and iterator to key in list typedef unordered_map int , PII HMIP ; // maps key to pair LI chain ; HMIP hash ; int _capacity ; void touch ( HMIP :: iterator it ){ // it is iterator to hash hold {key,{valuee,keyIterator}} chain . erase ( it - second . second ); //Removing key Node holding address iterator from chain chain . push_front ( it - first ); //Pushing key in front of list it - second . second = chain . begin (); // Chaning } public : LRUCache ( int capacity ) { _capacity = capacity ; } int get ( int key ) { auto it = hash . find ( key ); if ( it != hash . end ()){ touch ( it ); return it - second . first ; } return - 1 ; } void put ( int key , int value ) { auto it = hash . find ( key ); if ( it != hash . end ()){ //If key exit in hash then change its value touch ( it ); it - second . first = value ; return ; } if ( chain . size () == _capacity ){ int toDel = chain . back (); hash . erase ( hash . find ( toDel )); //delete entry in hash chain . pop_back (); } if ( chain . size () _capacity ){ chain . push_front ( key ); hash [ key ] = { value , chain . begin ()}; } } }; \u200b /** * Your LRUCache object will be instantiated and called as such: * LRUCache* obj = new LRUCache(capacity); * int param_1 = obj- get(key); * obj- put(key,value); */ \u200b","title":"Solution"},{"location":"LeetcodeSolved/0150-evaluate-reverse-polish-notation/","text":"0150-evaluate-reverse-polish-notation Problem Evaluate the value of an arithmetic expression in Reverse Polish Notation . Valid operators are + , - , , / . Each operand may be an integer or another expression. Note: Division between two integers should truncate toward zero. The given RPN expression is always valid. That means the expression would always evaluate to a result and there won't be any divide by zero operation. Example 1: Input: [\"2\", \"1\", \"+\", \"3\", \" \"] Output: 9 Explanation: ((2 + 1) * 3) = 9 Example 2: Input: [\"4\", \"13\", \"5\", \"/\", \"+\"] Output: 6 Explanation: (4 + (13 / 5)) = 6 Example 3: Input: [\"10\", \"6\", \"9\", \"3\", \"+\", \"-11\", \" \", \"/\", \" \", \"17\", \"+\", \"5\", \"+\"] Output: 22 Explanation: ((10 * (6 / ((9 + 3) * -11))) + 17) + 5 = ((10 * (6 / (12 * -11))) + 17) + 5 = ((10 * (6 / -132)) + 17) + 5 = ((10 * 0) + 17) + 5 = (0 + 17) + 5 = 17 + 5 = 22 Solution c++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 // Solve prefix expression class Solution { public : int evalRPN ( vector string tokens ) { stack int todo ; for ( string x : tokens ){ char ch = x [ 0 ]; if ( x . size () == 1 ( ch == + || ch == - || ch == * || ch == / )){ int op2 = todo . top (); todo . pop (); int op1 = todo . top (); todo . pop (); if ( ch == + ) todo . push ( op1 + op2 ); else if ( ch == - ) todo . push ( op1 - op2 ); else if ( ch == * ) todo . push ( op1 * op2 ); else todo . push ( op1 / op2 ); } else { todo . push ( stoi ( x )); } } return todo . top (); } }; \u200b","title":"0150-evaluate-reverse-polish-notation"},{"location":"LeetcodeSolved/0150-evaluate-reverse-polish-notation/#0150-evaluate-reverse-polish-notation","text":"","title":"0150-evaluate-reverse-polish-notation"},{"location":"LeetcodeSolved/0150-evaluate-reverse-polish-notation/#problem","text":"Evaluate the value of an arithmetic expression in Reverse Polish Notation . Valid operators are + , - , , / . Each operand may be an integer or another expression. Note: Division between two integers should truncate toward zero. The given RPN expression is always valid. That means the expression would always evaluate to a result and there won't be any divide by zero operation. Example 1: Input: [\"2\", \"1\", \"+\", \"3\", \" \"] Output: 9 Explanation: ((2 + 1) * 3) = 9 Example 2: Input: [\"4\", \"13\", \"5\", \"/\", \"+\"] Output: 6 Explanation: (4 + (13 / 5)) = 6 Example 3: Input: [\"10\", \"6\", \"9\", \"3\", \"+\", \"-11\", \" \", \"/\", \" \", \"17\", \"+\", \"5\", \"+\"] Output: 22 Explanation: ((10 * (6 / ((9 + 3) * -11))) + 17) + 5 = ((10 * (6 / (12 * -11))) + 17) + 5 = ((10 * (6 / -132)) + 17) + 5 = ((10 * 0) + 17) + 5 = (0 + 17) + 5 = 17 + 5 = 22","title":"Problem"},{"location":"LeetcodeSolved/0150-evaluate-reverse-polish-notation/#solution","text":"c++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 // Solve prefix expression class Solution { public : int evalRPN ( vector string tokens ) { stack int todo ; for ( string x : tokens ){ char ch = x [ 0 ]; if ( x . size () == 1 ( ch == + || ch == - || ch == * || ch == / )){ int op2 = todo . top (); todo . pop (); int op1 = todo . top (); todo . pop (); if ( ch == + ) todo . push ( op1 + op2 ); else if ( ch == - ) todo . push ( op1 - op2 ); else if ( ch == * ) todo . push ( op1 * op2 ); else todo . push ( op1 / op2 ); } else { todo . push ( stoi ( x )); } } return todo . top (); } }; \u200b","title":"Solution"},{"location":"LeetcodeSolved/0152-maximum-product-subarray/","text":"0152-maximum-product-subarray Problem Given an integer array nums , find the contiguous subarray within an array (containing at least one number) which has the largest product. Example 1: Input: [2,3,-2,4] Output: 6 Explanation: [2,3] has the largest product 6. Example 2: Input: [-2,0,-1] Output: 0 Explanation: The result cannot be 2, because [-2,-1] is not a subarray. Solution c++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 class Solution { public : int maxProduct ( vector int nums ) { if ( nums . size () == 0 ) return 0 ; int maxSoFar = nums [ 0 ]; int maxCurr = nums [ 0 ], minCurr = nums [ 0 ]; for ( int i = 1 ; i nums . size (); i ++ ){ if ( nums [ i ] 0 ) swap ( maxCurr , minCurr ); maxCurr = max ( nums [ i ], maxCurr * nums [ i ]); minCurr = min ( nums [ i ], minCurr * nums [ i ]); if ( maxCurr maxSoFar ) maxSoFar = maxCurr ; } return maxSoFar ; } }; \u200b \u200b \u200b \u200b \u200b \u200b //class Solution { // public: // int maxProduct(vector int nums) { // vector int record(nums.size()); // vector int zeros(nums.size()); // int counter = 0; // int zero = 0; // int maxProduct = 1; // /*Storing result of maxProduct of index i to index j*/ // vector vector int memo(nums.size(),vector int (nums.size(),INT_MIN)); // for(int i=0;i nums.size();i++) memo[i][i] = nums[i]; \u200b","title":"0152-maximum-product-subarray"},{"location":"LeetcodeSolved/0152-maximum-product-subarray/#0152-maximum-product-subarray","text":"","title":"0152-maximum-product-subarray"},{"location":"LeetcodeSolved/0152-maximum-product-subarray/#problem","text":"Given an integer array nums , find the contiguous subarray within an array (containing at least one number) which has the largest product. Example 1: Input: [2,3,-2,4] Output: 6 Explanation: [2,3] has the largest product 6. Example 2: Input: [-2,0,-1] Output: 0 Explanation: The result cannot be 2, because [-2,-1] is not a subarray.","title":"Problem"},{"location":"LeetcodeSolved/0152-maximum-product-subarray/#solution","text":"c++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 class Solution { public : int maxProduct ( vector int nums ) { if ( nums . size () == 0 ) return 0 ; int maxSoFar = nums [ 0 ]; int maxCurr = nums [ 0 ], minCurr = nums [ 0 ]; for ( int i = 1 ; i nums . size (); i ++ ){ if ( nums [ i ] 0 ) swap ( maxCurr , minCurr ); maxCurr = max ( nums [ i ], maxCurr * nums [ i ]); minCurr = min ( nums [ i ], minCurr * nums [ i ]); if ( maxCurr maxSoFar ) maxSoFar = maxCurr ; } return maxSoFar ; } }; \u200b \u200b \u200b \u200b \u200b \u200b //class Solution { // public: // int maxProduct(vector int nums) { // vector int record(nums.size()); // vector int zeros(nums.size()); // int counter = 0; // int zero = 0; // int maxProduct = 1; // /*Storing result of maxProduct of index i to index j*/ // vector vector int memo(nums.size(),vector int (nums.size(),INT_MIN)); // for(int i=0;i nums.size();i++) memo[i][i] = nums[i]; \u200b","title":"Solution"},{"location":"LeetcodeSolved/0190-reverse-bits/","text":"0190-reverse-bits Problem Reverse bits of a given 32 bits unsigned integer. Example 1: Input: 00000010100101000001111010011100 Output: 00111001011110000010100101000000 Explanation: The input binary string 00000010100101000001111010011100 represents the unsigned integer 43261596, so return 964176192 which its binary representation is 00111001011110000010100101000000 . Example 2: Input: 11111111111111111111111111111101 Output: 10111111111111111111111111111111 Explanation: The input binary string 11111111111111111111111111111101 represents the unsigned integer 4294967293, so return 3221225471 which its binary representation is 10101111110010110010011101101001 . Note: Note that in some languages such as Java, there is no unsigned integer type. In this case, both input and output will be given as signed integer type and should not affect your implementation, as the internal binary representation of the integer is the same whether it is signed or unsigned. In Java, the compiler represents the signed integers using 2's complement notation . Therefore, in Example 2 above the input represents the signed integer -3 and the output represents the signed integer -1073741825 . Follow up : If this function is called many times, how would you optimize it? Solution c++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 //Just trying bitset class Solution { public : uint32_t reverseBits ( uint32_t n ) { bitset 32 b ( n ); int start = 0 , end = 31 ; while ( start end ){ bool temp = b [ start ]; b [ start ] = b [ end ]; b [ end ] = temp ; start ++ ; end -- ; } return b . to_ulong (); } }; \u200b","title":"0190-reverse-bits"},{"location":"LeetcodeSolved/0190-reverse-bits/#0190-reverse-bits","text":"","title":"0190-reverse-bits"},{"location":"LeetcodeSolved/0190-reverse-bits/#problem","text":"Reverse bits of a given 32 bits unsigned integer. Example 1: Input: 00000010100101000001111010011100 Output: 00111001011110000010100101000000 Explanation: The input binary string 00000010100101000001111010011100 represents the unsigned integer 43261596, so return 964176192 which its binary representation is 00111001011110000010100101000000 . Example 2: Input: 11111111111111111111111111111101 Output: 10111111111111111111111111111111 Explanation: The input binary string 11111111111111111111111111111101 represents the unsigned integer 4294967293, so return 3221225471 which its binary representation is 10101111110010110010011101101001 . Note: Note that in some languages such as Java, there is no unsigned integer type. In this case, both input and output will be given as signed integer type and should not affect your implementation, as the internal binary representation of the integer is the same whether it is signed or unsigned. In Java, the compiler represents the signed integers using 2's complement notation . Therefore, in Example 2 above the input represents the signed integer -3 and the output represents the signed integer -1073741825 . Follow up : If this function is called many times, how would you optimize it?","title":"Problem"},{"location":"LeetcodeSolved/0190-reverse-bits/#solution","text":"c++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 //Just trying bitset class Solution { public : uint32_t reverseBits ( uint32_t n ) { bitset 32 b ( n ); int start = 0 , end = 31 ; while ( start end ){ bool temp = b [ start ]; b [ start ] = b [ end ]; b [ end ] = temp ; start ++ ; end -- ; } return b . to_ulong (); } }; \u200b","title":"Solution"},{"location":"LeetcodeSolved/0199-binary-tree-right-side-view/","text":"0199-binary-tree-right-side-view Problem Given a binary tree, imagine yourself standing on the right side of it, return the values of the nodes you can see ordered from top to bottom. Example: Input: [1,2,3,null,5,null,4] Output: [1, 3, 4] Explanation: 1 --- / \\ 2 3 --- \\ \\ 5 4 --- Solution c++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 /** * Definition for a binary tree node. * struct TreeNode { * int val; * TreeNode *left; * TreeNode *right; * TreeNode(int x) : val(x), left(NULL), right(NULL) {} * }; */ \u200b // Thinking : Traverse all and store latest val in preorder traversal // Alternative : Traverse in mirror image of preorder // store the first val // Link GeeksforGeeks class Solution { public : vector int rightSideView ( TreeNode * root ) { vector int ans ; if ( ! root ) return ans ; map int , int m ; preorder ( root , m , 0 ); for ( auto i : m ){ ans . push_back ( i . second ); } return ans ; } void preorder ( TreeNode * root , map int , int m , int level ){ if ( ! root ) return ; m [ level ] = root - val ; preorder ( root - left , m , level + 1 ); preorder ( root - right , m , level + 1 ); } }; \u200b","title":"0199-binary-tree-right-side-view"},{"location":"LeetcodeSolved/0199-binary-tree-right-side-view/#0199-binary-tree-right-side-view","text":"","title":"0199-binary-tree-right-side-view"},{"location":"LeetcodeSolved/0199-binary-tree-right-side-view/#problem","text":"Given a binary tree, imagine yourself standing on the right side of it, return the values of the nodes you can see ordered from top to bottom. Example: Input: [1,2,3,null,5,null,4] Output: [1, 3, 4] Explanation: 1 --- / \\ 2 3 --- \\ \\ 5 4 ---","title":"Problem"},{"location":"LeetcodeSolved/0199-binary-tree-right-side-view/#solution","text":"c++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 /** * Definition for a binary tree node. * struct TreeNode { * int val; * TreeNode *left; * TreeNode *right; * TreeNode(int x) : val(x), left(NULL), right(NULL) {} * }; */ \u200b // Thinking : Traverse all and store latest val in preorder traversal // Alternative : Traverse in mirror image of preorder // store the first val // Link GeeksforGeeks class Solution { public : vector int rightSideView ( TreeNode * root ) { vector int ans ; if ( ! root ) return ans ; map int , int m ; preorder ( root , m , 0 ); for ( auto i : m ){ ans . push_back ( i . second ); } return ans ; } void preorder ( TreeNode * root , map int , int m , int level ){ if ( ! root ) return ; m [ level ] = root - val ; preorder ( root - left , m , level + 1 ); preorder ( root - right , m , level + 1 ); } }; \u200b","title":"Solution"},{"location":"LeetcodeSolved/0200-number-of-islands/","text":"0200-number-of-islands Problem Given a 2d grid map of '1' s (land) and '0' s (water), count the number of islands. An island is surrounded by water and is formed by connecting adjacent lands horizontally or vertically. You may assume all four edges of the grid are all surrounded by water. Example 1: Input: 11110 11010 11000 00000 Output: 1 Example 2: Input: 11000 11000 00100 00011 Output: 3 Solution c++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 class Solution { private : int rows , cols ; public : int numIslands ( vector vector char grid ) { if ( grid . empty ()) return 0 ; rows = grid . size (); cols = grid [ 0 ]. size (); vector vector int visited ( rows , vector int ( cols , 0 )); int result = 0 ; for ( int i = 0 ; i rows ; i ++ ){ for ( int j = 0 ; j cols ; j ++ ){ if ( grid [ i ][ j ] == 1 ! visited [ i ][ j ]){ visited [ i ][ j ] = 1 ; toVisit ( grid , visited , i , j ); result ++ ; } } } return result ; } void toVisit ( vector vector char grid , vector vector int visited , int i , int j ){ vector int rowMove = { - 1 , 0 , 0 , 1 }; vector int colMove = { 0 , - 1 , 1 , 0 }; for ( int k = 0 ; k 4 ; k ++ ){ if ( isSafe ( grid , visited , i + rowMove [ k ], j + colMove [ k ])){ visited [ i + rowMove [ k ]][ j + colMove [ k ]] = 1 ; toVisit ( grid , visited , i + rowMove [ k ], j + colMove [ k ]); } } return ; } bool isSafe ( vector vector char grid , vector vector int visited , int i , int j ){ return ( i = 0 i rows j = 0 j cols ! visited [ i ][ j ] grid [ i ][ j ] == 1 ); } }; \u200b","title":"0200-number-of-islands"},{"location":"LeetcodeSolved/0200-number-of-islands/#0200-number-of-islands","text":"","title":"0200-number-of-islands"},{"location":"LeetcodeSolved/0200-number-of-islands/#problem","text":"Given a 2d grid map of '1' s (land) and '0' s (water), count the number of islands. An island is surrounded by water and is formed by connecting adjacent lands horizontally or vertically. You may assume all four edges of the grid are all surrounded by water. Example 1: Input: 11110 11010 11000 00000 Output: 1 Example 2: Input: 11000 11000 00100 00011 Output: 3","title":"Problem"},{"location":"LeetcodeSolved/0200-number-of-islands/#solution","text":"c++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 class Solution { private : int rows , cols ; public : int numIslands ( vector vector char grid ) { if ( grid . empty ()) return 0 ; rows = grid . size (); cols = grid [ 0 ]. size (); vector vector int visited ( rows , vector int ( cols , 0 )); int result = 0 ; for ( int i = 0 ; i rows ; i ++ ){ for ( int j = 0 ; j cols ; j ++ ){ if ( grid [ i ][ j ] == 1 ! visited [ i ][ j ]){ visited [ i ][ j ] = 1 ; toVisit ( grid , visited , i , j ); result ++ ; } } } return result ; } void toVisit ( vector vector char grid , vector vector int visited , int i , int j ){ vector int rowMove = { - 1 , 0 , 0 , 1 }; vector int colMove = { 0 , - 1 , 1 , 0 }; for ( int k = 0 ; k 4 ; k ++ ){ if ( isSafe ( grid , visited , i + rowMove [ k ], j + colMove [ k ])){ visited [ i + rowMove [ k ]][ j + colMove [ k ]] = 1 ; toVisit ( grid , visited , i + rowMove [ k ], j + colMove [ k ]); } } return ; } bool isSafe ( vector vector char grid , vector vector int visited , int i , int j ){ return ( i = 0 i rows j = 0 j cols ! visited [ i ][ j ] grid [ i ][ j ] == 1 ); } }; \u200b","title":"Solution"},{"location":"LeetcodeSolved/0207-course-schedule/","text":"0207-course-schedule Problem There are a total of n courses you have to take, labeled from 0 to n-1 . Some courses may have prerequisites, for example to take course 0 you have to first take course 1, which is expressed as a pair: [0,1] Given the total number of courses and a list of prerequisite pairs , is it possible for you to finish all courses? Example 1: Input: 2, [[1,0]] Output: true Explanation: There are a total of 2 courses to take. To take course 1 you should have finished course 0. So it is possible. Example 2: Input: 2, [[1,0],[0,1]] Output: false Explanation: There are a total of 2 courses to take. To take course 1 you should have finished course 0, and to take course 0 you should also have finished course 1. So it is impossible. Note: The input prerequisites is a graph represented by a list of edges , not adjacency matrices. Read more about how a graph is represented . You may assume that there are no duplicate edges in the input prerequisites. Solution c++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 class Solution { // -1 not visited, 0 visited, 1 in topological list // Cycle can be detected if you visited an already visited node but it is not in topological list public : bool canFinish ( int n , vector vector int pre ) { vector int visited ( n , - 1 ); vector vector int G ( n ); for ( auto node : pre ){ G [ node [ 0 ]]. push_back ( node [ 1 ]); } \u200b for ( int i = 0 ; i n ; i ++ ){ if ( visited [ i ] ==- 1 ){ if ( ! noCycle ( visited , G , i )) return false ; } } return true ; } bool noCycle ( vector int visited , vector vector int G , int root ){ if ( visited [ root ] == 0 ) return false ; if ( visited [ root ] == 1 ) return true ; visited [ root ] = 0 ; for ( int i : G [ root ]){ if ( ! noCycle ( visited , G , i )) return false ; } visited [ root ] = 1 ; return true ; } }; \u200b","title":"0207-course-schedule"},{"location":"LeetcodeSolved/0207-course-schedule/#0207-course-schedule","text":"","title":"0207-course-schedule"},{"location":"LeetcodeSolved/0207-course-schedule/#problem","text":"There are a total of n courses you have to take, labeled from 0 to n-1 . Some courses may have prerequisites, for example to take course 0 you have to first take course 1, which is expressed as a pair: [0,1] Given the total number of courses and a list of prerequisite pairs , is it possible for you to finish all courses? Example 1: Input: 2, [[1,0]] Output: true Explanation: There are a total of 2 courses to take. To take course 1 you should have finished course 0. So it is possible. Example 2: Input: 2, [[1,0],[0,1]] Output: false Explanation: There are a total of 2 courses to take. To take course 1 you should have finished course 0, and to take course 0 you should also have finished course 1. So it is impossible. Note: The input prerequisites is a graph represented by a list of edges , not adjacency matrices. Read more about how a graph is represented . You may assume that there are no duplicate edges in the input prerequisites.","title":"Problem"},{"location":"LeetcodeSolved/0207-course-schedule/#solution","text":"c++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 class Solution { // -1 not visited, 0 visited, 1 in topological list // Cycle can be detected if you visited an already visited node but it is not in topological list public : bool canFinish ( int n , vector vector int pre ) { vector int visited ( n , - 1 ); vector vector int G ( n ); for ( auto node : pre ){ G [ node [ 0 ]]. push_back ( node [ 1 ]); } \u200b for ( int i = 0 ; i n ; i ++ ){ if ( visited [ i ] ==- 1 ){ if ( ! noCycle ( visited , G , i )) return false ; } } return true ; } bool noCycle ( vector int visited , vector vector int G , int root ){ if ( visited [ root ] == 0 ) return false ; if ( visited [ root ] == 1 ) return true ; visited [ root ] = 0 ; for ( int i : G [ root ]){ if ( ! noCycle ( visited , G , i )) return false ; } visited [ root ] = 1 ; return true ; } }; \u200b","title":"Solution"},{"location":"LeetcodeSolved/0208-implement-trie-prefix-tree/","text":"0208-implement-trie-prefix-tree Problem Implement a trie with insert , search , and startsWith methods. Example: Trie trie = new Trie(); trie.insert(\"apple\"); trie.search(\"apple\"); // returns true trie.search(\"app\"); // returns false trie.startsWith(\"app\"); // returns true trie.insert(\"app\"); trie.search(\"app\"); // returns true Note: You may assume that all inputs are consist of lowercase letters a-z . All inputs are guaranteed to be non-empty strings. Solution c++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 class Trie { struct Node { int isTerminal ; vector Node * v ; Node (){ isTerminal = false ; v = vector Node * ( 26 , nullptr ); } }; Node * nodes ; public : /** Initialize your data structure here. */ Trie () { nodes = new Node (); } /** Inserts a word into the trie. */ void insert ( string word ) { insertion ( nodes , word , 0 ); } void insertion ( Node * node , string word , int idx ){ if ( idx == word . size ()){ node - isTerminal = true ; return ; } int i = word [ idx ] - a ; if ( ! node - v [ i ]) node - v [ i ] = new Node (); insertion ( node - v [ i ], word , idx + 1 ); } /** Returns if the word is in the trie. */ bool search ( string word ) { return searching ( nodes , word , 0 ); } bool searching ( Node * node , string word , int idx ){ if ( idx == word . size ()){ return node - isTerminal ; \u200b","title":"0208-implement-trie-prefix-tree"},{"location":"LeetcodeSolved/0208-implement-trie-prefix-tree/#0208-implement-trie-prefix-tree","text":"","title":"0208-implement-trie-prefix-tree"},{"location":"LeetcodeSolved/0208-implement-trie-prefix-tree/#problem","text":"Implement a trie with insert , search , and startsWith methods. Example: Trie trie = new Trie(); trie.insert(\"apple\"); trie.search(\"apple\"); // returns true trie.search(\"app\"); // returns false trie.startsWith(\"app\"); // returns true trie.insert(\"app\"); trie.search(\"app\"); // returns true Note: You may assume that all inputs are consist of lowercase letters a-z . All inputs are guaranteed to be non-empty strings.","title":"Problem"},{"location":"LeetcodeSolved/0208-implement-trie-prefix-tree/#solution","text":"c++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 class Trie { struct Node { int isTerminal ; vector Node * v ; Node (){ isTerminal = false ; v = vector Node * ( 26 , nullptr ); } }; Node * nodes ; public : /** Initialize your data structure here. */ Trie () { nodes = new Node (); } /** Inserts a word into the trie. */ void insert ( string word ) { insertion ( nodes , word , 0 ); } void insertion ( Node * node , string word , int idx ){ if ( idx == word . size ()){ node - isTerminal = true ; return ; } int i = word [ idx ] - a ; if ( ! node - v [ i ]) node - v [ i ] = new Node (); insertion ( node - v [ i ], word , idx + 1 ); } /** Returns if the word is in the trie. */ bool search ( string word ) { return searching ( nodes , word , 0 ); } bool searching ( Node * node , string word , int idx ){ if ( idx == word . size ()){ return node - isTerminal ; \u200b","title":"Solution"},{"location":"LeetcodeSolved/0210-course-schedule-ii/","text":"0210-course-schedule-ii Problem There are a total of n courses you have to take, labeled from 0 to n-1 . Some courses may have prerequisites, for example to take course 0 you have to first take course 1, which is expressed as a pair: [0,1] Given the total number of courses and a list of prerequisite pairs , return the ordering of courses you should take to finish all courses. There may be multiple correct orders, you just need to return one of them. If it is impossible to finish all courses, return an empty array. Example 1: Input: 2, [[1,0]] Output: [0,1] Explanation: There are a total of 2 courses to take. To take course 1 you should have finished course 0. So the correct course order is [0,1] . Example 2: Input: 4, [[1,0],[2,0],[3,1],[3,2]] Output: [0,1,2,3] or [0,2,1,3] Explanation: There are a total of 4 courses to take. To take course 3 you should have finished both courses 1 and 2. Both courses 1 and 2 should be taken after you finished course 0. So one correct course order is [0,1,2,3] . Another correct ordering is [0,2,1,3] . Note: The input prerequisites is a graph represented by a list of edges , not adjacency matrices. Read more about how a graph is represented . You may assume that there are no duplicate edges in the input prerequisites. Solution c++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 class Solution { public : vector int findOrder ( int n , vector vector int pre ) { vector int visited ( n , - 1 ); vector int order ; vector vector int G ( n ); for ( auto node : pre ){ G [ node [ 0 ]]. push_back ( node [ 1 ]); } \u200b for ( int i = 0 ; i n ; i ++ ){ if ( visited [ i ] ==- 1 ){ if ( ! noCycle ( visited , order , G , i )) return vector int (); } } \u200b return order ; } bool noCycle ( vector int visited , vector int order , vector vector int G , int root ){ if ( visited [ root ] == 0 ) return false ; if ( visited [ root ] == 1 ) return true ; visited [ root ] = 0 ; for ( int i : G [ root ]){ if ( ! noCycle ( visited , order , G , i )) return false ; } visited [ root ] = 1 ; order . push_back ( root ); return true ; } }; \u200b // -1 not visited, 0 visited, 1 in topological list // Cycle can be detected if you visited an already visited node but it is not in topological list \u200b \u200b","title":"0210-course-schedule-ii"},{"location":"LeetcodeSolved/0210-course-schedule-ii/#0210-course-schedule-ii","text":"","title":"0210-course-schedule-ii"},{"location":"LeetcodeSolved/0210-course-schedule-ii/#problem","text":"There are a total of n courses you have to take, labeled from 0 to n-1 . Some courses may have prerequisites, for example to take course 0 you have to first take course 1, which is expressed as a pair: [0,1] Given the total number of courses and a list of prerequisite pairs , return the ordering of courses you should take to finish all courses. There may be multiple correct orders, you just need to return one of them. If it is impossible to finish all courses, return an empty array. Example 1: Input: 2, [[1,0]] Output: [0,1] Explanation: There are a total of 2 courses to take. To take course 1 you should have finished course 0. So the correct course order is [0,1] . Example 2: Input: 4, [[1,0],[2,0],[3,1],[3,2]] Output: [0,1,2,3] or [0,2,1,3] Explanation: There are a total of 4 courses to take. To take course 3 you should have finished both courses 1 and 2. Both courses 1 and 2 should be taken after you finished course 0. So one correct course order is [0,1,2,3] . Another correct ordering is [0,2,1,3] . Note: The input prerequisites is a graph represented by a list of edges , not adjacency matrices. Read more about how a graph is represented . You may assume that there are no duplicate edges in the input prerequisites.","title":"Problem"},{"location":"LeetcodeSolved/0210-course-schedule-ii/#solution","text":"c++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 class Solution { public : vector int findOrder ( int n , vector vector int pre ) { vector int visited ( n , - 1 ); vector int order ; vector vector int G ( n ); for ( auto node : pre ){ G [ node [ 0 ]]. push_back ( node [ 1 ]); } \u200b for ( int i = 0 ; i n ; i ++ ){ if ( visited [ i ] ==- 1 ){ if ( ! noCycle ( visited , order , G , i )) return vector int (); } } \u200b return order ; } bool noCycle ( vector int visited , vector int order , vector vector int G , int root ){ if ( visited [ root ] == 0 ) return false ; if ( visited [ root ] == 1 ) return true ; visited [ root ] = 0 ; for ( int i : G [ root ]){ if ( ! noCycle ( visited , order , G , i )) return false ; } visited [ root ] = 1 ; order . push_back ( root ); return true ; } }; \u200b // -1 not visited, 0 visited, 1 in topological list // Cycle can be detected if you visited an already visited node but it is not in topological list \u200b \u200b","title":"Solution"},{"location":"LeetcodeSolved/0211-add-and-search-word-data-structure-design/","text":"0211-add-and-search-word-data-structure-design Problem Design a data structure that supports the following two operations: void addWord(word) bool search(word) search(word) can search a literal word or a regular expression string containing only letters a-z or . . A . means it can represent any one letter. Example: addWord(\"bad\") addWord(\"dad\") addWord(\"mad\") search(\"pad\") - false search(\"bad\") - true search(\".ad\") - true search(\"b..\") - true Note: You may assume that all words are consist of lowercase letters a-z . Solution c++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 // Inspired from @jianchao-li \u200b class TrieNode { public : bool isTerminal ; TrieNode * children [ 26 ]; TrieNode () : isTerminal ( false ){ memset ( children , NULL , sizeof ( TrieNode * ) * 26 ); } }; \u200b \u200b class WordDictionary { public : TrieNode * root = new TrieNode (); /** Initialize your data structure here. */ WordDictionary () { } /** Adds a word into the data structure. */ void addWord ( string word ) { TrieNode * node = root ; for ( int i = 0 ; i word . size (); ++ i ) { int pos = word [ i ] - a ; if ( node - children [ pos ] == nullptr ){ node - children [ pos ] = new TrieNode (); } node = node - children [ pos ]; } node - isTerminal = true ; } /** Returns if the word is in the data structure. A word could contain the dot character . to represent any one letter. */ bool search ( string word ) { return searching ( word , root ); } \u200b","title":"0211-add-and-search-word-data-structure-design"},{"location":"LeetcodeSolved/0211-add-and-search-word-data-structure-design/#0211-add-and-search-word-data-structure-design","text":"","title":"0211-add-and-search-word-data-structure-design"},{"location":"LeetcodeSolved/0211-add-and-search-word-data-structure-design/#problem","text":"Design a data structure that supports the following two operations: void addWord(word) bool search(word) search(word) can search a literal word or a regular expression string containing only letters a-z or . . A . means it can represent any one letter. Example: addWord(\"bad\") addWord(\"dad\") addWord(\"mad\") search(\"pad\") - false search(\"bad\") - true search(\".ad\") - true search(\"b..\") - true Note: You may assume that all words are consist of lowercase letters a-z .","title":"Problem"},{"location":"LeetcodeSolved/0211-add-and-search-word-data-structure-design/#solution","text":"c++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 // Inspired from @jianchao-li \u200b class TrieNode { public : bool isTerminal ; TrieNode * children [ 26 ]; TrieNode () : isTerminal ( false ){ memset ( children , NULL , sizeof ( TrieNode * ) * 26 ); } }; \u200b \u200b class WordDictionary { public : TrieNode * root = new TrieNode (); /** Initialize your data structure here. */ WordDictionary () { } /** Adds a word into the data structure. */ void addWord ( string word ) { TrieNode * node = root ; for ( int i = 0 ; i word . size (); ++ i ) { int pos = word [ i ] - a ; if ( node - children [ pos ] == nullptr ){ node - children [ pos ] = new TrieNode (); } node = node - children [ pos ]; } node - isTerminal = true ; } /** Returns if the word is in the data structure. A word could contain the dot character . to represent any one letter. */ bool search ( string word ) { return searching ( word , root ); } \u200b","title":"Solution"},{"location":"LeetcodeSolved/0212-word-search-ii/","text":"0212-word-search-ii Problem Given a 2D board and a list of words from the dictionary, find all words in the board. Each word must be constructed from letters of sequentially adjacent cell, where \"adjacent\" cells are those horizontally or vertically neighboring. The same letter cell may not be used more than once in a word. Example: Input: board = [ [' o ',' a ','a','n'], ['e',' t ',' a ',' e '], ['i',' h ','k','r'], ['i','f','l','v'] ] words = [\"oath\",\"pea\",\"eat\",\"rain\"] Output: [\"eat\",\"oath\"] Note: All inputs are consist of lowercase letters a-z . The values of words are distinct. Solution c++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 // Need to be optimize class TrieNode { public : bool word ; TrieNode * children [ 26 ]; TrieNode () { word = false ; memset ( children , NULL , sizeof ( children )); } }; \u200b class WordDictionary { public : void addWord ( string word ) { TrieNode * node = root ; for ( char c : word ) { if ( ! node - children [ c - a ]) { node - children [ c - a ] = new TrieNode (); } node = node - children [ c - a ]; } node - word = true ; } bool isSubstring ( string word ){ TrieNode * node = root ; for ( int i = 0 ; i word . size (); i ++ ){ if ( node - children [ word [ i ] - a ]) node = node - children [ word [ i ] - a ]; else return false ; } return true ; } /** Returns if the word is in the data structure. A word could contain the dot character . to represent any one letter. */ bool search ( string word ) { return search ( word . c_str (), root ); } \u200b","title":"0212-word-search-ii"},{"location":"LeetcodeSolved/0212-word-search-ii/#0212-word-search-ii","text":"","title":"0212-word-search-ii"},{"location":"LeetcodeSolved/0212-word-search-ii/#problem","text":"Given a 2D board and a list of words from the dictionary, find all words in the board. Each word must be constructed from letters of sequentially adjacent cell, where \"adjacent\" cells are those horizontally or vertically neighboring. The same letter cell may not be used more than once in a word. Example: Input: board = [ [' o ',' a ','a','n'], ['e',' t ',' a ',' e '], ['i',' h ','k','r'], ['i','f','l','v'] ] words = [\"oath\",\"pea\",\"eat\",\"rain\"] Output: [\"eat\",\"oath\"] Note: All inputs are consist of lowercase letters a-z . The values of words are distinct.","title":"Problem"},{"location":"LeetcodeSolved/0212-word-search-ii/#solution","text":"c++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 // Need to be optimize class TrieNode { public : bool word ; TrieNode * children [ 26 ]; TrieNode () { word = false ; memset ( children , NULL , sizeof ( children )); } }; \u200b class WordDictionary { public : void addWord ( string word ) { TrieNode * node = root ; for ( char c : word ) { if ( ! node - children [ c - a ]) { node - children [ c - a ] = new TrieNode (); } node = node - children [ c - a ]; } node - word = true ; } bool isSubstring ( string word ){ TrieNode * node = root ; for ( int i = 0 ; i word . size (); i ++ ){ if ( node - children [ word [ i ] - a ]) node = node - children [ word [ i ] - a ]; else return false ; } return true ; } /** Returns if the word is in the data structure. A word could contain the dot character . to represent any one letter. */ bool search ( string word ) { return search ( word . c_str (), root ); } \u200b","title":"Solution"},{"location":"LeetcodeSolved/0230-kth-smallest-element-in-a-bst/","text":"0230-kth-smallest-element-in-a-bst Problem Given a binary search tree, write a function kthSmallest to find the k th smallest element in it. Note: You may assume k is always valid, 1 \u2264 k \u2264 BST's total elements. Example 1: Input: root = [3,1,4,null,2], k = 1 3 / \\ 1 4 \\ 2 Output: 1 Example 2: Input: root = [5,3,6,2,4,null,null,1], k = 3 5 / \\ 3 6 / \\ 2 4 / 1 Output: 3 Follow up: What if the BST is modified (insert/delete operations) often and you need to find the kth smallest frequently? How would you optimize the kthSmallest routine? Solution c++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 /** * Definition for a binary tree node. * struct TreeNode { * int val; * TreeNode *left; * TreeNode *right; * TreeNode(int x) : val(x), left(NULL), right(NULL) {} * }; */ class Solution { public : int kthSmallest ( TreeNode * root , int k ) { stack TreeNode * todo ; while ( root != NULL || ! todo . empty ()){ while ( root != NULL ){ todo . push ( root ); root = root - left ; } root = todo . top (); todo . pop (); if ( -- k == 0 ) return root - val ; root = root - right ; } return 0 ; } }; \u200b","title":"0230-kth-smallest-element-in-a-bst"},{"location":"LeetcodeSolved/0230-kth-smallest-element-in-a-bst/#0230-kth-smallest-element-in-a-bst","text":"","title":"0230-kth-smallest-element-in-a-bst"},{"location":"LeetcodeSolved/0230-kth-smallest-element-in-a-bst/#problem","text":"Given a binary search tree, write a function kthSmallest to find the k th smallest element in it. Note: You may assume k is always valid, 1 \u2264 k \u2264 BST's total elements. Example 1: Input: root = [3,1,4,null,2], k = 1 3 / \\ 1 4 \\ 2 Output: 1 Example 2: Input: root = [5,3,6,2,4,null,null,1], k = 3 5 / \\ 3 6 / \\ 2 4 / 1 Output: 3 Follow up: What if the BST is modified (insert/delete operations) often and you need to find the kth smallest frequently? How would you optimize the kthSmallest routine?","title":"Problem"},{"location":"LeetcodeSolved/0230-kth-smallest-element-in-a-bst/#solution","text":"c++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 /** * Definition for a binary tree node. * struct TreeNode { * int val; * TreeNode *left; * TreeNode *right; * TreeNode(int x) : val(x), left(NULL), right(NULL) {} * }; */ class Solution { public : int kthSmallest ( TreeNode * root , int k ) { stack TreeNode * todo ; while ( root != NULL || ! todo . empty ()){ while ( root != NULL ){ todo . push ( root ); root = root - left ; } root = todo . top (); todo . pop (); if ( -- k == 0 ) return root - val ; root = root - right ; } return 0 ; } }; \u200b","title":"Solution"},{"location":"LeetcodeSolved/0234-palindrome-linked-list/","text":"0234-palindrome-linked-list Problem Given a singly linked list, determine if it is a palindrome. Example 1: Input: 1- 2 Output: false Example 2: Input: 1- 2- 2- 1 Output: true Follow up: Could you do it in O(n) time and O(1) space? Solution c++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 // Find the starting of reverse via two pointer technique // Reverse the staring from that point // Compare values from head of linked list and reversed linked list class Solution { public : bool isPalindrome ( ListNode * head ) { if ( head == NULL ) return true ; if ( head - next == NULL ) return true ; ListNode * slow = head ; ListNode * fast = head ; ListNode * prev = slow ; while ( fast ){ if ( fast - next == NULL ) break ; prev = slow ; slow = slow - next ; fast = fast - next - next ; } if ( fast != NULL ){ slow = slow - next ; } fast = head ; prev - next = NULL ; slow = reverseList ( slow ); while ( fast slow ){ if ( fast - val != slow - val ) return false ; fast = fast - next ; slow = slow - next ; } if ( fast || slow ) return false ; return true ; } ListNode * reverseList ( ListNode * root ){ if ( root == NULL ) return root ; ListNode * prev = NULL ; \u200b","title":"0234-palindrome-linked-list"},{"location":"LeetcodeSolved/0234-palindrome-linked-list/#0234-palindrome-linked-list","text":"","title":"0234-palindrome-linked-list"},{"location":"LeetcodeSolved/0234-palindrome-linked-list/#problem","text":"Given a singly linked list, determine if it is a palindrome. Example 1: Input: 1- 2 Output: false Example 2: Input: 1- 2- 2- 1 Output: true Follow up: Could you do it in O(n) time and O(1) space?","title":"Problem"},{"location":"LeetcodeSolved/0234-palindrome-linked-list/#solution","text":"c++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 // Find the starting of reverse via two pointer technique // Reverse the staring from that point // Compare values from head of linked list and reversed linked list class Solution { public : bool isPalindrome ( ListNode * head ) { if ( head == NULL ) return true ; if ( head - next == NULL ) return true ; ListNode * slow = head ; ListNode * fast = head ; ListNode * prev = slow ; while ( fast ){ if ( fast - next == NULL ) break ; prev = slow ; slow = slow - next ; fast = fast - next - next ; } if ( fast != NULL ){ slow = slow - next ; } fast = head ; prev - next = NULL ; slow = reverseList ( slow ); while ( fast slow ){ if ( fast - val != slow - val ) return false ; fast = fast - next ; slow = slow - next ; } if ( fast || slow ) return false ; return true ; } ListNode * reverseList ( ListNode * root ){ if ( root == NULL ) return root ; ListNode * prev = NULL ; \u200b","title":"Solution"},{"location":"LeetcodeSolved/0235-lowest-common-ancestor-of-a-binary-search-tree/","text":"0235-lowest-common-ancestor-of-a-binary-search-tree Problem Given a binary search tree (BST), find the lowest common ancestor (LCA) of two given nodes in the BST. According to the definition of LCA on Wikipedia : \u201cThe lowest common ancestor is defined between two nodes p and q as the lowest node in T that has both p and q as descendants (where we allow a node to be a descendant of itself ).\u201d Given binary search tree: root = [6,2,8,0,4,7,9,null,null,3,5] Example 1: Input: root = [6,2,8,0,4,7,9,null,null,3,5], p = 2, q = 8 Output: 6 Explanation: The LCA of nodes 2 and 8 is 6 . Example 2: Input: root = [6,2,8,0,4,7,9,null,null,3,5], p = 2, q = 4 Output: 2 Explanation: The LCA of nodes 2 and 4 is 2 , since a node can be a descendant of itself according to the LCA definition. Note: All of the nodes' values will be unique. p and q are different and both values will exist in the BST. Solution c++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 /** * Definition for a binary tree node. * struct TreeNode { * int val; * TreeNode *left; * TreeNode *right; * TreeNode(int x) : val(x), left(NULL), right(NULL) {} * }; */ class Solution { TreeNode * ans ; public : TreeNode * lowestCommonAncestor ( TreeNode * root , TreeNode * p , TreeNode * q ) { ans = nullptr ; lca ( root , p , q ); return ans ; } int lca ( TreeNode * root , TreeNode * p , TreeNode * q ){ int found = 0 ; if ( root == nullptr ) return 0 ; if ( root == p root == q ){ ans = root ; return 2 ; } if ( root == p || root == q ) found ++ ; found += lca ( root - left , p , q ); found += lca ( root - right , p , q ); if ( found = 2 ) if ( ans == nullptr ) ans = root ; return found ; } }; \u200b","title":"0235-lowest-common-ancestor-of-a-binary-search-tree"},{"location":"LeetcodeSolved/0235-lowest-common-ancestor-of-a-binary-search-tree/#0235-lowest-common-ancestor-of-a-binary-search-tree","text":"","title":"0235-lowest-common-ancestor-of-a-binary-search-tree"},{"location":"LeetcodeSolved/0235-lowest-common-ancestor-of-a-binary-search-tree/#problem","text":"Given a binary search tree (BST), find the lowest common ancestor (LCA) of two given nodes in the BST. According to the definition of LCA on Wikipedia : \u201cThe lowest common ancestor is defined between two nodes p and q as the lowest node in T that has both p and q as descendants (where we allow a node to be a descendant of itself ).\u201d Given binary search tree: root = [6,2,8,0,4,7,9,null,null,3,5] Example 1: Input: root = [6,2,8,0,4,7,9,null,null,3,5], p = 2, q = 8 Output: 6 Explanation: The LCA of nodes 2 and 8 is 6 . Example 2: Input: root = [6,2,8,0,4,7,9,null,null,3,5], p = 2, q = 4 Output: 2 Explanation: The LCA of nodes 2 and 4 is 2 , since a node can be a descendant of itself according to the LCA definition. Note: All of the nodes' values will be unique. p and q are different and both values will exist in the BST.","title":"Problem"},{"location":"LeetcodeSolved/0235-lowest-common-ancestor-of-a-binary-search-tree/#solution","text":"c++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 /** * Definition for a binary tree node. * struct TreeNode { * int val; * TreeNode *left; * TreeNode *right; * TreeNode(int x) : val(x), left(NULL), right(NULL) {} * }; */ class Solution { TreeNode * ans ; public : TreeNode * lowestCommonAncestor ( TreeNode * root , TreeNode * p , TreeNode * q ) { ans = nullptr ; lca ( root , p , q ); return ans ; } int lca ( TreeNode * root , TreeNode * p , TreeNode * q ){ int found = 0 ; if ( root == nullptr ) return 0 ; if ( root == p root == q ){ ans = root ; return 2 ; } if ( root == p || root == q ) found ++ ; found += lca ( root - left , p , q ); found += lca ( root - right , p , q ); if ( found = 2 ) if ( ans == nullptr ) ans = root ; return found ; } }; \u200b","title":"Solution"},{"location":"LeetcodeSolved/0236-lowest-common-ancestor-of-a-binary-tree/","text":"0236-lowest-common-ancestor-of-a-binary-tree Problem Given a binary tree, find the lowest common ancestor (LCA) of two given nodes in the tree. According to the definition of LCA on Wikipedia : \u201cThe lowest common ancestor is defined between two nodes p and q as the lowest node in T that has both p and q as descendants (where we allow a node to be a descendant of itself ).\u201d Given the following binary tree: root = [3,5,1,6,2,0,8,null,null,7,4] Example 1: Input: root = [3,5,1,6,2,0,8,null,null,7,4], p = 5, q = 1 Output: 3 Explanation: The LCA of nodes 5 and 1 is 3. Example 2: Input: root = [3,5,1,6,2,0,8,null,null,7,4], p = 5, q = 4 Output: 5 Explanation: The LCA of nodes 5 and 4 is 5 , since a node can be a descendant of itself according to the LCA definition. Note: All of the nodes' values will be unique. p and q are different and both values will exist in the binary tree. Solution c++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 \u200b return ans ; } bool isLCA ( TreeNode * root , TreeNode * p , TreeNode * q ){ // end of journey and we got nothing if ( ! root ) return false ; // we reached a house which containis criminals p or q int found = 0 ; if ( root == p || root == q ){ found ++ ; } // for another criminal go to left of that house and right of that. // May be neighbors are the one who are keeping them safe bool leftRes = isLCA ( root - left , p , q ); bool rightRes = isLCA ( root - right , p , q ); // if one have p and other have q then we have found them. if ( leftRes rightRes ){ ans = root ; return true ; } // Else one of then having p or q if ( leftRes || rightRes ) found ++ ; // If somehow we got both then if ( found == 2 ){ ans = root ; return true ; } // Something is even in our hand if ( found == 1 ) return true ; //hopeless return false ; } }; \u200b","title":"0236-lowest-common-ancestor-of-a-binary-tree"},{"location":"LeetcodeSolved/0236-lowest-common-ancestor-of-a-binary-tree/#0236-lowest-common-ancestor-of-a-binary-tree","text":"","title":"0236-lowest-common-ancestor-of-a-binary-tree"},{"location":"LeetcodeSolved/0236-lowest-common-ancestor-of-a-binary-tree/#problem","text":"Given a binary tree, find the lowest common ancestor (LCA) of two given nodes in the tree. According to the definition of LCA on Wikipedia : \u201cThe lowest common ancestor is defined between two nodes p and q as the lowest node in T that has both p and q as descendants (where we allow a node to be a descendant of itself ).\u201d Given the following binary tree: root = [3,5,1,6,2,0,8,null,null,7,4] Example 1: Input: root = [3,5,1,6,2,0,8,null,null,7,4], p = 5, q = 1 Output: 3 Explanation: The LCA of nodes 5 and 1 is 3. Example 2: Input: root = [3,5,1,6,2,0,8,null,null,7,4], p = 5, q = 4 Output: 5 Explanation: The LCA of nodes 5 and 4 is 5 , since a node can be a descendant of itself according to the LCA definition. Note: All of the nodes' values will be unique. p and q are different and both values will exist in the binary tree.","title":"Problem"},{"location":"LeetcodeSolved/0236-lowest-common-ancestor-of-a-binary-tree/#solution","text":"c++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 \u200b return ans ; } bool isLCA ( TreeNode * root , TreeNode * p , TreeNode * q ){ // end of journey and we got nothing if ( ! root ) return false ; // we reached a house which containis criminals p or q int found = 0 ; if ( root == p || root == q ){ found ++ ; } // for another criminal go to left of that house and right of that. // May be neighbors are the one who are keeping them safe bool leftRes = isLCA ( root - left , p , q ); bool rightRes = isLCA ( root - right , p , q ); // if one have p and other have q then we have found them. if ( leftRes rightRes ){ ans = root ; return true ; } // Else one of then having p or q if ( leftRes || rightRes ) found ++ ; // If somehow we got both then if ( found == 2 ){ ans = root ; return true ; } // Something is even in our hand if ( found == 1 ) return true ; //hopeless return false ; } }; \u200b","title":"Solution"},{"location":"LeetcodeSolved/0239-sliding-window-maximum/","text":"0239-sliding-window-maximum Problem Given an array nums , there is a sliding window of size k which is moving from the very left of the array to the very right. You can only see the k numbers in the window. Each time the sliding window moves right by one position. Return the max sliding window. Example: Input: nums = [1,3,-1,-3,5,3,6,7] , and k = 3 Output: [3,3,5,5,6,7] Explanation: Window position Max --------------- ----- [1 3 -1] -3 5 3 6 7 3 1 [3 -1 -3] 5 3 6 7 3 1 3 [-1 -3 5] 3 6 7 5 1 3 -1 [-3 5 3] 6 7 5 1 3 -1 -3 [5 3 6] 7 6 1 3 -1 -3 5 [3 6 7] 7 Note: You may assume k is always valid, 1 \u2264 k \u2264 input array's size for non-empty array. Follow up: Could you solve it in linear time? Solution c++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 // Use a deque , // remove indices that are not in window, remove less value before any i. // Since it itself is going to handle max case // Priority_queue won t help class Solution { public : vector int maxSlidingWindow ( vector int nums , int k ) { deque int q ; vector int res ; for ( int i = 0 ; i k - 1 ; i ++ ){ while ( ! q . empty () nums [ q . back ()] nums [ i ]){ q . pop_back (); } q . push_back ( i ); } for ( int i = k - 1 ; i nums . size (); i ++ ){ while ( ! q . empty () q . front () i - ( k - 1 )) q . pop_front (); while ( ! q . empty () nums [ q . back ()] nums [ i ]) q . pop_back (); q . push_back ( i ); if ( i = k - 1 ) res . push_back ( nums [ q . front ()]); } return res ; } }; \u200b","title":"0239-sliding-window-maximum"},{"location":"LeetcodeSolved/0239-sliding-window-maximum/#0239-sliding-window-maximum","text":"","title":"0239-sliding-window-maximum"},{"location":"LeetcodeSolved/0239-sliding-window-maximum/#problem","text":"Given an array nums , there is a sliding window of size k which is moving from the very left of the array to the very right. You can only see the k numbers in the window. Each time the sliding window moves right by one position. Return the max sliding window. Example: Input: nums = [1,3,-1,-3,5,3,6,7] , and k = 3 Output: [3,3,5,5,6,7] Explanation: Window position Max --------------- ----- [1 3 -1] -3 5 3 6 7 3 1 [3 -1 -3] 5 3 6 7 3 1 3 [-1 -3 5] 3 6 7 5 1 3 -1 [-3 5 3] 6 7 5 1 3 -1 -3 [5 3 6] 7 6 1 3 -1 -3 5 [3 6 7] 7 Note: You may assume k is always valid, 1 \u2264 k \u2264 input array's size for non-empty array. Follow up: Could you solve it in linear time?","title":"Problem"},{"location":"LeetcodeSolved/0239-sliding-window-maximum/#solution","text":"c++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 // Use a deque , // remove indices that are not in window, remove less value before any i. // Since it itself is going to handle max case // Priority_queue won t help class Solution { public : vector int maxSlidingWindow ( vector int nums , int k ) { deque int q ; vector int res ; for ( int i = 0 ; i k - 1 ; i ++ ){ while ( ! q . empty () nums [ q . back ()] nums [ i ]){ q . pop_back (); } q . push_back ( i ); } for ( int i = k - 1 ; i nums . size (); i ++ ){ while ( ! q . empty () q . front () i - ( k - 1 )) q . pop_front (); while ( ! q . empty () nums [ q . back ()] nums [ i ]) q . pop_back (); q . push_back ( i ); if ( i = k - 1 ) res . push_back ( nums [ q . front ()]); } return res ; } }; \u200b","title":"Solution"},{"location":"LeetcodeSolved/0241-different-ways-to-add-parentheses/","text":"0241-different-ways-to-add-parentheses Problem Given a string of numbers and operators, return all possible results from computing all the different possible ways to group numbers and operators. The valid operators are + , - and . Example 1: Input: \"2-1-1\" Output: [0, 2] Explanation: ((2-1)-1) = 0 (2-(1-1)) = 2 Example 2: Input: \"2 3-4 5\" Output: [-34, -14, -10, -10, 10] Explanation: (2 (3-(4 5))) = -34 ((2 3)-(4 5)) = -14 ((2 (3-4)) 5) = -10 (2 ((3-4) 5)) = -10 (((2 3)-4)*5) = 10 Solution c++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 class Solution { public : vector int res ; vector int diffWaysToCompute ( string input ) { int n = input . size (); for ( int k = 0 ; k input . size (); ++ k ) { if ( input [ k ] == + || input [ k ] == * || input [ k ] == - ){ vector int x = solve ( input , 0 , k - 1 ); vector int y = solve ( input , k + 1 , n - 1 ); for ( int i : x ){ for ( int j : y ){ switch ( input [ k ]){ case + : res . push_back ( i + j ); break ; case - : res . push_back ( i - j ); break ; case * : res . push_back ( i * j ); } } } } } if ( res . empty ()) res . push_back ( stoi ( input )); return res ; } \u200b std :: vector int solve ( string input , int start , int end ){ std :: vector int subset ; if ( start 0 || end = input . size ()) return subset ; \u200b for ( int k = start ; k = end ; ++ k ) { if ( input [ k ] == + || input [ k ] == * || input [ k ] == - ){ std :: vector int x = solve ( input , start , k - 1 ); std :: vector int y = solve ( input , k + 1 , end ); \u200b","title":"0241-different-ways-to-add-parentheses"},{"location":"LeetcodeSolved/0241-different-ways-to-add-parentheses/#0241-different-ways-to-add-parentheses","text":"","title":"0241-different-ways-to-add-parentheses"},{"location":"LeetcodeSolved/0241-different-ways-to-add-parentheses/#problem","text":"Given a string of numbers and operators, return all possible results from computing all the different possible ways to group numbers and operators. The valid operators are + , - and . Example 1: Input: \"2-1-1\" Output: [0, 2] Explanation: ((2-1)-1) = 0 (2-(1-1)) = 2 Example 2: Input: \"2 3-4 5\" Output: [-34, -14, -10, -10, 10] Explanation: (2 (3-(4 5))) = -34 ((2 3)-(4 5)) = -14 ((2 (3-4)) 5) = -10 (2 ((3-4) 5)) = -10 (((2 3)-4)*5) = 10","title":"Problem"},{"location":"LeetcodeSolved/0241-different-ways-to-add-parentheses/#solution","text":"c++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 class Solution { public : vector int res ; vector int diffWaysToCompute ( string input ) { int n = input . size (); for ( int k = 0 ; k input . size (); ++ k ) { if ( input [ k ] == + || input [ k ] == * || input [ k ] == - ){ vector int x = solve ( input , 0 , k - 1 ); vector int y = solve ( input , k + 1 , n - 1 ); for ( int i : x ){ for ( int j : y ){ switch ( input [ k ]){ case + : res . push_back ( i + j ); break ; case - : res . push_back ( i - j ); break ; case * : res . push_back ( i * j ); } } } } } if ( res . empty ()) res . push_back ( stoi ( input )); return res ; } \u200b std :: vector int solve ( string input , int start , int end ){ std :: vector int subset ; if ( start 0 || end = input . size ()) return subset ; \u200b for ( int k = start ; k = end ; ++ k ) { if ( input [ k ] == + || input [ k ] == * || input [ k ] == - ){ std :: vector int x = solve ( input , start , k - 1 ); std :: vector int y = solve ( input , k + 1 , end ); \u200b","title":"Solution"},{"location":"LeetcodeSolved/0268-missing-number/","text":"0268-missing-number Problem Given an array containing n distinct numbers taken from 0, 1, 2, ..., n , find the one that is missing from the array. Example 1: Input: [3,0,1] Output: 2 Example 2: Input: [9,6,4,2,3,5,7,0,1] Output: 8 Note : Your algorithm should run in linear runtime complexity. Could you implement it using only constant extra space complexity? Solution c++ 1 2 3 4 5 6 7 8 9 10 class Solution { public : int missingNumber ( vector int nums ) { long long n = nums . size (); return ( n * ( n + 1 )) / 2 - accumulate ( nums . begin (), nums . end (), 0 ); } }; // XOR with all numbers from zero to n \u200b \u200b","title":"0268-missing-number"},{"location":"LeetcodeSolved/0268-missing-number/#0268-missing-number","text":"","title":"0268-missing-number"},{"location":"LeetcodeSolved/0268-missing-number/#problem","text":"Given an array containing n distinct numbers taken from 0, 1, 2, ..., n , find the one that is missing from the array. Example 1: Input: [3,0,1] Output: 2 Example 2: Input: [9,6,4,2,3,5,7,0,1] Output: 8 Note : Your algorithm should run in linear runtime complexity. Could you implement it using only constant extra space complexity?","title":"Problem"},{"location":"LeetcodeSolved/0268-missing-number/#solution","text":"c++ 1 2 3 4 5 6 7 8 9 10 class Solution { public : int missingNumber ( vector int nums ) { long long n = nums . size (); return ( n * ( n + 1 )) / 2 - accumulate ( nums . begin (), nums . end (), 0 ); } }; // XOR with all numbers from zero to n \u200b \u200b","title":"Solution"},{"location":"LeetcodeSolved/0279-perfect-squares/","text":"0279-perfect-squares Problem Given a positive integer n , find the least number of perfect square numbers (for example, 1, 4, 9, 16, ... ) which sum to n . Example 1: Input: n = 12 Output: 3 Explanation: 12 = 4 + 4 + 4. Example 2: Input: n = 13 Output: 2 Explanation: 13 = 4 + 9. Solution c++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 class Solution { public : int numSquares ( int n ) { vector int data ( n + 1 , INT_MAX ); data [ 0 ] = 0 ; // Path to reach till numbers via minimum perfect squares for ( int i = 1 ; i = n ; i ++ ){ for ( int j = 1 ; j * j = i ; j ++ ){ data [ i ] = min ( data [ i - j * j ] + 1 , data [ i ]); } } //for(int i=0;i n;i++) cout data[i] ; return data [ n ]; } }; \u200b","title":"0279-perfect-squares"},{"location":"LeetcodeSolved/0279-perfect-squares/#0279-perfect-squares","text":"","title":"0279-perfect-squares"},{"location":"LeetcodeSolved/0279-perfect-squares/#problem","text":"Given a positive integer n , find the least number of perfect square numbers (for example, 1, 4, 9, 16, ... ) which sum to n . Example 1: Input: n = 12 Output: 3 Explanation: 12 = 4 + 4 + 4. Example 2: Input: n = 13 Output: 2 Explanation: 13 = 4 + 9.","title":"Problem"},{"location":"LeetcodeSolved/0279-perfect-squares/#solution","text":"c++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 class Solution { public : int numSquares ( int n ) { vector int data ( n + 1 , INT_MAX ); data [ 0 ] = 0 ; // Path to reach till numbers via minimum perfect squares for ( int i = 1 ; i = n ; i ++ ){ for ( int j = 1 ; j * j = i ; j ++ ){ data [ i ] = min ( data [ i - j * j ] + 1 , data [ i ]); } } //for(int i=0;i n;i++) cout data[i] ; return data [ n ]; } }; \u200b","title":"Solution"},{"location":"LeetcodeSolved/0287-find-the-duplicate-number/","text":"0287-find-the-duplicate-number Problem Given an array nums containing n + 1 integers where each integer is between 1 and n (inclusive), prove that at least one duplicate number must exist. Assume that there is only one duplicate number, find the duplicate one. Example 1: Input: [1,3,4,2,2] Output: 2 Example 2: Input: [3,1,3,4,2] Output: 3 Note: You must not modify the array (assume the array is read only). You must use only constant, O (1) extra space. Your runtime complexity should be less than O ( n 2 ). There is only one duplicate number in the array, but it could be repeated more than once. Solution c++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 class Solution { public : int findDuplicate ( vector int nums ) { if ( nums . size () = 1 ) return - 1 ; int slow = nums [ 0 ]; int fast = nums [ 0 ]; do { slow = nums [ slow ]; fast = nums [ nums [ fast ]]; } while ( fast != slow ); fast = nums [ 0 ]; while ( slow != fast ){ slow = nums [ slow ]; fast = nums [ fast ]; } return fast ; } }; \u200b","title":"0287-find-the-duplicate-number"},{"location":"LeetcodeSolved/0287-find-the-duplicate-number/#0287-find-the-duplicate-number","text":"","title":"0287-find-the-duplicate-number"},{"location":"LeetcodeSolved/0287-find-the-duplicate-number/#problem","text":"Given an array nums containing n + 1 integers where each integer is between 1 and n (inclusive), prove that at least one duplicate number must exist. Assume that there is only one duplicate number, find the duplicate one. Example 1: Input: [1,3,4,2,2] Output: 2 Example 2: Input: [3,1,3,4,2] Output: 3 Note: You must not modify the array (assume the array is read only). You must use only constant, O (1) extra space. Your runtime complexity should be less than O ( n 2 ). There is only one duplicate number in the array, but it could be repeated more than once.","title":"Problem"},{"location":"LeetcodeSolved/0287-find-the-duplicate-number/#solution","text":"c++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 class Solution { public : int findDuplicate ( vector int nums ) { if ( nums . size () = 1 ) return - 1 ; int slow = nums [ 0 ]; int fast = nums [ 0 ]; do { slow = nums [ slow ]; fast = nums [ nums [ fast ]]; } while ( fast != slow ); fast = nums [ 0 ]; while ( slow != fast ){ slow = nums [ slow ]; fast = nums [ fast ]; } return fast ; } }; \u200b","title":"Solution"},{"location":"LeetcodeSolved/0289-game-of-life/","text":"0289-game-of-life Problem According to the Wikipedia's article : \"The Game of Life , also known simply as Life , is a cellular automaton devised by the British mathematician John Horton Conway in 1970.\" Given a board with m by n cells, each cell has an initial state live (1) or dead (0). Each cell interacts with its eight neighbors (horizontal, vertical, diagonal) using the following four rules (taken from the above Wikipedia article): Any live cell with fewer than two live neighbors dies, as if caused by under-population. Any live cell with two or three live neighbors lives on to the next generation. Any live cell with more than three live neighbors dies, as if by over-population.. Any dead cell with exactly three live neighbors becomes a live cell, as if by reproduction. Write a function to compute the next state (after one update) of the board given its current state. The next state is created by applying the above rules simultaneously to every cell in the current state, where births and deaths occur simultaneously. Example: Input: [ [0,1,0], [0,0,1], [1,1,1], [0,0,0] ] Output: [ [0,0,0], [1,0,1], [0,1,1], [0,1,0] ] Follow up : Could you solve it in-place? Remember that the board needs to be updated at the same time: You cannot update some cells first and then use their updated values to update other cells. In this question, we represent the board using a 2D array. In principle, the board is infinite, which would cause problems when the active area encroaches the border of the array. How would you address these problems? Solution c++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 class Solution { public : void gameOfLife ( vector vector int board ) { int m = board . size (); int n = board [ 0 ]. size (); for ( int i = 0 ; i m ; i ++ ){ for ( int j = 0 ; j n ; j ++ ){ update ( board , i , j ); } } for ( int i = 0 ; i m ; i ++ ){ for ( int j = 0 ; j n ; j ++ ){ if ( board [ i ][ j ] == INT_MIN ) board [ i ][ j ] = 1 ; if ( board [ i ][ j ] == INT_MAX ) board [ i ][ j ] = 0 ; } } } void update ( vector vector int board , int i , int j ){ int m = board . size (); int n = board [ 0 ]. size (); int row [] = { - 1 , - 1 , - 1 , 0 , 0 , 1 , 1 , 1 }; int col [] = { - 1 , 0 , 1 , - 1 , 1 , - 1 , 0 , 1 }; int ones = 0 , zeros = 0 ; for ( int k = 0 ; k 8 ; k ++ ){ int x = i + row [ k ]; int y = j + col [ k ]; if ( x = 0 x m y = 0 y n ){ if ( board [ x ][ y ] == INT_MIN || board [ x ][ y ] == 0 ) zeros ++ ; else ones ++ ; } } if ( board [ i ][ j ] == 0 ones == 3 ){ board [ i ][ j ] = INT_MIN ; } if ( board [ i ][ j ] == 1 ){ \u200b","title":"0289-game-of-life"},{"location":"LeetcodeSolved/0289-game-of-life/#0289-game-of-life","text":"","title":"0289-game-of-life"},{"location":"LeetcodeSolved/0289-game-of-life/#problem","text":"According to the Wikipedia's article : \"The Game of Life , also known simply as Life , is a cellular automaton devised by the British mathematician John Horton Conway in 1970.\" Given a board with m by n cells, each cell has an initial state live (1) or dead (0). Each cell interacts with its eight neighbors (horizontal, vertical, diagonal) using the following four rules (taken from the above Wikipedia article): Any live cell with fewer than two live neighbors dies, as if caused by under-population. Any live cell with two or three live neighbors lives on to the next generation. Any live cell with more than three live neighbors dies, as if by over-population.. Any dead cell with exactly three live neighbors becomes a live cell, as if by reproduction. Write a function to compute the next state (after one update) of the board given its current state. The next state is created by applying the above rules simultaneously to every cell in the current state, where births and deaths occur simultaneously. Example: Input: [ [0,1,0], [0,0,1], [1,1,1], [0,0,0] ] Output: [ [0,0,0], [1,0,1], [0,1,1], [0,1,0] ] Follow up : Could you solve it in-place? Remember that the board needs to be updated at the same time: You cannot update some cells first and then use their updated values to update other cells. In this question, we represent the board using a 2D array. In principle, the board is infinite, which would cause problems when the active area encroaches the border of the array. How would you address these problems?","title":"Problem"},{"location":"LeetcodeSolved/0289-game-of-life/#solution","text":"c++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 class Solution { public : void gameOfLife ( vector vector int board ) { int m = board . size (); int n = board [ 0 ]. size (); for ( int i = 0 ; i m ; i ++ ){ for ( int j = 0 ; j n ; j ++ ){ update ( board , i , j ); } } for ( int i = 0 ; i m ; i ++ ){ for ( int j = 0 ; j n ; j ++ ){ if ( board [ i ][ j ] == INT_MIN ) board [ i ][ j ] = 1 ; if ( board [ i ][ j ] == INT_MAX ) board [ i ][ j ] = 0 ; } } } void update ( vector vector int board , int i , int j ){ int m = board . size (); int n = board [ 0 ]. size (); int row [] = { - 1 , - 1 , - 1 , 0 , 0 , 1 , 1 , 1 }; int col [] = { - 1 , 0 , 1 , - 1 , 1 , - 1 , 0 , 1 }; int ones = 0 , zeros = 0 ; for ( int k = 0 ; k 8 ; k ++ ){ int x = i + row [ k ]; int y = j + col [ k ]; if ( x = 0 x m y = 0 y n ){ if ( board [ x ][ y ] == INT_MIN || board [ x ][ y ] == 0 ) zeros ++ ; else ones ++ ; } } if ( board [ i ][ j ] == 0 ones == 3 ){ board [ i ][ j ] = INT_MIN ; } if ( board [ i ][ j ] == 1 ){ \u200b","title":"Solution"},{"location":"LeetcodeSolved/0295-find-median-from-data-stream/","text":"0295-find-median-from-data-stream Problem Median is the middle value in an ordered integer list. If the size of the list is even, there is no middle value. So the median is the mean of the two middle value. For example, [2,3,4] , the median is 3 [2,3] , the median is (2 + 3) / 2 = 2.5 Design a data structure that supports the following two operations: void addNum(int num) - Add a integer number from the data stream to the data structure. double findMedian() - Return the median of all elements so far. Example: addNum(1) addNum(2) findMedian() - 1.5 addNum(3) findMedian() - 2 Follow up: If all integer numbers from the stream are between 0 and 100, how would you optimize it? If 99% of all integer numbers from the stream are between 0 and 100, how would you optimize it? Solution c++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 // Two heap solution class MedianFinder { priority_queue int max_heap ; priority_queue int , vector int , greater int min_heap ; public : /** initialize your data structure here. */ MedianFinder () { } void addNum ( int num ) { max_heap . push ( num ); min_heap . push ( max_heap . top ()); max_heap . pop (); if ( max_heap . size () min_heap . size ()){ max_heap . push ( min_heap . top ()); min_heap . pop (); } } double findMedian () { if ( max_heap . size () == min_heap . size ()) return ( max_heap . top () + min_heap . top ()) / 2.0 ; return max_heap . top (); } }; \u200b /** * Your MedianFinder object will be instantiated and called as such: * MedianFinder* obj = new MedianFinder(); * obj- addNum(num); * double param_2 = obj- findMedian(); */ \u200b","title":"0295-find-median-from-data-stream"},{"location":"LeetcodeSolved/0295-find-median-from-data-stream/#0295-find-median-from-data-stream","text":"","title":"0295-find-median-from-data-stream"},{"location":"LeetcodeSolved/0295-find-median-from-data-stream/#problem","text":"Median is the middle value in an ordered integer list. If the size of the list is even, there is no middle value. So the median is the mean of the two middle value. For example, [2,3,4] , the median is 3 [2,3] , the median is (2 + 3) / 2 = 2.5 Design a data structure that supports the following two operations: void addNum(int num) - Add a integer number from the data stream to the data structure. double findMedian() - Return the median of all elements so far. Example: addNum(1) addNum(2) findMedian() - 1.5 addNum(3) findMedian() - 2 Follow up: If all integer numbers from the stream are between 0 and 100, how would you optimize it? If 99% of all integer numbers from the stream are between 0 and 100, how would you optimize it?","title":"Problem"},{"location":"LeetcodeSolved/0295-find-median-from-data-stream/#solution","text":"c++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 // Two heap solution class MedianFinder { priority_queue int max_heap ; priority_queue int , vector int , greater int min_heap ; public : /** initialize your data structure here. */ MedianFinder () { } void addNum ( int num ) { max_heap . push ( num ); min_heap . push ( max_heap . top ()); max_heap . pop (); if ( max_heap . size () min_heap . size ()){ max_heap . push ( min_heap . top ()); min_heap . pop (); } } double findMedian () { if ( max_heap . size () == min_heap . size ()) return ( max_heap . top () + min_heap . top ()) / 2.0 ; return max_heap . top (); } }; \u200b /** * Your MedianFinder object will be instantiated and called as such: * MedianFinder* obj = new MedianFinder(); * obj- addNum(num); * double param_2 = obj- findMedian(); */ \u200b","title":"Solution"},{"location":"LeetcodeSolved/0322-coin-change/","text":"0322-coin-change Problem You are given coins of different denominations and a total amount of money amount . Write a function to compute the fewest number of coins that you need to make up that amount. If that amount of money cannot be made up by any combination of the coins, return -1 . Example 1: Input: coins = [1, 2, 5] , amount = 11 Output: 3 Explanation: 11 = 5 + 5 + 1 Example 2: Input: coins = [2] , amount = 3 Output: -1 Note : You may assume that you have an infinite number of each kind of coin. Solution c++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 class Solution { public : int coinChange ( vector int coins , int amount ) { if ( amount 1 ) return 0 ; vector int dp ( amount + 1 , INT_MAX ); dp [ 0 ] = 0 ; for ( int i = 1 ; i = amount ; i ++ ){ for ( int coin : coins ){ if ( coin = i ){ dp [ i ] = min ( -- dp [ i ], dp [ i - coin ]) + 1 ; } } } return dp [ amount ] == INT_MAX ? - 1 : dp [ amount ]; } }; \u200b \u200b","title":"0322-coin-change"},{"location":"LeetcodeSolved/0322-coin-change/#0322-coin-change","text":"","title":"0322-coin-change"},{"location":"LeetcodeSolved/0322-coin-change/#problem","text":"You are given coins of different denominations and a total amount of money amount . Write a function to compute the fewest number of coins that you need to make up that amount. If that amount of money cannot be made up by any combination of the coins, return -1 . Example 1: Input: coins = [1, 2, 5] , amount = 11 Output: 3 Explanation: 11 = 5 + 5 + 1 Example 2: Input: coins = [2] , amount = 3 Output: -1 Note : You may assume that you have an infinite number of each kind of coin.","title":"Problem"},{"location":"LeetcodeSolved/0322-coin-change/#solution","text":"c++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 class Solution { public : int coinChange ( vector int coins , int amount ) { if ( amount 1 ) return 0 ; vector int dp ( amount + 1 , INT_MAX ); dp [ 0 ] = 0 ; for ( int i = 1 ; i = amount ; i ++ ){ for ( int coin : coins ){ if ( coin = i ){ dp [ i ] = min ( -- dp [ i ], dp [ i - coin ]) + 1 ; } } } return dp [ amount ] == INT_MAX ? - 1 : dp [ amount ]; } }; \u200b \u200b","title":"Solution"},{"location":"LeetcodeSolved/0338-counting-bits/","text":"0338-counting-bits Problem Given a non negative integer number num . For every numbers i in the range 0 \u2264 i \u2264 num calculate the number of 1's in their binary representation and return them as an array. Example 1: Input: 2 Output: [0,1,1] Example 2: Input: 5 Output: [0,1,1,2,1,2] Follow up: It is very easy to come up with a solution with run time O(n*sizeof(integer)) . But can you do it in linear time O(n) /possibly in a single pass? Space complexity should be O(n) . Can you do it like a boss? Do it without using any builtin function like __builtin_popcount in c++ or in any other language. Solution c++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 class Solution { public : vector int countBits ( int n ) { if ( n == 0 ) return { 0 }; vector int ans ( n + 1 ); ans [ 0 ] = 0 ; ans [ 1 ] = 1 ; for ( int i = 2 ; i = n ; i ++ ){ if ( i ( i - 1 )) ans [ i ] = 1 + ans [ i ( i - 1 )]; else ans [ i ] = 1 ; } return ans ; } // n n-1 drops the leftmost set bit }; \u200b","title":"0338-counting-bits"},{"location":"LeetcodeSolved/0338-counting-bits/#0338-counting-bits","text":"","title":"0338-counting-bits"},{"location":"LeetcodeSolved/0338-counting-bits/#problem","text":"Given a non negative integer number num . For every numbers i in the range 0 \u2264 i \u2264 num calculate the number of 1's in their binary representation and return them as an array. Example 1: Input: 2 Output: [0,1,1] Example 2: Input: 5 Output: [0,1,1,2,1,2] Follow up: It is very easy to come up with a solution with run time O(n*sizeof(integer)) . But can you do it in linear time O(n) /possibly in a single pass? Space complexity should be O(n) . Can you do it like a boss? Do it without using any builtin function like __builtin_popcount in c++ or in any other language.","title":"Problem"},{"location":"LeetcodeSolved/0338-counting-bits/#solution","text":"c++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 class Solution { public : vector int countBits ( int n ) { if ( n == 0 ) return { 0 }; vector int ans ( n + 1 ); ans [ 0 ] = 0 ; ans [ 1 ] = 1 ; for ( int i = 2 ; i = n ; i ++ ){ if ( i ( i - 1 )) ans [ i ] = 1 + ans [ i ( i - 1 )]; else ans [ i ] = 1 ; } return ans ; } // n n-1 drops the leftmost set bit }; \u200b","title":"Solution"},{"location":"LeetcodeSolved/0347-top-k-frequent-elements/","text":"0347-top-k-frequent-elements Problem Given a non-empty array of integers, return the k most frequent elements. Example 1: Input: nums = [1,1,1,2,2,3] , k = 2 Output: [1,2] Example 2: Input: nums = [1] , k = 1 Output: [1] Note: You may assume k is always valid, 1 \u2264 k \u2264 number of unique elements. Your algorithm's time complexity must be better than O( n log n ), where n is the array's size. Solution c++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 class Solution { public : vector int topKFrequent ( vector int nums , int k ) { vector int ans ; unordered_map int , int m ; for ( int num : nums ) m [ num ] ++ ; priority_queue pair int , int heap ; for ( auto tmp : m ){ heap . push ({ tmp . second , tmp . first }); // freq val if ( heap . size () m . size () - k ){ ans . push_back ( heap . top (). second ); heap . pop (); if ( ans . size () == k ) break ; } } // while(ans.size() k){ // ans.push_back(heap.top().second); // heap.pop(); // } return ans ; } }; \u200b","title":"0347-top-k-frequent-elements"},{"location":"LeetcodeSolved/0347-top-k-frequent-elements/#0347-top-k-frequent-elements","text":"","title":"0347-top-k-frequent-elements"},{"location":"LeetcodeSolved/0347-top-k-frequent-elements/#problem","text":"Given a non-empty array of integers, return the k most frequent elements. Example 1: Input: nums = [1,1,1,2,2,3] , k = 2 Output: [1,2] Example 2: Input: nums = [1] , k = 1 Output: [1] Note: You may assume k is always valid, 1 \u2264 k \u2264 number of unique elements. Your algorithm's time complexity must be better than O( n log n ), where n is the array's size.","title":"Problem"},{"location":"LeetcodeSolved/0347-top-k-frequent-elements/#solution","text":"c++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 class Solution { public : vector int topKFrequent ( vector int nums , int k ) { vector int ans ; unordered_map int , int m ; for ( int num : nums ) m [ num ] ++ ; priority_queue pair int , int heap ; for ( auto tmp : m ){ heap . push ({ tmp . second , tmp . first }); // freq val if ( heap . size () m . size () - k ){ ans . push_back ( heap . top (). second ); heap . pop (); if ( ans . size () == k ) break ; } } // while(ans.size() k){ // ans.push_back(heap.top().second); // heap.pop(); // } return ans ; } }; \u200b","title":"Solution"},{"location":"LeetcodeSolved/0363-max-sum-of-rectangle-no-larger-than-k/","text":"0363-max-sum-of-rectangle-no-larger-than-k Problem Given a non-empty 2D matrix matrix and an integer k , find the max sum of a rectangle in the matrix such that its sum is no larger than k . Example: Input: matrix = [[1,0,1],[0,-2,3]] , k = 2 Output: 2 Explanation: Because the sum of rectangle [[0, 1], [-2, 3]] is 2, and 2 is the max number no larger than k (k = 2). Note: The rectangle inside the matrix must have an area 0. What if the number of rows is much larger than the number of columns? Solution c++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 // Two imp concept // 1. 2D dp kadane s algo // 2. Max sum subarray with constraint class Solution { int res ; public : int maxSumSubmatrix ( vector vector int matrix , int k ) { int m = matrix . size (); int n = matrix [ 0 ]. size (); res = INT_MIN ; std :: vector int dp ( m , 0 ); \u200b for ( int i = 0 ; i n ; ++ i ) { for ( int j = i ; j n ; ++ j ) { for ( int k = 0 ; k m ; ++ k ) { dp [ k ] += matrix [ k ][ j ]; } getSubArray ( dp , k ); \u200b } dp = std :: vector int ( m , 0 ); } return res ; } \u200b void getSubArray ( std :: vector int dp , int k ){ set int cumSet ; cumSet . insert ( 0 ); int cumSum = 0 , n = dp . size (); int best = INT_MIN ; for ( int i = 0 ; i n ; ++ i ) { cumSum += dp [ i ]; auto it = cumSet . lower_bound ( cumSum - k ); if ( it != cumSet . end ()){ best = max ( best , cumSum - * it ); } cumSet . insert ( cumSum ); } res = max ( res , best ); } }; \u200b","title":"0363-max-sum-of-rectangle-no-larger-than-k"},{"location":"LeetcodeSolved/0363-max-sum-of-rectangle-no-larger-than-k/#0363-max-sum-of-rectangle-no-larger-than-k","text":"","title":"0363-max-sum-of-rectangle-no-larger-than-k"},{"location":"LeetcodeSolved/0363-max-sum-of-rectangle-no-larger-than-k/#problem","text":"Given a non-empty 2D matrix matrix and an integer k , find the max sum of a rectangle in the matrix such that its sum is no larger than k . Example: Input: matrix = [[1,0,1],[0,-2,3]] , k = 2 Output: 2 Explanation: Because the sum of rectangle [[0, 1], [-2, 3]] is 2, and 2 is the max number no larger than k (k = 2). Note: The rectangle inside the matrix must have an area 0. What if the number of rows is much larger than the number of columns?","title":"Problem"},{"location":"LeetcodeSolved/0363-max-sum-of-rectangle-no-larger-than-k/#solution","text":"c++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 // Two imp concept // 1. 2D dp kadane s algo // 2. Max sum subarray with constraint class Solution { int res ; public : int maxSumSubmatrix ( vector vector int matrix , int k ) { int m = matrix . size (); int n = matrix [ 0 ]. size (); res = INT_MIN ; std :: vector int dp ( m , 0 ); \u200b for ( int i = 0 ; i n ; ++ i ) { for ( int j = i ; j n ; ++ j ) { for ( int k = 0 ; k m ; ++ k ) { dp [ k ] += matrix [ k ][ j ]; } getSubArray ( dp , k ); \u200b } dp = std :: vector int ( m , 0 ); } return res ; } \u200b void getSubArray ( std :: vector int dp , int k ){ set int cumSet ; cumSet . insert ( 0 ); int cumSum = 0 , n = dp . size (); int best = INT_MIN ; for ( int i = 0 ; i n ; ++ i ) { cumSum += dp [ i ]; auto it = cumSet . lower_bound ( cumSum - k ); if ( it != cumSet . end ()){ best = max ( best , cumSum - * it ); } cumSet . insert ( cumSum ); } res = max ( res , best ); } }; \u200b","title":"Solution"},{"location":"LeetcodeSolved/0380-insert-delete-getrandom-o1/","text":"0380-insert-delete-getrandom-o1 Problem Design a data structure that supports all following operations in average O(1) time. insert(val) : Inserts an item val to the set if not already present. remove(val) : Removes an item val from the set if present. getRandom : Returns a random element from current set of elements. Each element must have the same probability of being returned. Example: // Init an empty set. RandomizedSet randomSet = new RandomizedSet(); // Inserts 1 to the set. Returns true as 1 was inserted successfully. randomSet.insert(1); // Returns false as 2 does not exist in the set. randomSet.remove(2); // Inserts 2 to the set, returns true. Set now contains [1,2]. randomSet.insert(2); // getRandom should return either 1 or 2 randomly. randomSet.getRandom(); // Removes 1 from the set, returns true. Set now contains [2]. randomSet.remove(1); // 2 was already in the set, so return false. randomSet.insert(2); // Since 2 is the only number in the set, getRandom always return 2. randomSet.getRandom(); Solution c++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 class RandomizedSet { unordered_map int , int m ; vector int v ; public : /** Initialize your data structure here. */ RandomizedSet () { } /** Inserts a value to the set. Returns true if the set did not already contain the specified element. */ bool insert ( int val ) { if ( m . count ( val ) == 1 ) return false ; v . push_back ( val ); m [ val ] = v . size () - 1 ; return true ; } /** Removes a value from the set. Returns true if the set contained the specified element. */ bool remove ( int val ) { if ( m . count ( val ) == 0 ) return false ; int i = m [ val ]; swap ( v [ i ], v [ v . size () - 1 ]); m [ v [ i ]] = i ; m . erase ( val ); v . pop_back (); return true ; } /** Get a random element from the set. */ int getRandom () { int size = m . size (); if ( size == 0 ) return - 1 ; int idx = rand () % size ; return v [ idx ]; } }; \u200b /** * Your RandomizedSet object will be instantiated and called as such: * RandomizedSet* obj = new RandomizedSet(); * bool param_1 = obj- insert(val); * bool param_2 = obj- remove(val); * int param_3 = obj- getRandom(); */ \u200b","title":"0380-insert-delete-getrandom-o1"},{"location":"LeetcodeSolved/0380-insert-delete-getrandom-o1/#0380-insert-delete-getrandom-o1","text":"","title":"0380-insert-delete-getrandom-o1"},{"location":"LeetcodeSolved/0380-insert-delete-getrandom-o1/#problem","text":"Design a data structure that supports all following operations in average O(1) time. insert(val) : Inserts an item val to the set if not already present. remove(val) : Removes an item val from the set if present. getRandom : Returns a random element from current set of elements. Each element must have the same probability of being returned. Example: // Init an empty set. RandomizedSet randomSet = new RandomizedSet(); // Inserts 1 to the set. Returns true as 1 was inserted successfully. randomSet.insert(1); // Returns false as 2 does not exist in the set. randomSet.remove(2); // Inserts 2 to the set, returns true. Set now contains [1,2]. randomSet.insert(2); // getRandom should return either 1 or 2 randomly. randomSet.getRandom(); // Removes 1 from the set, returns true. Set now contains [2]. randomSet.remove(1); // 2 was already in the set, so return false. randomSet.insert(2); // Since 2 is the only number in the set, getRandom always return 2. randomSet.getRandom();","title":"Problem"},{"location":"LeetcodeSolved/0380-insert-delete-getrandom-o1/#solution","text":"c++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 class RandomizedSet { unordered_map int , int m ; vector int v ; public : /** Initialize your data structure here. */ RandomizedSet () { } /** Inserts a value to the set. Returns true if the set did not already contain the specified element. */ bool insert ( int val ) { if ( m . count ( val ) == 1 ) return false ; v . push_back ( val ); m [ val ] = v . size () - 1 ; return true ; } /** Removes a value from the set. Returns true if the set contained the specified element. */ bool remove ( int val ) { if ( m . count ( val ) == 0 ) return false ; int i = m [ val ]; swap ( v [ i ], v [ v . size () - 1 ]); m [ v [ i ]] = i ; m . erase ( val ); v . pop_back (); return true ; } /** Get a random element from the set. */ int getRandom () { int size = m . size (); if ( size == 0 ) return - 1 ; int idx = rand () % size ; return v [ idx ]; } }; \u200b /** * Your RandomizedSet object will be instantiated and called as such: * RandomizedSet* obj = new RandomizedSet(); * bool param_1 = obj- insert(val); * bool param_2 = obj- remove(val); * int param_3 = obj- getRandom(); */ \u200b","title":"Solution"},{"location":"LeetcodeSolved/0394-decode-string/","text":"0394-decode-string Problem Given an encoded string, return it's decoded string. The encoding rule is: k[encoded_string] , where the encoded_string inside the square brackets is being repeated exactly k times. Note that k is guaranteed to be a positive integer. You may assume that the input string is always valid; No extra white spaces, square brackets are well-formed, etc. Furthermore, you may assume that the original data does not contain any digits and that digits are only for those repeat numbers, k . For example, there won't be input like 3a or 2[4] . Examples: s = \"3[a]2[bc]\", return \"aaabcbc\". s = \"3[a2[c]]\", return \"accaccacc\". s = \"2[abc]3[cd]ef\", return \"abcabccdcdcdef\". Solution c++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 // if any digit encounters we need to get the number by traversing the string. if ( s [ i ] = 1 s [ i ] = 9 ){ int temp = i ; while ( s [ temp ] != [ ) temp ++ ; //number starts from i and goes till temp-1 int repeat = getRepeat ( s , i , temp ); int start = temp + 1 ; int end = hash [ temp ]; string subStr = decodePart ( s , start , end ); /** * input: (2[ac2[d]],2,8) * output: acddacdd */ while ( repeat -- ){ res . append ( subStr ); } // Start i after closing square bracket i = hash [ temp ]; } else { res += s [ i ]; } } return res ; } /** returns integer fron string */ int getRepeat ( string s , int start , int end ){ string left ( s . begin () + start , s . begin () + end ); return stoi ( left ); } }; \u200b","title":"0394-decode-string"},{"location":"LeetcodeSolved/0394-decode-string/#0394-decode-string","text":"","title":"0394-decode-string"},{"location":"LeetcodeSolved/0394-decode-string/#problem","text":"Given an encoded string, return it's decoded string. The encoding rule is: k[encoded_string] , where the encoded_string inside the square brackets is being repeated exactly k times. Note that k is guaranteed to be a positive integer. You may assume that the input string is always valid; No extra white spaces, square brackets are well-formed, etc. Furthermore, you may assume that the original data does not contain any digits and that digits are only for those repeat numbers, k . For example, there won't be input like 3a or 2[4] . Examples: s = \"3[a]2[bc]\", return \"aaabcbc\". s = \"3[a2[c]]\", return \"accaccacc\". s = \"2[abc]3[cd]ef\", return \"abcabccdcdcdef\".","title":"Problem"},{"location":"LeetcodeSolved/0394-decode-string/#solution","text":"c++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 // if any digit encounters we need to get the number by traversing the string. if ( s [ i ] = 1 s [ i ] = 9 ){ int temp = i ; while ( s [ temp ] != [ ) temp ++ ; //number starts from i and goes till temp-1 int repeat = getRepeat ( s , i , temp ); int start = temp + 1 ; int end = hash [ temp ]; string subStr = decodePart ( s , start , end ); /** * input: (2[ac2[d]],2,8) * output: acddacdd */ while ( repeat -- ){ res . append ( subStr ); } // Start i after closing square bracket i = hash [ temp ]; } else { res += s [ i ]; } } return res ; } /** returns integer fron string */ int getRepeat ( string s , int start , int end ){ string left ( s . begin () + start , s . begin () + end ); return stoi ( left ); } }; \u200b","title":"Solution"},{"location":"LeetcodeSolved/0416-partition-equal-subset-sum/","text":"0416-partition-equal-subset-sum Problem Given a non-empty array containing only positive integers , find if the array can be partitioned into two subsets such that the sum of elements in both subsets is equal. Note: Each of the array element will not exceed 100. The array size will not exceed 200. Example 1: Input: [1, 5, 11, 5] Output: true Explanation: The array can be partitioned as [1, 5, 5] and [11]. Example 2: Input: [1, 2, 3, 5] Output: false Explanation: The array cannot be partitioned into equal sum subsets. Solution c++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 class Solution { public : bool canPartition ( vector int nums ) { if ( nums . size () == 0 || nums . size () == 1 ) return false ; int sum = accumulate ( nums . begin (), nums . end (), 0 ); if ( sum 1 ) return false ; sum /= 2 ; vector vector int dp ( nums . size (), vector int ( sum + 1 , - 1 )); return canAchieve ( nums , dp , 0 , sum ); } \u200b bool canAchieve ( vector int nums , vector vector int dp , int start , int target ){ if ( target 0 ) return false ; if ( target == 0 ) return true ; if ( start == nums . size ()) return false ; if ( dp [ start ][ target ] != - 1 ) return dp [ start ][ target ]; \u200b for ( int i = start ; i nums . size (); i ++ ){ if ( canAchieve ( nums , dp , i + 1 , target - nums [ i ]) || canAchieve ( nums , dp , i + 1 , target )) return true ; } return dp [ start ][ target ] = false ; } }; \u200b \u200b \u200b","title":"0416-partition-equal-subset-sum"},{"location":"LeetcodeSolved/0416-partition-equal-subset-sum/#0416-partition-equal-subset-sum","text":"","title":"0416-partition-equal-subset-sum"},{"location":"LeetcodeSolved/0416-partition-equal-subset-sum/#problem","text":"Given a non-empty array containing only positive integers , find if the array can be partitioned into two subsets such that the sum of elements in both subsets is equal. Note: Each of the array element will not exceed 100. The array size will not exceed 200. Example 1: Input: [1, 5, 11, 5] Output: true Explanation: The array can be partitioned as [1, 5, 5] and [11]. Example 2: Input: [1, 2, 3, 5] Output: false Explanation: The array cannot be partitioned into equal sum subsets.","title":"Problem"},{"location":"LeetcodeSolved/0416-partition-equal-subset-sum/#solution","text":"c++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 class Solution { public : bool canPartition ( vector int nums ) { if ( nums . size () == 0 || nums . size () == 1 ) return false ; int sum = accumulate ( nums . begin (), nums . end (), 0 ); if ( sum 1 ) return false ; sum /= 2 ; vector vector int dp ( nums . size (), vector int ( sum + 1 , - 1 )); return canAchieve ( nums , dp , 0 , sum ); } \u200b bool canAchieve ( vector int nums , vector vector int dp , int start , int target ){ if ( target 0 ) return false ; if ( target == 0 ) return true ; if ( start == nums . size ()) return false ; if ( dp [ start ][ target ] != - 1 ) return dp [ start ][ target ]; \u200b for ( int i = start ; i nums . size (); i ++ ){ if ( canAchieve ( nums , dp , i + 1 , target - nums [ i ]) || canAchieve ( nums , dp , i + 1 , target )) return true ; } return dp [ start ][ target ] = false ; } }; \u200b \u200b \u200b","title":"Solution"},{"location":"LeetcodeSolved/0430-flatten-a-multilevel-doubly-linked-list/","text":"0430-flatten-a-multilevel-doubly-linked-list Problem You are given a doubly linked list which in addition to the next and previous pointers, it could have a child pointer, which may or may not point to a separate doubly linked list. These child lists may have one or more children of their own, and so on, to produce a multilevel data structure, as shown in the example below. Flatten the list so that all the nodes appear in a single-level, doubly linked list. You are given the head of the first level of the list. Example: Input: 1---2---3---4---5---6--NULL | 7---8---9---10--NULL | 11--12--NULL Output: 1-2-3-7-8-11-12-9-10-4-5-6-NULL Explanation for the above example: Given the following multilevel doubly linked list: We should return the following flattened doubly linked list: Solution c++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 /* * @lc app=leetcode id=430 lang=cpp * * [430] Flatten a Multilevel Doubly Linked List */ /* // Definition for a Node. class Node { public: int val; Node* prev; Node* next; Node* child; \u200b Node() {} \u200b Node(int _val, Node* _prev, Node* _next, Node* _child) { val = _val; prev = _prev; next = _next; child = _child; } }; */ class Solution { public : Node * flatten ( Node * head ) { if ( ! head ) return head ; Node * p = head ; while ( p ){ if ( p - child ){ mergeChild ( p , p - child , p - next ); Node * tmp = p - next ; p - next = p - child ; p - child = NULL ; p = tmp ; \u200b","title":"0430-flatten-a-multilevel-doubly-linked-list"},{"location":"LeetcodeSolved/0430-flatten-a-multilevel-doubly-linked-list/#0430-flatten-a-multilevel-doubly-linked-list","text":"","title":"0430-flatten-a-multilevel-doubly-linked-list"},{"location":"LeetcodeSolved/0430-flatten-a-multilevel-doubly-linked-list/#problem","text":"You are given a doubly linked list which in addition to the next and previous pointers, it could have a child pointer, which may or may not point to a separate doubly linked list. These child lists may have one or more children of their own, and so on, to produce a multilevel data structure, as shown in the example below. Flatten the list so that all the nodes appear in a single-level, doubly linked list. You are given the head of the first level of the list. Example: Input: 1---2---3---4---5---6--NULL | 7---8---9---10--NULL | 11--12--NULL Output: 1-2-3-7-8-11-12-9-10-4-5-6-NULL Explanation for the above example: Given the following multilevel doubly linked list: We should return the following flattened doubly linked list:","title":"Problem"},{"location":"LeetcodeSolved/0430-flatten-a-multilevel-doubly-linked-list/#solution","text":"c++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 /* * @lc app=leetcode id=430 lang=cpp * * [430] Flatten a Multilevel Doubly Linked List */ /* // Definition for a Node. class Node { public: int val; Node* prev; Node* next; Node* child; \u200b Node() {} \u200b Node(int _val, Node* _prev, Node* _next, Node* _child) { val = _val; prev = _prev; next = _next; child = _child; } }; */ class Solution { public : Node * flatten ( Node * head ) { if ( ! head ) return head ; Node * p = head ; while ( p ){ if ( p - child ){ mergeChild ( p , p - child , p - next ); Node * tmp = p - next ; p - next = p - child ; p - child = NULL ; p = tmp ; \u200b","title":"Solution"},{"location":"LeetcodeSolved/0435-non-overlapping-intervals/","text":"0435-non-overlapping-intervals Problem Given a collection of intervals, find the minimum number of intervals you need to remove to make the rest of the intervals non-overlapping. Note: You may assume the interval's end point is always bigger than its start point. Intervals like [1,2] and [2,3] have borders \"touching\" but they don't overlap each other. Example 1: Input: [ [1,2], [2,3], [3,4], [1,3] ] Output: 1 Explanation: [1,3] can be removed and the rest of intervals are non-overlapping. Example 2: Input: [ [1,2], [1,2], [1,2] ] Output: 2 Explanation: You need to remove two [1,2] to make the rest of intervals non-overlapping. Example 3: Input: [ [1,2], [2,3] ] Output: 0 Explanation: You don't need to remove any of the intervals since they're already non-overlapping. NOTE: input types have been changed on April 15, 2019. Please reset to default code definition to get new method signature. Solution c++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 class Solution { public : int eraseOverlapIntervals ( vector vector int ins ) { if ( ins . empty ()) return 0 ; sort ( ins . begin (), ins . end ()); vector vector int res ; res . push_back ( ins [ 0 ]); for ( int i = 0 ; i ins . size (); i ++ ){ int last = res . back ()[ 1 ]; if ( last ins [ i ][ 0 ]){ res . back ()[ 1 ] = min ( last , ins [ i ][ 1 ]); } else { res . push_back ( ins [ i ]); } } return ins . size () - res . size (); } }; //Can be done without res. \u200b","title":"0435-non-overlapping-intervals"},{"location":"LeetcodeSolved/0435-non-overlapping-intervals/#0435-non-overlapping-intervals","text":"","title":"0435-non-overlapping-intervals"},{"location":"LeetcodeSolved/0435-non-overlapping-intervals/#problem","text":"Given a collection of intervals, find the minimum number of intervals you need to remove to make the rest of the intervals non-overlapping. Note: You may assume the interval's end point is always bigger than its start point. Intervals like [1,2] and [2,3] have borders \"touching\" but they don't overlap each other. Example 1: Input: [ [1,2], [2,3], [3,4], [1,3] ] Output: 1 Explanation: [1,3] can be removed and the rest of intervals are non-overlapping. Example 2: Input: [ [1,2], [1,2], [1,2] ] Output: 2 Explanation: You need to remove two [1,2] to make the rest of intervals non-overlapping. Example 3: Input: [ [1,2], [2,3] ] Output: 0 Explanation: You don't need to remove any of the intervals since they're already non-overlapping. NOTE: input types have been changed on April 15, 2019. Please reset to default code definition to get new method signature.","title":"Problem"},{"location":"LeetcodeSolved/0435-non-overlapping-intervals/#solution","text":"c++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 class Solution { public : int eraseOverlapIntervals ( vector vector int ins ) { if ( ins . empty ()) return 0 ; sort ( ins . begin (), ins . end ()); vector vector int res ; res . push_back ( ins [ 0 ]); for ( int i = 0 ; i ins . size (); i ++ ){ int last = res . back ()[ 1 ]; if ( last ins [ i ][ 0 ]){ res . back ()[ 1 ] = min ( last , ins [ i ][ 1 ]); } else { res . push_back ( ins [ i ]); } } return ins . size () - res . size (); } }; //Can be done without res. \u200b","title":"Solution"},{"location":"LeetcodeSolved/0457-circular-array-loop/","text":"0457-circular-array-loop Problem You are given a circular array nums of positive and negative integers. If a number k at an index is positive, then move forward k steps. Conversely, if it's negative (- k ), move backward k steps. Since the array is circular, you may assume that the last element's next element is the first element, and the first element's previous element is the last element. Determine if there is a loop (or a cycle) in nums . A cycle must start and end at the same index and the cycle's length 1. Furthermore, movements in a cycle must all follow a single direction. In other words, a cycle must not consist of both forward and backward movements. Example 1: Input: [2,-1,1,2,2] Output: true Explanation: There is a cycle, from index 0 - 2 - 3 - 0. The cycle's length is 3. Example 2: Input: [-1,2] Output: false Explanation: The movement from index 1 - 1 - 1 ... is not a cycle, because the cycle's length is 1. By definition the cycle's length must be greater than 1. Example 3: Input: [-2,1,-1,-2,-2] Output: false Explanation: The movement from index 1 - 2 - 1 - ... is not a cycle, because movement from index 1 - 2 is a forward movement, but movement from index 2 - 1 is a backward movement. All movements in a cycle must follow a single direction. Note: -1000 \u2264 nums[i] \u2264 1000 nums[i] \u2260 0 1 \u2264 nums.length \u2264 5000 Follow up: Could you solve it in O(n) time complexity and O(1) extra space complexity? Solution c++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 class Solution { public : bool circularArrayLoop ( vector int nums ) { int n = nums . size (); vector int v ( n ); for ( int i = 0 ; i n ; i ++ ){ v [ i ] = ((( i + nums [ i ]) % n ) + n ) % n ; } for ( int i = 0 ; i n ; i ++ ){ int slow = i ; int fast = i ; int sign = ( nums [ i ] 0 ? 1 : - 1 ); int flag = 1 , visited = 0 ; while ( 1 ){ if ( sign 0 ( nums [ v [ fast ]] 0 || nums [ v [ v [ fast ]]] 0 || nums [ v [ slow ]] 0 )){ flag = 0 ; break ; } if ( sign 0 ( nums [ v [ fast ]] 0 || nums [ v [ v [ fast ]]] 0 || nums [ v [ slow ]] 0 )){ flag = 0 ; break ; } if ( fast == v [ fast ] || v [ fast ] == v [ v [ fast ]] || slow == v [ slow ]){ flag = 0 ; break ; } fast = v [ v [ fast ]]; slow = v [ slow ]; visited ++ ; if ( fast == slow ) break ; if ( visited == n ){ flag = 0 ; break ; } } if ( flag ) return true ; } return false ; } }; \u200b","title":"0457-circular-array-loop"},{"location":"LeetcodeSolved/0457-circular-array-loop/#0457-circular-array-loop","text":"","title":"0457-circular-array-loop"},{"location":"LeetcodeSolved/0457-circular-array-loop/#problem","text":"You are given a circular array nums of positive and negative integers. If a number k at an index is positive, then move forward k steps. Conversely, if it's negative (- k ), move backward k steps. Since the array is circular, you may assume that the last element's next element is the first element, and the first element's previous element is the last element. Determine if there is a loop (or a cycle) in nums . A cycle must start and end at the same index and the cycle's length 1. Furthermore, movements in a cycle must all follow a single direction. In other words, a cycle must not consist of both forward and backward movements. Example 1: Input: [2,-1,1,2,2] Output: true Explanation: There is a cycle, from index 0 - 2 - 3 - 0. The cycle's length is 3. Example 2: Input: [-1,2] Output: false Explanation: The movement from index 1 - 1 - 1 ... is not a cycle, because the cycle's length is 1. By definition the cycle's length must be greater than 1. Example 3: Input: [-2,1,-1,-2,-2] Output: false Explanation: The movement from index 1 - 2 - 1 - ... is not a cycle, because movement from index 1 - 2 is a forward movement, but movement from index 2 - 1 is a backward movement. All movements in a cycle must follow a single direction. Note: -1000 \u2264 nums[i] \u2264 1000 nums[i] \u2260 0 1 \u2264 nums.length \u2264 5000 Follow up: Could you solve it in O(n) time complexity and O(1) extra space complexity?","title":"Problem"},{"location":"LeetcodeSolved/0457-circular-array-loop/#solution","text":"c++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 class Solution { public : bool circularArrayLoop ( vector int nums ) { int n = nums . size (); vector int v ( n ); for ( int i = 0 ; i n ; i ++ ){ v [ i ] = ((( i + nums [ i ]) % n ) + n ) % n ; } for ( int i = 0 ; i n ; i ++ ){ int slow = i ; int fast = i ; int sign = ( nums [ i ] 0 ? 1 : - 1 ); int flag = 1 , visited = 0 ; while ( 1 ){ if ( sign 0 ( nums [ v [ fast ]] 0 || nums [ v [ v [ fast ]]] 0 || nums [ v [ slow ]] 0 )){ flag = 0 ; break ; } if ( sign 0 ( nums [ v [ fast ]] 0 || nums [ v [ v [ fast ]]] 0 || nums [ v [ slow ]] 0 )){ flag = 0 ; break ; } if ( fast == v [ fast ] || v [ fast ] == v [ v [ fast ]] || slow == v [ slow ]){ flag = 0 ; break ; } fast = v [ v [ fast ]]; slow = v [ slow ]; visited ++ ; if ( fast == slow ) break ; if ( visited == n ){ flag = 0 ; break ; } } if ( flag ) return true ; } return false ; } }; \u200b","title":"Solution"},{"location":"LeetcodeSolved/0547-friend-circles/","text":"0547-friend-circles Problem There are N students in a class. Some of them are friends, while some are not. Their friendship is transitive in nature. For example, if A is a direct friend of B, and B is a direct friend of C, then A is an indirect friend of C. And we defined a friend circle is a group of students who are direct or indirect friends. Given a N*N matrix M representing the friend relationship between students in the class. If M[i][j] = 1, then the i th and j th students are direct friends with each other, otherwise not. And you have to output the total number of friend circles among all the students. Example 1: Input: [[1,1,0], [1,1,0], [0,0,1]] Output: 2 Explanation: The 0 th and 1 st students are direct friends, so they are in a friend circle. The 2 nd student himself is in a friend circle. So return 2. Example 2: Input: [[1,1,0], [1,1,1], [0,1,1]] Output: 1 Explanation: The 0 th and 1 st students are direct friends, the 1 st and 2 nd students are direct friends, so the 0 th and 2 nd students are indirect friends. All of them are in the same friend circle, so return 1. Note: N is in range [1,200]. M[i][i] = 1 for all students. If M[i][j] = 1, then M[j][i] = 1. Solution c++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 class Solution { public : int findCircleNum ( vector vector int M ) { if ( M . size () == 0 ) return 0 ; int row = M . size (); int col = M [ 0 ]. size (); int counter = 0 ; vector int visited ( row , 0 ); stack int dfs ; for ( int i = 0 ; i row ; i ++ ){ if ( ! visited [ i ]){ dfs . push ( i ); counter ++ ; while ( ! dfs . empty ()){ int curr = dfs . top (); dfs . pop (); visited [ curr ] = 1 ; for ( int j = 0 ; j col ; j ++ ){ if ( ! visited [ j ] M [ curr ][ j ]) { dfs . push ( j ); } } } } } return counter ; } }; \u200b","title":"0547-friend-circles"},{"location":"LeetcodeSolved/0547-friend-circles/#0547-friend-circles","text":"","title":"0547-friend-circles"},{"location":"LeetcodeSolved/0547-friend-circles/#problem","text":"There are N students in a class. Some of them are friends, while some are not. Their friendship is transitive in nature. For example, if A is a direct friend of B, and B is a direct friend of C, then A is an indirect friend of C. And we defined a friend circle is a group of students who are direct or indirect friends. Given a N*N matrix M representing the friend relationship between students in the class. If M[i][j] = 1, then the i th and j th students are direct friends with each other, otherwise not. And you have to output the total number of friend circles among all the students. Example 1: Input: [[1,1,0], [1,1,0], [0,0,1]] Output: 2 Explanation: The 0 th and 1 st students are direct friends, so they are in a friend circle. The 2 nd student himself is in a friend circle. So return 2. Example 2: Input: [[1,1,0], [1,1,1], [0,1,1]] Output: 1 Explanation: The 0 th and 1 st students are direct friends, the 1 st and 2 nd students are direct friends, so the 0 th and 2 nd students are indirect friends. All of them are in the same friend circle, so return 1. Note: N is in range [1,200]. M[i][i] = 1 for all students. If M[i][j] = 1, then M[j][i] = 1.","title":"Problem"},{"location":"LeetcodeSolved/0547-friend-circles/#solution","text":"c++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 class Solution { public : int findCircleNum ( vector vector int M ) { if ( M . size () == 0 ) return 0 ; int row = M . size (); int col = M [ 0 ]. size (); int counter = 0 ; vector int visited ( row , 0 ); stack int dfs ; for ( int i = 0 ; i row ; i ++ ){ if ( ! visited [ i ]){ dfs . push ( i ); counter ++ ; while ( ! dfs . empty ()){ int curr = dfs . top (); dfs . pop (); visited [ curr ] = 1 ; for ( int j = 0 ; j col ; j ++ ){ if ( ! visited [ j ] M [ curr ][ j ]) { dfs . push ( j ); } } } } } return counter ; } }; \u200b","title":"Solution"},{"location":"LeetcodeSolved/0572-subtree-of-another-tree/","text":"0572-subtree-of-another-tree Problem Given two non-empty binary trees s and t , check whether tree t has exactly the same structure and node values with a subtree of s . A subtree of s is a tree consists of a node in s and all of this node's descendants. The tree s could also be considered as a subtree of itself. Example 1: Given tree s: 3 / \\ 4 5 / \\ 1 2 Given tree t: 4 / \\ 1 2 Return true , because t has the same structure and node values with a subtree of s. Example 2: Given tree s: 3 / \\ 4 5 / \\ 1 2 / 0 Given tree t: 4 / \\ 1 2 Return false . Solution c++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 /** * Definition for a binary tree node. * struct TreeNode { * int val; * TreeNode *left; * TreeNode *right; * TreeNode(int x) : val(x), left(NULL), right(NULL) {} * }; */ class Solution { public : bool isSubtree ( TreeNode * s , TreeNode * t ) { if ( ! s ! t ) return true ; vector TreeNode * v ; traverseTree ( s , v , t - val ); for ( auto root : v ){ if ( matchTree ( root , t )) return true ; } return false ; } bool matchTree ( TreeNode * a , TreeNode * b ){ if ( ! a ! b ) return true ; if (( a ! b ) || ( b ! a ) || ( a - val != b - val )) return false ; return matchTree ( a - left , b - left ) matchTree ( a - right , b - right ); } void traverseTree ( TreeNode * s , vector TreeNode * v , int rval ){ if ( s == nullptr ) return ; if ( s - val == rval ){ v . push_back ( s ); } traverseTree ( s - left , v , rval ); traverseTree ( s - right , v , rval ); return ; } }; \u200b","title":"0572-subtree-of-another-tree"},{"location":"LeetcodeSolved/0572-subtree-of-another-tree/#0572-subtree-of-another-tree","text":"","title":"0572-subtree-of-another-tree"},{"location":"LeetcodeSolved/0572-subtree-of-another-tree/#problem","text":"Given two non-empty binary trees s and t , check whether tree t has exactly the same structure and node values with a subtree of s . A subtree of s is a tree consists of a node in s and all of this node's descendants. The tree s could also be considered as a subtree of itself. Example 1: Given tree s: 3 / \\ 4 5 / \\ 1 2 Given tree t: 4 / \\ 1 2 Return true , because t has the same structure and node values with a subtree of s. Example 2: Given tree s: 3 / \\ 4 5 / \\ 1 2 / 0 Given tree t: 4 / \\ 1 2 Return false .","title":"Problem"},{"location":"LeetcodeSolved/0572-subtree-of-another-tree/#solution","text":"c++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 /** * Definition for a binary tree node. * struct TreeNode { * int val; * TreeNode *left; * TreeNode *right; * TreeNode(int x) : val(x), left(NULL), right(NULL) {} * }; */ class Solution { public : bool isSubtree ( TreeNode * s , TreeNode * t ) { if ( ! s ! t ) return true ; vector TreeNode * v ; traverseTree ( s , v , t - val ); for ( auto root : v ){ if ( matchTree ( root , t )) return true ; } return false ; } bool matchTree ( TreeNode * a , TreeNode * b ){ if ( ! a ! b ) return true ; if (( a ! b ) || ( b ! a ) || ( a - val != b - val )) return false ; return matchTree ( a - left , b - left ) matchTree ( a - right , b - right ); } void traverseTree ( TreeNode * s , vector TreeNode * v , int rval ){ if ( s == nullptr ) return ; if ( s - val == rval ){ v . push_back ( s ); } traverseTree ( s - left , v , rval ); traverseTree ( s - right , v , rval ); return ; } }; \u200b","title":"Solution"},{"location":"LeetcodeSolved/0583-delete-operation-for-two-strings/","text":"0583-delete-operation-for-two-strings Problem Given two words word1 and word2 , find the minimum number of steps required to make word1 and word2 the same, where in each step you can delete one character in either string. Example 1: Input: \"sea\", \"eat\" Output: 2 Explanation: You need one step to make \"sea\" to \"ea\" and another step to make \"eat\" to \"ea\". Note: The length of given words won't exceed 500. Characters in given words can only be lower-case letters. Solution c++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 class Solution { public : int minDistance ( string word1 , string word2 ) { int n = word1 . size (), m = word2 . size (); if ( n == 0 || m == 0 ) return max ( n , m ); vector vector int dp ( n , vector int ( m , - 1 )); int LCS = comSequence ( word1 , word2 , dp , n - 1 , m - 1 ); return n + m - 2 * LCS ; } int comSequence ( string word1 , string word2 , vector vector int dp , int last1 , int last2 ){ if ( last1 0 || last2 0 ) return 0 ; if ( dp [ last1 ][ last2 ] - 1 ) return dp [ last1 ][ last2 ]; if ( word1 [ last1 ] == word2 [ last2 ]){ dp [ last1 ][ last2 ] = 1 + comSequence ( word1 , word2 , dp , last1 - 1 , last2 - 1 ); } else { dp [ last1 ][ last2 ] = max ( comSequence ( word1 , word2 , dp , last1 - 1 , last2 ), comSequence ( word1 , word2 , dp , last1 , last2 - 1 )); } return dp [ last1 ][ last2 ]; } }; \u200b","title":"0583-delete-operation-for-two-strings"},{"location":"LeetcodeSolved/0583-delete-operation-for-two-strings/#0583-delete-operation-for-two-strings","text":"","title":"0583-delete-operation-for-two-strings"},{"location":"LeetcodeSolved/0583-delete-operation-for-two-strings/#problem","text":"Given two words word1 and word2 , find the minimum number of steps required to make word1 and word2 the same, where in each step you can delete one character in either string. Example 1: Input: \"sea\", \"eat\" Output: 2 Explanation: You need one step to make \"sea\" to \"ea\" and another step to make \"eat\" to \"ea\". Note: The length of given words won't exceed 500. Characters in given words can only be lower-case letters.","title":"Problem"},{"location":"LeetcodeSolved/0583-delete-operation-for-two-strings/#solution","text":"c++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 class Solution { public : int minDistance ( string word1 , string word2 ) { int n = word1 . size (), m = word2 . size (); if ( n == 0 || m == 0 ) return max ( n , m ); vector vector int dp ( n , vector int ( m , - 1 )); int LCS = comSequence ( word1 , word2 , dp , n - 1 , m - 1 ); return n + m - 2 * LCS ; } int comSequence ( string word1 , string word2 , vector vector int dp , int last1 , int last2 ){ if ( last1 0 || last2 0 ) return 0 ; if ( dp [ last1 ][ last2 ] - 1 ) return dp [ last1 ][ last2 ]; if ( word1 [ last1 ] == word2 [ last2 ]){ dp [ last1 ][ last2 ] = 1 + comSequence ( word1 , word2 , dp , last1 - 1 , last2 - 1 ); } else { dp [ last1 ][ last2 ] = max ( comSequence ( word1 , word2 , dp , last1 - 1 , last2 ), comSequence ( word1 , word2 , dp , last1 , last2 - 1 )); } return dp [ last1 ][ last2 ]; } }; \u200b","title":"Solution"},{"location":"LeetcodeSolved/0622-design-circular-queue/","text":"0622-design-circular-queue Problem Design your implementation of the circular queue. The circular queue is a linear data structure in which the operations are performed based on FIFO (First In First Out) principle and the last position is connected back to the first position to make a circle. It is also called \"Ring Buffer\". One of the benefits of the circular queue is that we can make use of the spaces in front of the queue. In a normal queue, once the queue becomes full, we cannot insert the next element even if there is a space in front of the queue. But using the circular queue, we can use the space to store new values. Your implementation should support following operations: MyCircularQueue(k) : Constructor, set the size of the queue to be k. Front : Get the front item from the queue. If the queue is empty, return -1. Rear : Get the last item from the queue. If the queue is empty, return -1. enQueue(value) : Insert an element into the circular queue. Return true if the operation is successful. deQueue() : Delete an element from the circular queue. Return true if the operation is successful. isEmpty() : Checks whether the circular queue is empty or not. isFull() : Checks whether the circular queue is full or not. Example: MyCircularQueue circularQueue = new MyCircularQueue(3); // set the size to be 3 circularQueue.enQueue(1); // return true circularQueue.enQueue(2); // return true circularQueue.enQueue(3); // return true circularQueue.enQueue(4); // return false, the queue is full circularQueue.Rear(); // return 3 circularQueue.isFull(); // return true circularQueue.deQueue(); // return true circularQueue.enQueue(4); // return true circularQueue.Rear(); // return 4 Note: All values will be in the range of [0, 1000]. The number of operations will be in the range of [1, 1000]. Please do not use the built-in Queue library. Solution c++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 class MyCircularQueue { private : vector int data ; int front , rear , qSize ; public : /** Initialize your data structure here. Set the size of the queue to be k. */ MyCircularQueue ( int k ) { qSize = k ; for ( int i = 0 ; i k ; i ++ ) data . push_back ( 0 ); front = rear =- 1 ; } /** Insert an element into the circular queue. Return true if the operation is successful. */ bool enQueue ( int value ) { if ( isFull ()) return false ; if ( rear ==- 1 ) front = 0 ; rear = ( rear + 1 ) % qSize ; data [ rear ] = value ; return true ; } /** Delete an element from the circular queue. Return true if the operation is successful. */ bool deQueue () { if ( isEmpty ()) return false ; if ( front == rear ){ front = rear =- 1 ; return true ; } front = ( front + 1 ) % qSize ; return true ; } /** Get the front item from the queue. */ int Front () { if ( isEmpty ()) return - 1 ; return data [ front ]; } /** Get the last item from the queue. */ int Rear () { if ( isEmpty ()) return - 1 ; return data [ rear ]; } /** Checks whether the circular queue is empty or not. */ bool isEmpty () { return front ==- 1 ; } /** Checks whether the circular queue is full or not. */ bool isFull () { return ( front == ( rear + 1 ) % qSize ); } }; \u200b /** * Your MyCircularQueue object will be instantiated and called as such: * MyCircularQueue* obj = new MyCircularQueue(k); * bool param_1 = obj- enQueue(value); * bool param_2 = obj- deQueue(); * int param_3 = obj- Front(); \u200b","title":"0622-design-circular-queue"},{"location":"LeetcodeSolved/0622-design-circular-queue/#0622-design-circular-queue","text":"","title":"0622-design-circular-queue"},{"location":"LeetcodeSolved/0622-design-circular-queue/#problem","text":"Design your implementation of the circular queue. The circular queue is a linear data structure in which the operations are performed based on FIFO (First In First Out) principle and the last position is connected back to the first position to make a circle. It is also called \"Ring Buffer\". One of the benefits of the circular queue is that we can make use of the spaces in front of the queue. In a normal queue, once the queue becomes full, we cannot insert the next element even if there is a space in front of the queue. But using the circular queue, we can use the space to store new values. Your implementation should support following operations: MyCircularQueue(k) : Constructor, set the size of the queue to be k. Front : Get the front item from the queue. If the queue is empty, return -1. Rear : Get the last item from the queue. If the queue is empty, return -1. enQueue(value) : Insert an element into the circular queue. Return true if the operation is successful. deQueue() : Delete an element from the circular queue. Return true if the operation is successful. isEmpty() : Checks whether the circular queue is empty or not. isFull() : Checks whether the circular queue is full or not. Example: MyCircularQueue circularQueue = new MyCircularQueue(3); // set the size to be 3 circularQueue.enQueue(1); // return true circularQueue.enQueue(2); // return true circularQueue.enQueue(3); // return true circularQueue.enQueue(4); // return false, the queue is full circularQueue.Rear(); // return 3 circularQueue.isFull(); // return true circularQueue.deQueue(); // return true circularQueue.enQueue(4); // return true circularQueue.Rear(); // return 4 Note: All values will be in the range of [0, 1000]. The number of operations will be in the range of [1, 1000]. Please do not use the built-in Queue library.","title":"Problem"},{"location":"LeetcodeSolved/0622-design-circular-queue/#solution","text":"c++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 class MyCircularQueue { private : vector int data ; int front , rear , qSize ; public : /** Initialize your data structure here. Set the size of the queue to be k. */ MyCircularQueue ( int k ) { qSize = k ; for ( int i = 0 ; i k ; i ++ ) data . push_back ( 0 ); front = rear =- 1 ; } /** Insert an element into the circular queue. Return true if the operation is successful. */ bool enQueue ( int value ) { if ( isFull ()) return false ; if ( rear ==- 1 ) front = 0 ; rear = ( rear + 1 ) % qSize ; data [ rear ] = value ; return true ; } /** Delete an element from the circular queue. Return true if the operation is successful. */ bool deQueue () { if ( isEmpty ()) return false ; if ( front == rear ){ front = rear =- 1 ; return true ; } front = ( front + 1 ) % qSize ; return true ; } /** Get the front item from the queue. */ int Front () { if ( isEmpty ()) return - 1 ; return data [ front ]; } /** Get the last item from the queue. */ int Rear () { if ( isEmpty ()) return - 1 ; return data [ rear ]; } /** Checks whether the circular queue is empty or not. */ bool isEmpty () { return front ==- 1 ; } /** Checks whether the circular queue is full or not. */ bool isFull () { return ( front == ( rear + 1 ) % qSize ); } }; \u200b /** * Your MyCircularQueue object will be instantiated and called as such: * MyCircularQueue* obj = new MyCircularQueue(k); * bool param_1 = obj- enQueue(value); * bool param_2 = obj- deQueue(); * int param_3 = obj- Front(); \u200b","title":"Solution"},{"location":"LeetcodeSolved/0652-find-duplicate-subtrees/","text":"0652-find-duplicate-subtrees Problem Given a binary tree, return all duplicate subtrees. For each kind of duplicate subtrees, you only need to return the root node of any one of them. Two trees are duplicate if they have the same structure with same node values. Example 1: 1 / \\ 2 3 / / \\ 4 2 4 / 4 The following are two duplicate subtrees: 2 / 4 and 4 Therefore, you need to return above trees' root in the form of a list. Solution c++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 /** * Definition for a binary tree node. * struct TreeNode { * int val; * TreeNode *left; * TreeNode *right; * TreeNode(int x) : val(x), left(NULL), right(NULL) {} * }; */ \u200b // Todo : Why inorder did t worked. class Solution { public : vector TreeNode * findDuplicateSubtrees ( TreeNode * root ) { unordered_map string , int m ; vector TreeNode * ans ; dfs ( m , ans , root ); return ans ; } string dfs ( unordered_map string , int m , vector TreeNode * ans , TreeNode * root ){ if ( ! root ) return ; string s = to_string ( root - val ) + , + dfs ( m , ans , root - left ) + , + dfs ( m , ans , root - right ); if ( m [ s ] ++ == 1 ) ans . push_back ( root ); return s ; } }; \u200b","title":"0652-find-duplicate-subtrees"},{"location":"LeetcodeSolved/0652-find-duplicate-subtrees/#0652-find-duplicate-subtrees","text":"","title":"0652-find-duplicate-subtrees"},{"location":"LeetcodeSolved/0652-find-duplicate-subtrees/#problem","text":"Given a binary tree, return all duplicate subtrees. For each kind of duplicate subtrees, you only need to return the root node of any one of them. Two trees are duplicate if they have the same structure with same node values. Example 1: 1 / \\ 2 3 / / \\ 4 2 4 / 4 The following are two duplicate subtrees: 2 / 4 and 4 Therefore, you need to return above trees' root in the form of a list.","title":"Problem"},{"location":"LeetcodeSolved/0652-find-duplicate-subtrees/#solution","text":"c++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 /** * Definition for a binary tree node. * struct TreeNode { * int val; * TreeNode *left; * TreeNode *right; * TreeNode(int x) : val(x), left(NULL), right(NULL) {} * }; */ \u200b // Todo : Why inorder did t worked. class Solution { public : vector TreeNode * findDuplicateSubtrees ( TreeNode * root ) { unordered_map string , int m ; vector TreeNode * ans ; dfs ( m , ans , root ); return ans ; } string dfs ( unordered_map string , int m , vector TreeNode * ans , TreeNode * root ){ if ( ! root ) return ; string s = to_string ( root - val ) + , + dfs ( m , ans , root - left ) + , + dfs ( m , ans , root - right ); if ( m [ s ] ++ == 1 ) ans . push_back ( root ); return s ; } }; \u200b","title":"Solution"},{"location":"LeetcodeSolved/0833-find-and-replace-in-string/","text":"0833-find-and-replace-in-string Problem To some string S , we will perform some replacement operations that replace groups of letters with new ones (not necessarily the same size). Each replacement operation has 3 parameters: a starting index i , a source word x and a target word y . The rule is that if x starts at position i in the original string S , then we will replace that occurrence of x with y . If not, we do nothing. For example, if we have S = \"abcd\" and we have some replacement operation i = 2, x = \"cd\", y = \"ffff\" , then because \"cd\" starts at position 2 in the original string S , we will replace it with \"ffff\" . Using another example on S = \"abcd\" , if we have both the replacement operation i = 0, x = \"ab\", y = \"eee\" , as well as another replacement operation i = 2, x = \"ec\", y = \"ffff\" , this second operation does nothing because in the original string S[2] = 'c' , which doesn't match x[0] = 'e' . All these operations occur simultaneously. It's guaranteed that there won't be any overlap in replacement: for example, S = \"abc\", indexes = [0, 1], sources = [\"ab\",\"bc\"] is not a valid test case. Example 1: Input: S = \"abcd\", indexes = [0,2], sources = [\"a\",\"cd\"], targets = [\"eee\",\"ffff\"] Output: \"eeebffff\" Explanation: \"a\" starts at index 0 in S, so it's replaced by \"eee\". \"cd\" starts at index 2 in S, so it's replaced by \"ffff\". Example 2: Input: S = \"abcd\", indexes = [0,2], sources = [\"ab\",\"ec\"], targets = [\"eee\",\"ffff\"] Output: \"eeecd\" Explanation: \"ab\" starts at index 0 in S, so it's replaced by \"eee\". \"ec\" doesn't starts at index 2 in the original S, so we do nothing. Notes: 0 = indexes.length = sources.length = targets.length = 100 0 indexes[i] S.length = 1000 All characters in given inputs are lowercase letters. Solution c++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 class Solution { struct sortinrev { bool operator ()( const pair int , int a , const pair int , int b ) { return ( a . first b . first ); } }; \u200b public : string findReplaceString ( string S , vector int indexes , vector string sources , vector string targets ) { vector int valid ( indexes . size (), 0 ); vector pair int , int p ; for ( int i = 0 ; i indexes . size (); i ++ ){ if ( S . find ( sources [ i ], indexes [ i ]) == indexes [ i ]){ valid [ i ] = 1 ; } } for ( int i = 0 ; i indexes . size (); i ++ ) p . push_back ({ indexes [ i ], i }); sort ( p . begin (), p . end (), sortinrev ()); for ( int i = 0 ; i p . size (); i ++ ){ if ( valid [ p [ i ]. second ]){ int idx = p [ i ]. second ; S . replace ( p [ i ]. first , sources [ idx ]. size (), targets [ idx ]); } } return S ; } }; \u200b","title":"0833-find-and-replace-in-string"},{"location":"LeetcodeSolved/0833-find-and-replace-in-string/#0833-find-and-replace-in-string","text":"","title":"0833-find-and-replace-in-string"},{"location":"LeetcodeSolved/0833-find-and-replace-in-string/#problem","text":"To some string S , we will perform some replacement operations that replace groups of letters with new ones (not necessarily the same size). Each replacement operation has 3 parameters: a starting index i , a source word x and a target word y . The rule is that if x starts at position i in the original string S , then we will replace that occurrence of x with y . If not, we do nothing. For example, if we have S = \"abcd\" and we have some replacement operation i = 2, x = \"cd\", y = \"ffff\" , then because \"cd\" starts at position 2 in the original string S , we will replace it with \"ffff\" . Using another example on S = \"abcd\" , if we have both the replacement operation i = 0, x = \"ab\", y = \"eee\" , as well as another replacement operation i = 2, x = \"ec\", y = \"ffff\" , this second operation does nothing because in the original string S[2] = 'c' , which doesn't match x[0] = 'e' . All these operations occur simultaneously. It's guaranteed that there won't be any overlap in replacement: for example, S = \"abc\", indexes = [0, 1], sources = [\"ab\",\"bc\"] is not a valid test case. Example 1: Input: S = \"abcd\", indexes = [0,2], sources = [\"a\",\"cd\"], targets = [\"eee\",\"ffff\"] Output: \"eeebffff\" Explanation: \"a\" starts at index 0 in S, so it's replaced by \"eee\". \"cd\" starts at index 2 in S, so it's replaced by \"ffff\". Example 2: Input: S = \"abcd\", indexes = [0,2], sources = [\"ab\",\"ec\"], targets = [\"eee\",\"ffff\"] Output: \"eeecd\" Explanation: \"ab\" starts at index 0 in S, so it's replaced by \"eee\". \"ec\" doesn't starts at index 2 in the original S, so we do nothing. Notes: 0 = indexes.length = sources.length = targets.length = 100 0 indexes[i] S.length = 1000 All characters in given inputs are lowercase letters.","title":"Problem"},{"location":"LeetcodeSolved/0833-find-and-replace-in-string/#solution","text":"c++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 class Solution { struct sortinrev { bool operator ()( const pair int , int a , const pair int , int b ) { return ( a . first b . first ); } }; \u200b public : string findReplaceString ( string S , vector int indexes , vector string sources , vector string targets ) { vector int valid ( indexes . size (), 0 ); vector pair int , int p ; for ( int i = 0 ; i indexes . size (); i ++ ){ if ( S . find ( sources [ i ], indexes [ i ]) == indexes [ i ]){ valid [ i ] = 1 ; } } for ( int i = 0 ; i indexes . size (); i ++ ) p . push_back ({ indexes [ i ], i }); sort ( p . begin (), p . end (), sortinrev ()); for ( int i = 0 ; i p . size (); i ++ ){ if ( valid [ p [ i ]. second ]){ int idx = p [ i ]. second ; S . replace ( p [ i ]. first , sources [ idx ]. size (), targets [ idx ]); } } return S ; } }; \u200b","title":"Solution"},{"location":"LeetcodeSolved/0841-keys-and-rooms/","text":"0841-keys-and-rooms Problem There are N rooms and you start in room 0 . Each room has a distinct number in 0, 1, 2, ..., N-1 , and each room may have some keys to access the next room. Formally, each room i has a list of keys rooms[i] , and each key rooms[i][j] is an integer in [0, 1, ..., N-1] where N = rooms.length . A key rooms[i][j] = v opens the room with number v . Initially, all the rooms start locked (except for room 0 ). You can walk back and forth between rooms freely. Return true if and only if you can enter every room. Example 1: Input: [[1],[2],[3],[]] Output: true Explanation: We start in room 0, and pick up key 1. We then go to room 1, and pick up key 2. We then go to room 2, and pick up key 3. We then go to room 3. Since we were able to go to every room, we return true. Example 2: Input: [[1,3],[3,0,1],[2],[0]] Output: false Explanation: We can't enter the room with number 2. Note: 1 = rooms.length = 1000 0 = rooms[i].length = 1000 The number of keys in all rooms combined is at most 3000 . Solution c++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 class Solution { public : bool canVisitAllRooms ( vector vector int rooms ) { vector int visited ( rooms . size (), 0 ); visited [ 0 ] = 1 ; return dfsVisit ( rooms , visited , 0 ); } bool dfsVisit ( vector vector int rooms , vector int visited , int inRoom ){ for ( int i = 0 ; i rooms [ inRoom ]. size (); i ++ ){ if ( visited [ rooms [ inRoom ][ i ]] || rooms [ inRoom ][ i ] == inRoom ) continue ; visited [ rooms [ inRoom ][ i ]] = 1 ; if ( dfsVisit ( rooms , visited , rooms [ inRoom ][ i ])){ return true ; } } return isAllVisited ( visited ); } bool isAllVisited ( vector int visited ){ for ( int x : visited ) if ( ! x ) return false ; return true ; } }; \u200b","title":"0841-keys-and-rooms"},{"location":"LeetcodeSolved/0841-keys-and-rooms/#0841-keys-and-rooms","text":"","title":"0841-keys-and-rooms"},{"location":"LeetcodeSolved/0841-keys-and-rooms/#problem","text":"There are N rooms and you start in room 0 . Each room has a distinct number in 0, 1, 2, ..., N-1 , and each room may have some keys to access the next room. Formally, each room i has a list of keys rooms[i] , and each key rooms[i][j] is an integer in [0, 1, ..., N-1] where N = rooms.length . A key rooms[i][j] = v opens the room with number v . Initially, all the rooms start locked (except for room 0 ). You can walk back and forth between rooms freely. Return true if and only if you can enter every room. Example 1: Input: [[1],[2],[3],[]] Output: true Explanation: We start in room 0, and pick up key 1. We then go to room 1, and pick up key 2. We then go to room 2, and pick up key 3. We then go to room 3. Since we were able to go to every room, we return true. Example 2: Input: [[1,3],[3,0,1],[2],[0]] Output: false Explanation: We can't enter the room with number 2. Note: 1 = rooms.length = 1000 0 = rooms[i].length = 1000 The number of keys in all rooms combined is at most 3000 .","title":"Problem"},{"location":"LeetcodeSolved/0841-keys-and-rooms/#solution","text":"c++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 class Solution { public : bool canVisitAllRooms ( vector vector int rooms ) { vector int visited ( rooms . size (), 0 ); visited [ 0 ] = 1 ; return dfsVisit ( rooms , visited , 0 ); } bool dfsVisit ( vector vector int rooms , vector int visited , int inRoom ){ for ( int i = 0 ; i rooms [ inRoom ]. size (); i ++ ){ if ( visited [ rooms [ inRoom ][ i ]] || rooms [ inRoom ][ i ] == inRoom ) continue ; visited [ rooms [ inRoom ][ i ]] = 1 ; if ( dfsVisit ( rooms , visited , rooms [ inRoom ][ i ])){ return true ; } } return isAllVisited ( visited ); } bool isAllVisited ( vector int visited ){ for ( int x : visited ) if ( ! x ) return false ; return true ; } }; \u200b","title":"Solution"},{"location":"LeetcodeSolved/0973-k-closest-points-to-origin/","text":"0973-k-closest-points-to-origin Problem We have a list of points on the plane. Find the K closest points to the origin (0, 0) . (Here, the distance between two points on a plane is the Euclidean distance.) You may return the answer in any order. The answer is guaranteed to be unique (except for the order that it is in.) Example 1: Input: points = [[1,3],[-2,2]] , K = 1 Output: [[-2,2]] Explanation: The distance between (1, 3) and the origin is sqrt(10). The distance between (-2, 2) and the origin is sqrt(8). Since sqrt(8) sqrt(10), (-2, 2) is closer to the origin. We only want the closest K = 1 points from the origin, so the answer is just [[-2,2]]. Example 2: Input: points = [[3,3],[5,-1],[-2,4]] , K = 2 Output: [[3,3],[-2,4]] (The answer [[-2,4],[3,3]] would also be accepted.) Note: 1 = K = points.length = 10000 -10000 points[i][0] 10000 -10000 points[i][1] 10000 Solution c++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 class Solution { public : vector vector int kClosest ( vector vector int points , int k ) { vector vector int ans ; if ( k == 0 || points . size () == 0 ) return ans ; if ( k == points . size ()) return points ; vector int arr ; unordered_map int , vector int m ; for ( int i = 0 ; i points . size (); i ++ ){ int x = points [ i ][ 0 ]; int y = points [ i ][ 1 ]; int key = x * x + y * y ; if ( m . count ( key ) == 0 ){ m [ key ] = vector int (); m [ key ]. push_back ( i ); } else { m [ key ]. push_back ( i ); } arr . push_back ( key ); } sort ( arr . begin (), arr . end ()); int j = 0 ; while ( k ){ auto it = m . find ( arr [ j ]); vector int v = it - second ; for ( int i = 0 ; i v . size (); i ++ ){ if ( k == 0 ) break ; ans . push_back ( points [ v [ i ]]); k -- ; } j ++ ; } return ans ; } }; \u200b // Another good method is to use nth_element or partial sort to do it in O(n) time. \u200b","title":"0973-k-closest-points-to-origin"},{"location":"LeetcodeSolved/0973-k-closest-points-to-origin/#0973-k-closest-points-to-origin","text":"","title":"0973-k-closest-points-to-origin"},{"location":"LeetcodeSolved/0973-k-closest-points-to-origin/#problem","text":"We have a list of points on the plane. Find the K closest points to the origin (0, 0) . (Here, the distance between two points on a plane is the Euclidean distance.) You may return the answer in any order. The answer is guaranteed to be unique (except for the order that it is in.) Example 1: Input: points = [[1,3],[-2,2]] , K = 1 Output: [[-2,2]] Explanation: The distance between (1, 3) and the origin is sqrt(10). The distance between (-2, 2) and the origin is sqrt(8). Since sqrt(8) sqrt(10), (-2, 2) is closer to the origin. We only want the closest K = 1 points from the origin, so the answer is just [[-2,2]]. Example 2: Input: points = [[3,3],[5,-1],[-2,4]] , K = 2 Output: [[3,3],[-2,4]] (The answer [[-2,4],[3,3]] would also be accepted.) Note: 1 = K = points.length = 10000 -10000 points[i][0] 10000 -10000 points[i][1] 10000","title":"Problem"},{"location":"LeetcodeSolved/0973-k-closest-points-to-origin/#solution","text":"c++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 class Solution { public : vector vector int kClosest ( vector vector int points , int k ) { vector vector int ans ; if ( k == 0 || points . size () == 0 ) return ans ; if ( k == points . size ()) return points ; vector int arr ; unordered_map int , vector int m ; for ( int i = 0 ; i points . size (); i ++ ){ int x = points [ i ][ 0 ]; int y = points [ i ][ 1 ]; int key = x * x + y * y ; if ( m . count ( key ) == 0 ){ m [ key ] = vector int (); m [ key ]. push_back ( i ); } else { m [ key ]. push_back ( i ); } arr . push_back ( key ); } sort ( arr . begin (), arr . end ()); int j = 0 ; while ( k ){ auto it = m . find ( arr [ j ]); vector int v = it - second ; for ( int i = 0 ; i v . size (); i ++ ){ if ( k == 0 ) break ; ans . push_back ( points [ v [ i ]]); k -- ; } j ++ ; } return ans ; } }; \u200b // Another good method is to use nth_element or partial sort to do it in O(n) time. \u200b","title":"Solution"},{"location":"LeetcodeSolved/1028-recover-a-tree-from-preorder-traversal/","text":"1028-recover-a-tree-from-preorder-traversal Problem We run a preorder depth first search on the root of a binary tree. At each node in this traversal, we output D dashes (where D is the depth of this node), then we output the value of this node. (If the depth of a node is D , the depth of its immediate child is D+1 . The depth of the root node is 0 .) If a node has only one child, that child is guaranteed to be the left child. Given the output S of this traversal, recover the tree and return its root . Example 1: Input: \"1-2--3--4-5--6--7\" Output: [1,2,5,3,4,6,7] Example 2: Input: \"1-2--3---4-5--6---7\" Output: [1,2,5,3,null,6,null,4,null,7] Example 3: Input: \"1-401--349---90--88\" Output: [1,401,null,349,88,90] Note: The number of nodes in the original tree is between 1 and 1000 . Each node will have a value between 1 and 10^9 . Solution c++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 /** * Definition for a binary tree node. * struct TreeNode { * int val; * TreeNode *left; * TreeNode *right; * TreeNode(int x) : val(x), left(NULL), right(NULL) {} * }; */ class Solution { public : int getDepth ( int idx , string s ){ int cnt = 0 ; while ( idx s . size () s [ idx ] == - ){ idx ++ ; cnt ++ ; } return cnt ; } int getValue ( int idx , string s ){ int value = 0 ; while ( idx s . size () isdigit ( s [ idx ])){ value = value * 10 + ( s [ idx ] - 0 ); idx ++ ; } return value ; } TreeNode * recoverFromPreorder ( string S ) { vector pair int , int nodes ; int idx = 0 ; //parse string while ( idx S . size ()){ int depth = getDepth ( idx , S ); int value = getValue ( idx , S ); nodes . push_back ({ depth , value }); } \u200b","title":"1028-recover-a-tree-from-preorder-traversal"},{"location":"LeetcodeSolved/1028-recover-a-tree-from-preorder-traversal/#1028-recover-a-tree-from-preorder-traversal","text":"","title":"1028-recover-a-tree-from-preorder-traversal"},{"location":"LeetcodeSolved/1028-recover-a-tree-from-preorder-traversal/#problem","text":"We run a preorder depth first search on the root of a binary tree. At each node in this traversal, we output D dashes (where D is the depth of this node), then we output the value of this node. (If the depth of a node is D , the depth of its immediate child is D+1 . The depth of the root node is 0 .) If a node has only one child, that child is guaranteed to be the left child. Given the output S of this traversal, recover the tree and return its root . Example 1: Input: \"1-2--3--4-5--6--7\" Output: [1,2,5,3,4,6,7] Example 2: Input: \"1-2--3---4-5--6---7\" Output: [1,2,5,3,null,6,null,4,null,7] Example 3: Input: \"1-401--349---90--88\" Output: [1,401,null,349,88,90] Note: The number of nodes in the original tree is between 1 and 1000 . Each node will have a value between 1 and 10^9 .","title":"Problem"},{"location":"LeetcodeSolved/1028-recover-a-tree-from-preorder-traversal/#solution","text":"c++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 /** * Definition for a binary tree node. * struct TreeNode { * int val; * TreeNode *left; * TreeNode *right; * TreeNode(int x) : val(x), left(NULL), right(NULL) {} * }; */ class Solution { public : int getDepth ( int idx , string s ){ int cnt = 0 ; while ( idx s . size () s [ idx ] == - ){ idx ++ ; cnt ++ ; } return cnt ; } int getValue ( int idx , string s ){ int value = 0 ; while ( idx s . size () isdigit ( s [ idx ])){ value = value * 10 + ( s [ idx ] - 0 ); idx ++ ; } return value ; } TreeNode * recoverFromPreorder ( string S ) { vector pair int , int nodes ; int idx = 0 ; //parse string while ( idx S . size ()){ int depth = getDepth ( idx , S ); int value = getValue ( idx , S ); nodes . push_back ({ depth , value }); } \u200b","title":"Solution"},{"location":"LeetcodeSolved/1038-binary-search-tree-to-greater-sum-tree/","text":"1038-binary-search-tree-to-greater-sum-tree Problem Given the root of a binary search tree with distinct values, modify it so that every node has a new value equal to the sum of the values of the original tree that are greater than or equal to node.val . As a reminder, a binary search tree is a tree that satisfies these constraints: The left subtree of a node contains only nodes with keys less than the node's key. The right subtree of a node contains only nodes with keys greater than the node's key. Both the left and right subtrees must also be binary search trees. Example 1: Input: [4,1,6,0,2,5,7,null,null,null,3,null,null,null,8] Output: [30,36,21,36,35,26,15,null,null,null,33,null,null,null,8] Note: The number of nodes in the tree is between 1 and 100 . Each node will have value between 0 and 100 . The given tree is a binary search tree. Solution c++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 /** * Definition for a binary tree node. * struct TreeNode { * int val; * TreeNode *left; * TreeNode *right; * TreeNode(int x) : val(x), left(NULL), right(NULL) {} * }; */ class Solution { public : TreeNode * bstToGst ( TreeNode * root ) { if ( root == NULL ) return root ; if ( root - right != NULL ){ int rvalue = toGST ( root - right , 0 ); root - val = rvalue + root - val ; } if ( root - left != NULL ){ int lvalue = toGST ( root - left , root - val ); } return root ; } int toGST ( TreeNode * root , int value ){ int x = 0 , y = 0 ; if ( root - right != NULL ){ y = toGST ( root - right , value ); } if ( y == 0 ) root - val = root - val + value ; else root - val = root - val + y ; if ( root - left != NULL ){ x = toGST ( root - left , root - val ); return x ; } return root - val ; } }; \u200b","title":"1038-binary-search-tree-to-greater-sum-tree"},{"location":"LeetcodeSolved/1038-binary-search-tree-to-greater-sum-tree/#1038-binary-search-tree-to-greater-sum-tree","text":"","title":"1038-binary-search-tree-to-greater-sum-tree"},{"location":"LeetcodeSolved/1038-binary-search-tree-to-greater-sum-tree/#problem","text":"Given the root of a binary search tree with distinct values, modify it so that every node has a new value equal to the sum of the values of the original tree that are greater than or equal to node.val . As a reminder, a binary search tree is a tree that satisfies these constraints: The left subtree of a node contains only nodes with keys less than the node's key. The right subtree of a node contains only nodes with keys greater than the node's key. Both the left and right subtrees must also be binary search trees. Example 1: Input: [4,1,6,0,2,5,7,null,null,null,3,null,null,null,8] Output: [30,36,21,36,35,26,15,null,null,null,33,null,null,null,8] Note: The number of nodes in the tree is between 1 and 100 . Each node will have value between 0 and 100 . The given tree is a binary search tree.","title":"Problem"},{"location":"LeetcodeSolved/1038-binary-search-tree-to-greater-sum-tree/#solution","text":"c++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 /** * Definition for a binary tree node. * struct TreeNode { * int val; * TreeNode *left; * TreeNode *right; * TreeNode(int x) : val(x), left(NULL), right(NULL) {} * }; */ class Solution { public : TreeNode * bstToGst ( TreeNode * root ) { if ( root == NULL ) return root ; if ( root - right != NULL ){ int rvalue = toGST ( root - right , 0 ); root - val = rvalue + root - val ; } if ( root - left != NULL ){ int lvalue = toGST ( root - left , root - val ); } return root ; } int toGST ( TreeNode * root , int value ){ int x = 0 , y = 0 ; if ( root - right != NULL ){ y = toGST ( root - right , value ); } if ( y == 0 ) root - val = root - val + value ; else root - val = root - val + y ; if ( root - left != NULL ){ x = toGST ( root - left , root - val ); return x ; } return root - val ; } }; \u200b","title":"Solution"},{"location":"LeetcodeSolved/1048-longest-string-chain/","text":"1048-longest-string-chain Problem Given a list of words, each word consists of English lowercase letters. Let's say word1 is a predecessor of word2 if and only if we can add exactly one letter anywhere in word1 to make it equal to word2 . For example, \"abc\" is a predecessor of \"abac\" . A word chain is a sequence of words [word_1, word_2, ..., word_k] with k = 1 , where word_1 is a predecessor of word_2 , word_2 is a predecessor of word_3 , and so on. Return the longest possible length of a word chain with words chosen from the given list of words . Example 1: Input: [\"a\",\"b\",\"ba\",\"bca\",\"bda\",\"bdca\"] Output: 4 Explanation : one of the longest word chain is \"a\",\"ba\",\"bda\",\"bdca\". Note: 1 = words.length = 1000 1 = words[i].length = 16 words[i] only consists of English lowercase letters. Solution c++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 class Solution { vector int freq ; public : int longestStrChain ( vector string words ) { if ( words . size () == 1 ) return 1 ; // Sort words in assending order of size sort ( words . begin (), words . end (),[]( string a , string b ){ return a . size () b . size ();}); int n = words . size (); // dp[i] represents longest chain from index i till n-1 index vector int dp ( n , 1 ); int maxChain = 1 ; // for n-1 index longest chain contains only words[n-1] // for every index from n-2 to 0, retrive the longest chain after it. for ( int i = n - 2 ; i = 0 ; i -- ){ for ( int j = i + 1 ; j n ; j ++ ){ if ( words [ j ]. size () == words [ i ]. size () + 1 ){ // If words[i] is predecessor of words[j] than chain will be incremented by 1 // Store max of all chains possible from words[i] if ( isPred ( words [ i ], words [ j ])){ dp [ i ] = max ( dp [ i ], dp [ j ] + 1 ); } } // Difference of exactly one letter else if ( words [ j ]. size () words [ i ]. size () + 1 ) break ; } // If chain from words[i] is longest than store it in maxChain maxChain = max ( maxChain , dp [ i ]); } \u200b","title":"1048-longest-string-chain"},{"location":"LeetcodeSolved/1048-longest-string-chain/#1048-longest-string-chain","text":"","title":"1048-longest-string-chain"},{"location":"LeetcodeSolved/1048-longest-string-chain/#problem","text":"Given a list of words, each word consists of English lowercase letters. Let's say word1 is a predecessor of word2 if and only if we can add exactly one letter anywhere in word1 to make it equal to word2 . For example, \"abc\" is a predecessor of \"abac\" . A word chain is a sequence of words [word_1, word_2, ..., word_k] with k = 1 , where word_1 is a predecessor of word_2 , word_2 is a predecessor of word_3 , and so on. Return the longest possible length of a word chain with words chosen from the given list of words . Example 1: Input: [\"a\",\"b\",\"ba\",\"bca\",\"bda\",\"bdca\"] Output: 4 Explanation : one of the longest word chain is \"a\",\"ba\",\"bda\",\"bdca\". Note: 1 = words.length = 1000 1 = words[i].length = 16 words[i] only consists of English lowercase letters.","title":"Problem"},{"location":"LeetcodeSolved/1048-longest-string-chain/#solution","text":"c++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 class Solution { vector int freq ; public : int longestStrChain ( vector string words ) { if ( words . size () == 1 ) return 1 ; // Sort words in assending order of size sort ( words . begin (), words . end (),[]( string a , string b ){ return a . size () b . size ();}); int n = words . size (); // dp[i] represents longest chain from index i till n-1 index vector int dp ( n , 1 ); int maxChain = 1 ; // for n-1 index longest chain contains only words[n-1] // for every index from n-2 to 0, retrive the longest chain after it. for ( int i = n - 2 ; i = 0 ; i -- ){ for ( int j = i + 1 ; j n ; j ++ ){ if ( words [ j ]. size () == words [ i ]. size () + 1 ){ // If words[i] is predecessor of words[j] than chain will be incremented by 1 // Store max of all chains possible from words[i] if ( isPred ( words [ i ], words [ j ])){ dp [ i ] = max ( dp [ i ], dp [ j ] + 1 ); } } // Difference of exactly one letter else if ( words [ j ]. size () words [ i ]. size () + 1 ) break ; } // If chain from words[i] is longest than store it in maxChain maxChain = max ( maxChain , dp [ i ]); } \u200b","title":"Solution"},{"location":"LeetcodeSolved/1049-last-stone-weight-ii/","text":"1049-last-stone-weight-ii Problem We have a collection of rocks, each rock has a positive integer weight. Each turn, we choose any two rocks and smash them together. Suppose the stones have weights x and y with x = y . The result of this smash is: If x == y , both stones are totally destroyed; If x != y , the stone of weight x is totally destroyed, and the stone of weight y has new weight y-x . At the end, there is at most 1 stone left. Return the smallest possible weight of this stone (the weight is 0 if there are no stones left.) Example 1: Input: [2,7,4,1,8,1] Output: 1 Explanation: We can combine 2 and 4 to get 2 so the array converts to [2,7,1,8,1] then, we can combine 7 and 8 to get 1 so the array converts to [2,1,1,1] then, we can combine 2 and 1 to get 1 so the array converts to [1,1,1] then, we can combine 1 and 1 to get 0 so the array converts to [1] then that's the optimal value. Note: 1 = stones.length = 30 1 = stones[i] = 100 Solution c++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 class Solution { private : int sumStone ; public : int lastStoneWeightII ( vector int stones ) { if ( stones . size () == 0 ) return 0 ; if ( stones . size () == 1 ) return stones [ 0 ]; sumStone = accumulate ( stones . begin (), stones . end (), 0 ); vector vector int dp ( sumStone , vector int ( stones . size (), - 1 )); return minRock ( stones , dp , 0 , 0 ); } int minRock ( vector int stones , vector vector int dp , int cost , int ptr ){ if ( ptr == stones . size ()) return abs ( sumStone - 2 * cost ); if ( dp [ cost ][ ptr ] != - 1 ) return dp [ cost ][ ptr ]; return dp [ cost ][ ptr ] = min ( minRock ( stones , dp , cost + stones [ ptr ], ptr + 1 ), minRock ( stones , dp , cost , ptr + 1 )); } }; \u200b","title":"1049-last-stone-weight-ii"},{"location":"LeetcodeSolved/1049-last-stone-weight-ii/#1049-last-stone-weight-ii","text":"","title":"1049-last-stone-weight-ii"},{"location":"LeetcodeSolved/1049-last-stone-weight-ii/#problem","text":"We have a collection of rocks, each rock has a positive integer weight. Each turn, we choose any two rocks and smash them together. Suppose the stones have weights x and y with x = y . The result of this smash is: If x == y , both stones are totally destroyed; If x != y , the stone of weight x is totally destroyed, and the stone of weight y has new weight y-x . At the end, there is at most 1 stone left. Return the smallest possible weight of this stone (the weight is 0 if there are no stones left.) Example 1: Input: [2,7,4,1,8,1] Output: 1 Explanation: We can combine 2 and 4 to get 2 so the array converts to [2,7,1,8,1] then, we can combine 7 and 8 to get 1 so the array converts to [2,1,1,1] then, we can combine 2 and 1 to get 1 so the array converts to [1,1,1] then, we can combine 1 and 1 to get 0 so the array converts to [1] then that's the optimal value. Note: 1 = stones.length = 30 1 = stones[i] = 100","title":"Problem"},{"location":"LeetcodeSolved/1049-last-stone-weight-ii/#solution","text":"c++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 class Solution { private : int sumStone ; public : int lastStoneWeightII ( vector int stones ) { if ( stones . size () == 0 ) return 0 ; if ( stones . size () == 1 ) return stones [ 0 ]; sumStone = accumulate ( stones . begin (), stones . end (), 0 ); vector vector int dp ( sumStone , vector int ( stones . size (), - 1 )); return minRock ( stones , dp , 0 , 0 ); } int minRock ( vector int stones , vector vector int dp , int cost , int ptr ){ if ( ptr == stones . size ()) return abs ( sumStone - 2 * cost ); if ( dp [ cost ][ ptr ] != - 1 ) return dp [ cost ][ ptr ]; return dp [ cost ][ ptr ] = min ( minRock ( stones , dp , cost + stones [ ptr ], ptr + 1 ), minRock ( stones , dp , cost , ptr + 1 )); } }; \u200b","title":"Solution"},{"location":"LeetcodeSolved/1054-distant-barcodes/","text":"1054-distant-barcodes Problem In a warehouse, there is a row of barcodes, where the i -th barcode is barcodes[i] . Rearrange the barcodes so that no two adjacent barcodes are equal. You may return any answer, and it is guaranteed an answer exists. Example 1: Input: [1,1,1,2,2,2] Output: [2,1,2,1,2,1] Example 2: Input: [1,1,1,1,2,2,3,3] Output: [1,3,1,3,2,1,2,1] Note: 1 = barcodes.length = 10000 1 = barcodes[i] = 10000 Solution c++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 // struct comp{ // bool operator()(const pair int,int a,const pair int,int b){ // return a.first b.first; // } // } \u200b // Alternative : Fix the most frequent first and then order does not matter, fill all in gaps O(n) class Solution { public : vector int rearrangeBarcodes ( vector int barcodes ) { if ( barcodes . size () = 2 ) return barcodes ; unordered_map int , int m ; int n = barcodes . size (); for ( int i : barcodes ) m [ i ] ++ ; priority_queue pair int , int pq ; for ( auto i : m ){ pq . push ({ i . second , i . first }); } pair int , int tmp = pq . top (); pq . pop (); for ( int i = 0 ; i n ; i += 2 ){ if ( tmp . first == 0 ){ tmp = pq . top (); pq . pop (); } barcodes [ i ] = tmp . second ; tmp . first -= 1 ; } for ( int i = 1 ; i n ; i += 2 ){ if ( tmp . first == 0 ){ tmp = pq . top (); pq . pop (); } barcodes [ i ] = tmp . second ; tmp . first -= 1 ; } return barcodes ; } }; \u200b","title":"1054-distant-barcodes"},{"location":"LeetcodeSolved/1054-distant-barcodes/#1054-distant-barcodes","text":"","title":"1054-distant-barcodes"},{"location":"LeetcodeSolved/1054-distant-barcodes/#problem","text":"In a warehouse, there is a row of barcodes, where the i -th barcode is barcodes[i] . Rearrange the barcodes so that no two adjacent barcodes are equal. You may return any answer, and it is guaranteed an answer exists. Example 1: Input: [1,1,1,2,2,2] Output: [2,1,2,1,2,1] Example 2: Input: [1,1,1,1,2,2,3,3] Output: [1,3,1,3,2,1,2,1] Note: 1 = barcodes.length = 10000 1 = barcodes[i] = 10000","title":"Problem"},{"location":"LeetcodeSolved/1054-distant-barcodes/#solution","text":"c++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 // struct comp{ // bool operator()(const pair int,int a,const pair int,int b){ // return a.first b.first; // } // } \u200b // Alternative : Fix the most frequent first and then order does not matter, fill all in gaps O(n) class Solution { public : vector int rearrangeBarcodes ( vector int barcodes ) { if ( barcodes . size () = 2 ) return barcodes ; unordered_map int , int m ; int n = barcodes . size (); for ( int i : barcodes ) m [ i ] ++ ; priority_queue pair int , int pq ; for ( auto i : m ){ pq . push ({ i . second , i . first }); } pair int , int tmp = pq . top (); pq . pop (); for ( int i = 0 ; i n ; i += 2 ){ if ( tmp . first == 0 ){ tmp = pq . top (); pq . pop (); } barcodes [ i ] = tmp . second ; tmp . first -= 1 ; } for ( int i = 1 ; i n ; i += 2 ){ if ( tmp . first == 0 ){ tmp = pq . top (); pq . pop (); } barcodes [ i ] = tmp . second ; tmp . first -= 1 ; } return barcodes ; } }; \u200b","title":"Solution"},{"location":"LeetcodeSolved/1071-greatest-common-divisor-of-strings/","text":"1071-greatest-common-divisor-of-strings Problem For strings S and T , we say \" T divides S \" if and only if S = T + ... + T ( T concatenated with itself 1 or more times) Return the largest string X such that X divides str1 and X divides str2 . Example 1: Input: str1 = \"ABCABC\" , str2 = \"ABC\" Output: \"ABC\" Example 2: Input: str1 = \"ABABAB\" , str2 = \"ABAB\" Output: \"AB\" Example 3: Input: str1 = \"LEET\" , str2 = \"CODE\" Output: \"\" Note: 1 = str1.length = 1000 1 = str2.length = 1000 str1[i] and str2[i] are English uppercase letters. Solution c++ 1 2 3 4 5 6 7 8 9 10 11 12 13 class Solution { public : string gcdOfStrings ( string str1 , string str2 ) { if ( str1 . size () str2 . size ()) return gcdOfStrings ( str2 , str1 ); if ( str2 . empty ()) return str1 ; if ( str1 . substr ( 0 , str2 . size ()) != str2 ) return ; return gcdOfStrings ( str1 . substr ( str2 . size ()), str2 ); } }; \u200b // Discuss Solution // Modulo approach is wrong here \u200b","title":"1071-greatest-common-divisor-of-strings"},{"location":"LeetcodeSolved/1071-greatest-common-divisor-of-strings/#1071-greatest-common-divisor-of-strings","text":"","title":"1071-greatest-common-divisor-of-strings"},{"location":"LeetcodeSolved/1071-greatest-common-divisor-of-strings/#problem","text":"For strings S and T , we say \" T divides S \" if and only if S = T + ... + T ( T concatenated with itself 1 or more times) Return the largest string X such that X divides str1 and X divides str2 . Example 1: Input: str1 = \"ABCABC\" , str2 = \"ABC\" Output: \"ABC\" Example 2: Input: str1 = \"ABABAB\" , str2 = \"ABAB\" Output: \"AB\" Example 3: Input: str1 = \"LEET\" , str2 = \"CODE\" Output: \"\" Note: 1 = str1.length = 1000 1 = str2.length = 1000 str1[i] and str2[i] are English uppercase letters.","title":"Problem"},{"location":"LeetcodeSolved/1071-greatest-common-divisor-of-strings/#solution","text":"c++ 1 2 3 4 5 6 7 8 9 10 11 12 13 class Solution { public : string gcdOfStrings ( string str1 , string str2 ) { if ( str1 . size () str2 . size ()) return gcdOfStrings ( str2 , str1 ); if ( str2 . empty ()) return str1 ; if ( str1 . substr ( 0 , str2 . size ()) != str2 ) return ; return gcdOfStrings ( str1 . substr ( str2 . size ()), str2 ); } }; \u200b // Discuss Solution // Modulo approach is wrong here \u200b","title":"Solution"},{"location":"LeetcodeSolved/1072-flip-columns-for-maximum-number-of-equal-rows/","text":"1072-flip-columns-for-maximum-number-of-equal-rows Problem Given a matrix consisting of 0s and 1s, we may choose any number of columns in the matrix and flip every cell in that column. Flipping a cell changes the value of that cell from 0 to 1 or from 1 to 0. Return the maximum number of rows that have all values equal after some number of flips. Example 1: Input: [[0,1],[1,1]] Output: 1 Explanation: After flipping no values, 1 row has all values equal. Example 2: Input: [[0,1],[1,0]] Output: 2 Explanation: After flipping values in the first column, both rows have equal values. Example 3: Input: [[0,0,0],[0,0,1],[1,1,0]] Output: 2 Explanation: After flipping values in the first two columns, the last two rows have equal values. Note: 1 = matrix.length = 300 1 = matrix[i].length = 300 All matrix[i].length 's are equal matrix[i][j] is 0 or 1 Solution c++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 //Must Redo Again \u200b // Concept find max no. of rows that can be toogled together. \u200b class Solution { public : int maxEqualRowsAfterFlips ( vector vector int m ) { if ( m . size () == 0 ) return 0 ; int ans = 1 ; while ( m . size () 0 ){ int cnt = 1 ; for ( int j = 1 ; j m . size (); j ++ ){ int eq = 1 , xoreq = 1 ; for ( int k = 0 ; k m [ 0 ]. size (); k ++ ){ eq = m [ 0 ][ k ] == m [ j ][ k ]; xoreq = m [ 0 ][ k ] != m [ j ][ k ]; } if ( eq || xoreq ){ cnt ++ ; swap ( m [ j -- ], m [ m . size () - 1 ]); m . pop_back (); } } ans = max ( ans , cnt ); swap ( m [ 0 ], m [ m . size () - 1 ]); m . pop_back (); } return ans ; } }; \u200b","title":"1072-flip-columns-for-maximum-number-of-equal-rows"},{"location":"LeetcodeSolved/1072-flip-columns-for-maximum-number-of-equal-rows/#1072-flip-columns-for-maximum-number-of-equal-rows","text":"","title":"1072-flip-columns-for-maximum-number-of-equal-rows"},{"location":"LeetcodeSolved/1072-flip-columns-for-maximum-number-of-equal-rows/#problem","text":"Given a matrix consisting of 0s and 1s, we may choose any number of columns in the matrix and flip every cell in that column. Flipping a cell changes the value of that cell from 0 to 1 or from 1 to 0. Return the maximum number of rows that have all values equal after some number of flips. Example 1: Input: [[0,1],[1,1]] Output: 1 Explanation: After flipping no values, 1 row has all values equal. Example 2: Input: [[0,1],[1,0]] Output: 2 Explanation: After flipping values in the first column, both rows have equal values. Example 3: Input: [[0,0,0],[0,0,1],[1,1,0]] Output: 2 Explanation: After flipping values in the first two columns, the last two rows have equal values. Note: 1 = matrix.length = 300 1 = matrix[i].length = 300 All matrix[i].length 's are equal matrix[i][j] is 0 or 1","title":"Problem"},{"location":"LeetcodeSolved/1072-flip-columns-for-maximum-number-of-equal-rows/#solution","text":"c++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 //Must Redo Again \u200b // Concept find max no. of rows that can be toogled together. \u200b class Solution { public : int maxEqualRowsAfterFlips ( vector vector int m ) { if ( m . size () == 0 ) return 0 ; int ans = 1 ; while ( m . size () 0 ){ int cnt = 1 ; for ( int j = 1 ; j m . size (); j ++ ){ int eq = 1 , xoreq = 1 ; for ( int k = 0 ; k m [ 0 ]. size (); k ++ ){ eq = m [ 0 ][ k ] == m [ j ][ k ]; xoreq = m [ 0 ][ k ] != m [ j ][ k ]; } if ( eq || xoreq ){ cnt ++ ; swap ( m [ j -- ], m [ m . size () - 1 ]); m . pop_back (); } } ans = max ( ans , cnt ); swap ( m [ 0 ], m [ m . size () - 1 ]); m . pop_back (); } return ans ; } }; \u200b","title":"Solution"}]}